-- version = 51
-- 2022-04-29 09:22:20.975135--
-- PostgreSQL database dump
--

-- Dumped from database version 13.4
-- Dumped by pg_dump version 13.3

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: api; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA api;


--
-- Name: aws_commons; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS aws_commons WITH SCHEMA public;


--
-- Name: EXTENSION aws_commons; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION aws_commons IS 'Common data types across AWS services';


--
-- Name: aws_lambda; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS aws_lambda WITH SCHEMA public;


--
-- Name: EXTENSION aws_lambda; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION aws_lambda IS 'AWS Lambda integration';


--
-- Name: dev; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA dev;


--
-- Name: reclada; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA reclada;


--
-- Name: reclada_notification; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA reclada_notification;


--
-- Name: reclada_object; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA reclada_object;


--
-- Name: reclada_revision; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA reclada_revision;


--
-- Name: reclada_storage; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA reclada_storage;


--
-- Name: reclada_user; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA reclada_user;


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- Name: dp_bhvr; Type: TYPE; Schema: reclada; Owner: -
--

CREATE TYPE reclada.dp_bhvr AS ENUM (
    'Replace',
    'Update',
    'Reject',
    'Copy',
    'Insert',
    'Merge'
);


--
-- Name: auth_get_login_url(jsonb); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.auth_get_login_url(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    base_url VARCHAR;
    client_id VARCHAR;
BEGIN
    SELECT oidc_url, oidc_client_id INTO base_url, client_id
        FROM reclada.auth_setting;
    IF base_url IS NULL THEN
        RETURN jsonb_build_object('login_url', NULL);
    ELSE
        RETURN jsonb_build_object('login_url', format(
            '%s/auth?client_id=%s&response_type=code',
            base_url, client_id
        ));
    END IF;
END;
$$;


--
-- Name: hello_world(jsonb); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.hello_world(data jsonb) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
SELECT 'Hello, world!';
$$;


--
-- Name: hello_world(text); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.hello_world(data text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
SELECT 'Hello, world!';
$$;


--
-- Name: reclada_object_create(jsonb, text, text); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.reclada_object_create(data jsonb, ver text DEFAULT '1'::text, draft text DEFAULT 'false'::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    data_jsonb       jsonb;
    class            text;
    user_info        jsonb;
    attrs            jsonb;
    data_to_create   jsonb = '[]'::jsonb;
    result           jsonb;
    _need_flat       bool := false;
    _draft           bool;
    _guid            uuid;
    _f_name          text := 'api.reclada_object_create';
BEGIN

    _draft := draft != 'false';

    IF (jsonb_typeof(data) != 'array') THEN
        data := '[]'::jsonb || data;
    END IF;

    FOR data_jsonb IN SELECT jsonb_array_elements(data) LOOP

        _guid := CASE ver
                        when '1'
                            then data_jsonb->>'GUID'
                        when '2'
                            then data_jsonb->>'{GUID}'
                    end;
        if _draft then
            if _guid is null then
                perform reclada.raise_exception('GUID is required.',_f_name);
            end if;
            INSERT into reclada.draft(guid,data)
                values(_guid,data_jsonb);
        else

             class := CASE ver
                            when '1'
                                then data_jsonb->>'class'
                            when '2'
                                then data_jsonb->>'{class}'
                        end;

            IF (class IS NULL) THEN
                RAISE EXCEPTION 'The reclada object class is not specified (api)';
            END IF;

            SELECT reclada_user.auth_by_token(data_jsonb->>'accessToken') INTO user_info;
            data_jsonb := data_jsonb - 'accessToken';

            IF (NOT(reclada_user.is_allowed(user_info, 'create', class))) THEN
                RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'create', class;
            END IF;
            
            if ver = '2' then
                _need_flat := true;
                with recursive j as 
                (
                    select  row_number() over() as id,
                            key,
                            value 
                        from jsonb_each(data_jsonb)
                            where key like '{%}'
                ),
                inn as 
                (
                    SELECT  row_number() over(order by s.id,j.id) rn,
                            j.id,
                            s.id sid,
                            s.d,
                            ARRAY (
                                SELECT UNNEST(arr.v) 
                                LIMIT array_position(arr.v, s.d)
                            ) as k
                        FROM j
                        left join lateral
                        (
                            select id, d ,max(id) over() mid
                            from
                            (
                                SELECT  row_number() over() as id, 
                                        d
                                    from regexp_split_to_table(substring(j.key,2,char_length(j.key)-2),',') d 
                            ) t
                        ) s on s.mid != s.id
                        join lateral
                        (
                            select regexp_split_to_array(substring(j.key,2,char_length(j.key)-2),',') v
                        ) arr on true
                            where d is not null
                ),
                src as
                (
                    select  reclada.jsonb_deep_set('{}'::jsonb,('{'|| i.d ||'}')::text[],'{}'::jsonb) r,
                            i.rn
                        from inn i
                            where i.rn = 1
                    union
                    select  reclada.jsonb_deep_set(
                                s.r,
                                i.k,
                                '{}'::jsonb
                            ) r,
                            i.rn
                        from src s
                        join inn i
                            on s.rn + 1 = i.rn
                ),
                tmpl as 
                (
                    select r v
                        from src
                        ORDER BY rn DESC
                        limit 1
                ),
                res as
                (
                    SELECT jsonb_set(
                            (select v from tmpl),
                            j.key::text[],
                            j.value
                        ) v,
                        j.id
                        FROM j
                            where j.id = 1
                    union 
                    select jsonb_set(
                            res.v,
                            j.key::text[],
                            j.value
                        ) v,
                        j.id
                        FROM res
                        join j
                            on res.id + 1 =j.id
                )
                SELECT v 
                    FROM res
                    ORDER BY ID DESC
                    limit 1
                    into data_jsonb;
            end if;

            if data_jsonb is null then
                RAISE EXCEPTION 'JSON invalid';
            end if;
            data_to_create := data_to_create || data_jsonb;
        end if;
    END LOOP;

    if data_to_create is not  null then
        SELECT reclada_object.create(data_to_create, user_info) 
            INTO result;
    end if;
    if ver = '2' or _draft then
        RETURN '{"status":"OK"}'::jsonb;
    end if;
    RETURN result;

END;
$$;


--
-- Name: reclada_object_delete(jsonb, text, text); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.reclada_object_delete(data jsonb, ver text DEFAULT '1'::text, draft text DEFAULT 'false'::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    class         text;
    obj_id        uuid;
    user_info     jsonb;
    result        jsonb;

BEGIN

    obj_id := CASE ver
                when '1'
                    then data->>'GUID'
                when '2'
                    then data->>'{GUID}'
            end;
    IF (obj_id IS NULL) THEN
        RAISE EXCEPTION 'Could not delete object with no id';
    END IF;

    if draft != 'false' then
        delete from reclada.draft 
            where guid = obj_id;
        
    else

        class := CASE ver
                        when '1'
                            then data->>'class'
                        when '2'
                            then data->>'{class}'
                    end;
        IF (class IS NULL) THEN
            RAISE EXCEPTION 'reclada object class not specified';
        END IF;

        data := data || ('{"GUID":"'|| obj_id ||'","class":"'|| class ||'"}')::jsonb;

        SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;
        data := data - 'accessToken';

        IF (NOT(reclada_user.is_allowed(user_info, 'delete', class))) THEN
            RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'delete', class;
        END IF;

        SELECT reclada_object.delete(data, user_info) INTO result;

    end if;

    if ver = '2' or draft != 'false' then 
        RETURN '{"status":"OK"}'::jsonb;
    end if;

    RETURN result;

END;
$$;


--
-- Name: reclada_object_get_transaction_id(jsonb); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.reclada_object_get_transaction_id(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
BEGIN
    return reclada_object.get_transaction_id(data);
END;
$$;


--
-- Name: reclada_object_list(jsonb, text, text); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.reclada_object_list(data jsonb DEFAULT NULL::jsonb, ver text DEFAULT '1'::text, draft text DEFAULT 'false'::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    _class              text;
    user_info           jsonb;
    result              jsonb;
    _filter             jsonb;
    _guid               uuid;
BEGIN

    if draft != 'false' then
        return array_to_json
            (
                array
                (
                    SELECT o.data 
                        FROM reclada.draft o
                            where id = 
                                (
                                    select max(id) 
                                        FROM reclada.draft d
                                            where o.guid = d.guid
                                )
                            -- and o.user = user_info->>'guid'
                )
            )::jsonb;
    end if;

    _class := CASE ver
                when '1'
                    then data->>'class'
                when '2'
                    then data->>'{class}'
            end;
    IF(_class IS NULL) THEN
        RAISE EXCEPTION 'reclada object class not specified';
    END IF;

    _guid := CASE ver
        when '1'
            then data->>'GUID'
        when '2'
            then data->>'{GUID}'
    end;

    _filter = data->'filter';

    if _guid is not null then
        SELECT format(  '{
                            "operator":"AND",
                            "value":[
                                {
                                    "operator":"=",
                                    "value":["{class}","%s"]
                                },
                                {
                                    "operator":"=",
                                    "value":["{GUID}","%s"]
                                }
                            ]
                        }',
                    _class,
                    _guid
                )::jsonb 
            INTO _filter;

    ELSEIF _filter IS NOT NULL THEN
        SELECT format(  '{
                            "operator":"AND",
                            "value":[
                                {
                                    "operator":"=",
                                    "value":["{class}","%s"]
                                },
                                %s
                            ]
                        }',
                _class,
                _filter
            )::jsonb 
            INTO _filter;
    ELSEIF ver = '2' then
        SELECT format( '{
                            "operator":"=",
                            "value":["{class}","%s"]
                        }',
                _class
            )::jsonb 
            INTO _filter;
    END IF;
    
    IF _filter IS NOT NULL THEN
        data := Jsonb_set(data,'{filter}', _filter);
    END IF;

    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;
    data := data - 'accessToken';

    IF (NOT(reclada_user.is_allowed(user_info, 'list', _class))) THEN
        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list', _class;
    END IF;

    SELECT reclada_object.list(data, true, ver) 
        INTO result;
    RETURN result;

END;
$$;


--
-- Name: reclada_object_list_add(jsonb); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.reclada_object_list_add(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    class          text;
    obj_id         uuid;
    user_info      jsonb;
    field_value    jsonb;
    values_to_add  jsonb;
    result         jsonb;

BEGIN

    class := data->>'class';
    IF (class IS NULL) THEN
        RAISE EXCEPTION 'The reclada object class is not specified';
    END IF;

    obj_id := (data->>'GUID')::uuid;
    IF (obj_id IS NULL) THEN
        RAISE EXCEPTION 'There is no GUID';
    END IF;

    field_value := data->'field';
    IF (field_value IS NULL) THEN
        RAISE EXCEPTION 'There is no field';
    END IF;

    values_to_add := data->'value';
    IF (values_to_add IS NULL OR values_to_add = 'null'::jsonb) THEN
        RAISE EXCEPTION 'The value should not be null';
    END IF;

    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;
    data := data - 'accessToken';

    IF (NOT(reclada_user.is_allowed(user_info, 'list_add', class))) THEN
        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list_add', class;
    END IF;

    SELECT reclada_object.list_add(data) INTO result;
    RETURN result;

END;
$$;


--
-- Name: reclada_object_list_drop(jsonb); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.reclada_object_list_drop(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    class           text;
    obj_id          uuid;
    user_info       jsonb;
    field_value     jsonb;
    values_to_drop  jsonb;
    result          jsonb;

BEGIN

	class := data->>'class';
	IF (class IS NULL) THEN
		RAISE EXCEPTION 'The reclada object class is not specified';
	END IF;

	obj_id := (data->>'GUID')::uuid;
	IF (obj_id IS NULL) THEN
		RAISE EXCEPTION 'There is no GUID';
	END IF;

	field_value := data->'field';
	IF (field_value IS NULL OR field_value = 'null'::jsonb) THEN
		RAISE EXCEPTION 'There is no field';
	END IF;

	values_to_drop := data->'value';
	IF (values_to_drop IS NULL OR values_to_drop = 'null'::jsonb) THEN
		RAISE EXCEPTION 'The value should not be null';
	END IF;

    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;
    data := data - 'accessToken';

    IF (NOT(reclada_user.is_allowed(user_info, 'list_add', class))) THEN
        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list_add', class;
    END IF;

    SELECT reclada_object.list_drop(data) INTO result;
    RETURN result;

END;
$$;


--
-- Name: reclada_object_list_related(jsonb); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.reclada_object_list_related(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    class          text;
    obj_id         uuid;
    field          jsonb;
    related_class  jsonb;
    user_info      jsonb;
    result         jsonb;

BEGIN
    class := data->>'class';
    IF (class IS NULL) THEN
        RAISE EXCEPTION 'The reclada object class is not specified';
    END IF;

    obj_id := (data->>'GUID')::uuid;
    IF (obj_id IS NULL) THEN
        RAISE EXCEPTION 'The object GUID is not specified';
    END IF;

    field := data->'field';
    IF (field IS NULL) THEN
        RAISE EXCEPTION 'The object field is not specified';
    END IF;

    related_class := data->'relatedClass';
    IF (related_class IS NULL) THEN
        RAISE EXCEPTION 'The related class is not specified';
    END IF;

    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;
    data := data - 'accessToken';

    IF (NOT(reclada_user.is_allowed(user_info, 'list_related', class))) THEN
        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list_related', class;
    END IF;

    SELECT reclada_object.list_related(data) INTO result;

    RETURN result;

END;
$$;


--
-- Name: reclada_object_update(jsonb, text); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.reclada_object_update(data jsonb, ver text DEFAULT '1'::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    class         text;
    objid         uuid;
    attrs         jsonb;
    user_info     jsonb;
    result        jsonb;
    _need_flat    bool := false;

BEGIN

    class := CASE ver
            when '1'
                then data->>'class'
            when '2'
                then data->>'{class}'
        end;

    IF (class IS NULL) THEN
        RAISE EXCEPTION 'reclada object class not specified';
    END IF;

    objid := CASE ver
            when '1'
                then data->>'GUID'
            when '2'
                then data->>'{GUID}'
        end;
    IF (objid IS NULL) THEN
        RAISE EXCEPTION 'Could not update object with no GUID';
    END IF;
    
    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;
    data := data - 'accessToken';

    IF (NOT(reclada_user.is_allowed(user_info, 'update', class))) THEN
        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'update', class;
    END IF;

    if ver = '2' then

        with recursive j as 
        (
            select  row_number() over() as id,
                    key,
                    value 
                from jsonb_each(data)
                    where key like '{%}'
        ),
        t as
        (
            select  j.id    , 
                    j.key   , 
                    j.value , 
                    o.data
                from reclada.v_object o
                join j
                    on true
                    where o.obj_id = 
                        (
                            select (j.value#>>'{}')::uuid 
                                from j where j.key = '{GUID}'
                        )
        ),
        r as 
        (
            select id,key,value,jsonb_set(t.data,t.key::text[],t.value) as u, t.data
                from t
                    where id = 1
            union
            select t.id,t.key,t.value,jsonb_set(r.u   ,t.key::text[],t.value) as u, t.data
                from r
                JOIN t
                    on t.id-1 = r.id
        )
        select r.u
            from r
                where id = (select max(j.id) from j)
            INTO data;
    end if;
    -- raise notice '%', data#>>'{}';
    SELECT reclada_object.update(data, user_info) INTO result;

    if ver = '2' then
        RETURN '{"status":"OK"}'::jsonb;
    end if;
    return result;
END;
$$;


--
-- Name: storage_generate_presigned_get(jsonb); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.storage_generate_presigned_get(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    object_data  jsonb;
    object_id    uuid;
    result       jsonb;
    user_info    jsonb;
    context      jsonb;

BEGIN
    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;
    data := data - 'accessToken';

    IF (NOT(reclada_user.is_allowed(user_info, 'generate presigned get', ''))) THEN
        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned get';
    END IF;

    -- TODO: check user's permissions for reclada object access?
    object_id := data->>'objectId';
    SELECT reclada_object.list(format(
        '{"class": "File", "attributes": {}, "GUID": "%s"}',
        object_id
    )::jsonb) -> 0 INTO object_data;

    IF (object_data IS NULL) THEN
		RAISE EXCEPTION 'There is no object with such id';
	END IF;

    SELECT attrs
    FROM reclada.v_active_object
    WHERE class_name = 'Context'
    ORDER BY id DESC
    LIMIT 1
    INTO context;

    SELECT payload
    FROM aws_lambda.invoke(
        aws_commons.create_lambda_function_arn(
            context->>'Lambda',
            context->>'Region'
            ),
        format('{
            "type": "get",
            "uri": "%s",
            "expiration": 3600}',
            object_data->'attributes'->>'uri'
            )::jsonb)
    INTO result;

    RETURN result;
END;
$$;


--
-- Name: storage_generate_presigned_post(jsonb); Type: FUNCTION; Schema: api; Owner: -
--

CREATE FUNCTION api.storage_generate_presigned_post(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    user_info    jsonb;
    object_name  varchar;
    file_type    varchar;
    file_size    varchar;
    context      jsonb;
    bucket_name  varchar;
    url          varchar;
    result       jsonb;

BEGIN
    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;
    data := data - 'accessToken';

    IF (NOT(reclada_user.is_allowed(user_info, 'generate presigned post', ''))) THEN
        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';
    END IF;

    object_name := data->>'objectName';
    file_type := data->>'fileType';
    file_size := data->>'fileSize';

    IF (object_name IS NULL) OR (file_type IS NULL) OR (file_size IS NULL) THEN
        RAISE EXCEPTION 'Parameters objectName, fileType and fileSize must be present';
    END IF;

    SELECT attrs
    FROM reclada.v_active_object
    WHERE class_name = 'RuntimeContext'
    ORDER BY id DESC
    LIMIT 1
    INTO context;

    bucket_name := data->>'bucketName';

    SELECT payload::jsonb
    FROM aws_lambda.invoke(
        aws_commons.create_lambda_function_arn(
                context->>'Lambda',
                context->>'Region'
        ),
        format('{
            "type": "post",
            "fileName": "%s",
            "fileType": "%s",
            "fileSize": "%s",
            "bucketName": "%s",
            "expiration": 3600}',
            object_name,
            file_type,
            file_size,
            bucket_name
            )::jsonb)
    INTO url;

    result = format(
        '{"uploadUrl": %s}',
        url
    )::jsonb;

    RETURN result;
END;
$$;


--
-- Name: begin_install_component(text, text, text, text); Type: FUNCTION; Schema: dev; Owner: -
--

CREATE FUNCTION dev.begin_install_component(_name text, _repository text, _commit_hash text, _parent_component_name text DEFAULT ''::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    _guid        uuid;
    _f_name      text = 'dev.begin_install_component';
BEGIN
    perform reclada.raise_exception( '"'|| name ||'" component has is already begun installing.',_f_name)
        from dev.component;

    select guid 
        from reclada.v_component 
            where name = _name
        into _guid;

    _guid = coalesce(_guid,public.uuid_generate_v4());
    _parent_component_name = nullif(_parent_component_name,'');

    insert into dev.component( name,  repository,  commit_hash,  guid,  parent_component_name)
                       select _name, _repository, _commit_hash, _guid, _parent_component_name;

    delete from dev.component_object;
    insert into dev.component_object(data)
        select obj_data
            from reclada.v_component_object
                where component_name = _name;
    return 'OK';
END;
$$;


--
-- Name: downgrade_component(text); Type: FUNCTION; Schema: dev; Owner: -
--

CREATE FUNCTION dev.downgrade_component(_component_name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
    CREATE TEMP TABLE del_comp(
        tran_id bigint,
        id bigint,
        guid uuid,
        name text,
        rev_num bigint
    );

    with recursive t as (
        SELECT  transaction_id, 
                id, 
                guid, 
                name, 
                null as pre, 
                null::bigint as pre_id,
                0 as lvl,
                c.revision_num
            from reclada.v_component c
                WHERE not exists(
                        SELECT 
                            FROM reclada.v_component_object co 
                                where co.obj_id = c.guid
                    )
        union
        select  cc.transaction_id, 
                cc.id, 
                cc.guid, 
                cc.name, 
                t.name as pre, 
                t.id as pre_id,
                t.lvl+1 as lvl,
                cc.revision_num
            from t
            join reclada.v_component_object co
                on t.guid = co.component_guid
            join reclada.v_component cc
                on cc.id = co.id
    ),
    h as (
        SELECT  t.transaction_id, 
                t.id, 
                t.guid, 
                t.name, 
                t.pre, 
                t.pre_id, 
                t.lvl,
                t.revision_num
            FROM t
                where name = _component_name
        union
        select  t.transaction_id, 
                t.id, 
                t.guid, 
                t.name, 
                t.pre, 
                t.pre_id, 
                t.lvl,
                null revision_num
            FROM h
            JOIN t
                on t.pre_id = h.id
    )
    insert into del_comp(tran_id, id, guid, name, rev_num)
        SELECT    transaction_id, id, guid, name, revision_num  
            FROM h;

    DELETE from reclada.object 
        WHERE transaction_id  in (select tran_id from del_comp);


    with recursive t as (
        SELECT o.transaction_id, o.obj_id
            from reclada.v_object o
                WHERE o.obj_id = (SELECT guid from del_comp where name = _component_name)
                    AND coalesce(revision_num, 1) = coalesce(
                            (SELECT rev_num from del_comp where name = _component_name), 
                            1
                        ) - 1
        union 
        select o.transaction_id, o.obj_id
            from t
            JOIN reclada.v_relationship r
                ON r.parent_guid = t.obj_id
                    AND 'data of reclada-component' = r.type
            join reclada.v_object o
                on o.obj_id = r.subject
                    and o.transaction_id >= t.transaction_id
                    and o.class_name = 'Component'
    )
    update reclada.object u
        SET status = reclada_object.get_active_status_obj_id()
        FROM t c
            WHERE u.transaction_id = c.transaction_id
                and NOT EXISTS (
                        SELECT from reclada.object o
                            WHERE o.status != reclada_object.get_archive_status_obj_id()
                                and o.guid = u.guid
                    );
    drop TABLE del_comp;
    return 'OK';
END
$$;


--
-- Name: downgrade_version(); Type: FUNCTION; Schema: dev; Owner: -
--

CREATE FUNCTION dev.downgrade_version() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare 
    current_ver int; 
    downgrade_script text;
    v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN

    select max(ver) 
        from dev.VER
    into current_ver;
    
    select v.downgrade_script 
        from dev.VER v
            WHERE current_ver = v.ver
        into downgrade_script;

    if COALESCE(downgrade_script,'') = '' then
        RAISE EXCEPTION 'downgrade_script is empty! from dev.downgrade_version()';
    end if;

    perform dev.downgrade_component('db');
    
    EXECUTE downgrade_script;

    -- mark, that chanches applied
    delete 
        from dev.VER v
            where v.ver = current_ver;

    v_msg = 'OK, curren version: ' || (current_ver-1)::text;
    perform reclada.raise_notice(v_msg);
    return v_msg;
EXCEPTION when OTHERS then 
	get stacked diagnostics
        v_state   = returned_sqlstate,
        v_msg     = message_text,
        v_detail  = pg_exception_detail,
        v_hint    = pg_exception_hint,
        v_context = pg_exception_context;

    v_state := format('Got exception:
state   : %s
message : %s
detail  : %s
hint    : %s
context : %s
SQLSTATE: %s
SQLERRM : %s', 
                v_state, 
                v_msg, 
                v_detail, 
                v_hint, 
                v_context,
                SQLSTATE,
                SQLERRM);
    perform dev.reg_notice(v_state);
    return v_state;
END
$$;


--
-- Name: finish_install_component(); Type: FUNCTION; Schema: dev; Owner: -
--

CREATE FUNCTION dev.finish_install_component() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    _f_name   text := 'dev.finish_install_component';
    _parent_component_name text;
    _comp_obj jsonb;
    _data     jsonb;
	_tran_id  bigint := reclada.get_transaction_id();
BEGIN

    perform reclada.raise_exception('Component does not found.',_f_name)
        where not exists(select 1 from dev.component);
    
    select jsonb_build_object(
                                'GUID'          , guid::text,
                                'class'         , 'Component',
                                'transactionID' , _tran_id,
                                'attributes'    , jsonb_build_object(
                                    'name'        , name,
                                    'repository'  , repository,
                                    'commitHash'  , commit_hash
                                )
                            ),
            parent_component_name
        from dev.component
        into _comp_obj,
             _parent_component_name;

    delete from dev.component;

    update dev.component_object
        set status = 'delete'
            where status = 'need to check';

    update dev.component_object
        set data = data || jsonb_build_object('transactionID',_tran_id)
            where status != 'delete';

    perform reclada_object.delete(data)
        from dev.component_object
            where status = 'delete';

    FOR _data IN (SELECT data 
                    from dev.component_object 
                        where status = 'create_subclass'
                        ORDER BY id)
    LOOP
        perform reclada_object.create_relationship(
                'data of reclada-component',
                (_comp_obj ->>'GUID')::uuid ,
                (cr.v ->>'GUID')::uuid ,
                '{}'::jsonb            ,
                (_comp_obj  ->>'GUID')::uuid,
                _tran_id
            )
            from (select reclada_object.create_subclass(_data)#>'{0}' v) cr;
    END LOOP;

    perform reclada_object.create_relationship(
                'data of reclada-component',
                (_comp_obj     ->>'GUID')::uuid ,
                (el.value ->>'GUID')::uuid ,
                '{}'::jsonb                ,
                (_comp_obj     ->>'GUID')::uuid,
                _tran_id
            )
        from dev.component_object c
        cross join lateral (
            select reclada_object.create(c.data) v
        ) cr
        cross join lateral jsonb_array_elements(cr.v) el
            where c.status = 'create';

    perform reclada_object.update(data)
        from dev.component_object
            where status = 'update';

    if exists
    (
        select 
            from reclada.object o
                where o.guid = (_comp_obj->>'GUID')::uuid
    ) then
        perform reclada_object.update(_comp_obj);
    else
        perform reclada_object.create(_comp_obj);
    end if;
    
    perform reclada_object.create_relationship(
                'data of reclada-component',
                c.guid ,
                (_comp_obj     ->>'GUID')::uuid ,
                '{}'::jsonb                ,
                c.guid ,
                _tran_id
            )
        from reclada.v_component c
            where _parent_component_name = c.name;

    perform reclada_object.refresh_mv('All');

    return 'OK';

END;
$$;


--
-- Name: reg_notice(text); Type: FUNCTION; Schema: dev; Owner: -
--

CREATE FUNCTION dev.reg_notice(msg text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    insert into dev.t_dbg(msg)
		select msg;
    perform reclada.raise_notice(msg);
END
$$;


--
-- Name: get_children(uuid); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.get_children(_obj_id uuid) RETURNS SETOF uuid
    LANGUAGE sql STABLE
    AS $$
    WITH RECURSIVE temp1 (id,obj_id,parent,class_name,level) AS (
        SELECT
            id,
            obj_id,
            parent_guid,
            class_name,
            1
        FROM reclada.v_active_object vao 
        WHERE obj_id =_obj_id
            UNION 
        SELECT
            t2.id,
            t2.obj_id,
            t2.parent_guid,
            t2.class_name,
            level+1
        FROM reclada.v_active_object t2 JOIN temp1 t1 ON t1.obj_id=t2.parent_guid
    )
    SELECT obj_id FROM temp1
$$;


--
-- Name: get_duplicates(jsonb, uuid, uuid); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.get_duplicates(_attrs jsonb, _class_uuid uuid, exclude_uuid uuid DEFAULT NULL::uuid) RETURNS TABLE(obj_guid uuid, dup_behavior reclada.dp_bhvr, is_cascade boolean, dup_field text)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    q text;
BEGIN
    SELECT val
    FROM reclada.v_get_duplicates_query
    LIMIT 1
        INTO q;
    q := REPLACE(q, '@#@#@attrs@#@#@',          _attrs::text);
    q := REPLACE(q, '@#@#@class_uuid@#@#@',     _class_uuid::text);
    IF exclude_uuid IS NULL THEN
        q := REPLACE(q, '@#@#@exclude_uuid@#@#@',   ''::text);    
    ELSE
        q := REPLACE(q, '@#@#@exclude_uuid@#@#@',   ' || ''AND obj_id != '''''::text || exclude_uuid::text || '''''''');
    END IF;

    EXECUTE q
        INTO q;
    
    RETURN QUERY EXECUTE q;
END;            
$$;


--
-- Name: get_transaction_id(); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.get_transaction_id() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
    return nextval('reclada.transaction_id');
END
$$;


--
-- Name: get_transaction_id_for_import(text); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.get_transaction_id_for_import(fileguid text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    tran_id_    bigint;
BEGIN

    select o.transaction_id
        from reclada.v_active_object o
            where o.class_name = 'Document'
                and attrs->>'fileGUID' = fileGUID
        ORDER BY ID DESC 
        limit 1
        into tran_id_;

    if tran_id_ is not null then
        PERFORM reclada_object.delete(format('{"transactionID":%s}',tran_id_)::jsonb);
    end if;
    tran_id_ := reclada.get_transaction_id();

    return tran_id_;
END
$$;


--
-- Name: get_unifield_index_name(text[]); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.get_unifield_index_name(fields text[]) RETURNS text
    LANGUAGE sql STABLE
    AS $$
	SELECT lower(array_to_string(fields,'_'))||'_index_';
$$;


--
-- Name: get_validation_schema(uuid); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.get_validation_schema(class_guid uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    _schema_obj     jsonb;
    _properties     jsonb = '{}'::jsonb;
    _required       jsonb = '[]'::jsonb;
    _parent_schema  jsonb ;
    _parent_list    jsonb ;
    _parent         uuid ;
    _res            jsonb = '{}'::jsonb;
    _f_name         text = 'reclada.get_validation_schema';
BEGIN

    SELECT reclada_object.get_schema(class_guid::text) 
        INTO _schema_obj;

    IF (_schema_obj IS NULL) THEN
        perform reclada.raise_exception('No json schema available for ' || class_guid, _f_name);
    END IF;

    _parent_list = _schema_obj#>'{attributes,parentList}';

    FOR _parent IN SELECT jsonb_array_elements_text(_parent_list ) 
    LOOP
        _parent_schema := reclada.get_validation_schema(_parent);
        _properties := _properties || coalesce((_parent_schema->'properties'),'{}'::jsonb);
        _required   := _required   || coalesce((_parent_schema->'required'  ),'[]'::jsonb);
        _res := _res || _parent_schema ;  
    END LOOP;
    
    _parent_schema := _schema_obj#>'{attributes,schema}';
    _properties := _properties || coalesce((_parent_schema->'properties'),'{}'::jsonb);
    _required   := _required   || coalesce((_parent_schema->'required'  ),'[]'::jsonb);
    _res := _res || _parent_schema ;  
    _res := _res || jsonb_build_object( 'required'  , _required,
                                        'properties', _properties);
    return _res;
END;
$$;


--
-- Name: jsonb_deep_set(jsonb, text[], jsonb); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.jsonb_deep_set(curjson jsonb, globalpath text[], newval jsonb) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    IF curjson is null THEN
        curjson := '{}'::jsonb;
    END IF;
    FOR index IN 1..ARRAY_LENGTH(globalpath, 1) LOOP
        IF curjson #> globalpath[1:index] is null THEN
            curjson := jsonb_set(curjson, globalpath[1:index], '{}');
        END IF;
    END LOOP;
    curjson := jsonb_set(curjson, globalpath, newval);
    RETURN curjson;
END;
$$;


--
-- Name: jsonb_merge(jsonb, jsonb); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.jsonb_merge(current_data jsonb, new_data jsonb DEFAULT NULL::jsonb) RETURNS jsonb
    LANGUAGE sql IMMUTABLE
    AS $$
    SELECT CASE jsonb_typeof(current_data)
        WHEN 'object' THEN
            CASE jsonb_typeof(new_data)
                WHEN 'object' THEN (
                    SELECT jsonb_object_agg(k,
                        CASE
                            WHEN e2.v IS NULL THEN e1.v
                            WHEN e1.v IS NULL THEN e2.v
                            WHEN e1.v = e2.v THEN e1.v
                            ELSE reclada.jsonb_merge(e1.v, e2.v)
                        END)
                    FROM jsonb_each(current_data) e1(k, v)
                        FULL JOIN jsonb_each(new_data) e2(k, v) USING (k)
                )
                ELSE current_data
            END
        WHEN 'array' THEN current_data || new_data
        ELSE current_data
    END
$$;


--
-- Name: load_staging(); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.load_staging() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    _data_agg jsonb;
    _batch_size bigint := 1000;
BEGIN
    FOR _data_agg IN (select jsonb_agg(vrn.data)	  
                        from (
                            select data,
                                ROUND((ROW_NUMBER()OVER()-1)/_batch_size) AS rn
                                from NEW_TABLE
                        ) vrn
                        group by vrn.rn
                     ) 
    LOOP 
        PERFORM reclada_object.create(_data_agg);
    END LOOP;
    DELETE FROM reclada.staging;
    RETURN NEW;
END
$$;


--
-- Name: raise_exception(text, text); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.raise_exception(msg text, func_name text DEFAULT '<unknown>'::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- 
    RAISE EXCEPTION '% 
    from: %', msg, func_name;
END
$$;


--
-- Name: raise_notice(text); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.raise_notice(msg text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- 
    RAISE NOTICE '%', msg;
END
$$;


--
-- Name: random_string(integer); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.random_string(_length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
    chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
    result text := '';
    i integer := 0;
    _f_name text := 'reclada.random_string';
begin
    if _length < 0 then
        perform reclada.raise_exception('Given length cannot be less than 0', _f_name);
    end if;
    for i in 1.._length loop
        result := result || chars[1+random()*(array_length(chars, 1)-1)];
    end loop;
    return result;
end;
$$;


--
-- Name: rollback_import(text); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.rollback_import(fileguid text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    tran_id_     bigint;
    json_data   jsonb;
    tmp         jsonb;
    obj_id_     uuid;
    f_name      text;
    id_         bigint;
BEGIN
    f_name := 'reclada.rollback_import';
    select o.transaction_id
        from reclada.v_active_object o
            where o.class_name = 'Document'
                and attrs->>'fileGUID' = fileGUID
        ORDER BY ID DESC 
        limit 1
        into tran_id_;

    if tran_id_ is null then
        PERFORM reclada.raise_exception('"fileGUID": "'
                            ||fileGUID
                            ||'" not found for existing Documents',f_name);
    end if;

    delete from reclada.object where tran_id_ = transaction_id;
    
    with t as (
        select o.transaction_id
            from reclada.v_object o
                where o.class_name = 'Document'
                    and attrs->>'fileGUID' = fileGUID
            ORDER BY ID DESC 
            limit 1
    ) 
    update reclada.object o
        set status = reclada_object.get_active_status_obj_id()
        from t
            where t.transaction_id = o.transaction_id;
                    
    return 'OK';
END
$$;


--
-- Name: try_cast_int(text, integer); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.try_cast_int(p_in text, p_default integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
begin
    return p_in::int;
    exception when others then
        return p_default;
end;
$$;


--
-- Name: try_cast_uuid(text, integer); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.try_cast_uuid(p_in text, p_default integer DEFAULT NULL::integer) RETURNS uuid
    LANGUAGE plpgsql IMMUTABLE
    AS $$
begin
    return p_in::uuid;
    exception when others then
        return p_default;
end;
$$;


--
-- Name: validate_json(jsonb, text); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.validate_json(_data jsonb, _function text) RETURNS void
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    _schema jsonb;
BEGIN

    -- select reclada.raise_exception('JSON invalid: ' || _data >> '{}')
    select schema 
        from reclada.v_DTO_json_schema
            where _function = function
        into _schema;
    
     IF (_schema is null ) then
        RAISE EXCEPTION 'DTOJsonSchema for function: % not found',
                        _function;
    END IF;

    IF (NOT(public.validate_json_schema(_schema, _data))) THEN
        RAISE EXCEPTION 'JSON invalid: %, schema: %, function: %', 
                        _data #>> '{}'   , 
                        _schema #>> '{}' ,
                        _function;
    END IF;
      

END;
$$;


--
-- Name: validate_json_schema(jsonb); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.validate_json_schema(_data jsonb) RETURNS TABLE(valid_schema jsonb, attributes jsonb, class_name text, class_guid uuid)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    _schema_obj     jsonb;
    _valid_schema   jsonb;
    _attrs          jsonb;
    _class          text ;
    _class_name     text ;
    _class_guid     uuid ;
    _f_name         text = 'reclada.validate_json_schema';
BEGIN

    -- perform reclada.raise_notice(_data#>>'{}');
    _class := _data->>'class';

    IF (_class IS NULL) THEN
        perform reclada.raise_exception('The reclada object class is not specified',_f_name);
    END IF;

    SELECT reclada_object.get_schema(_class) 
        INTO _schema_obj;

    IF (_schema_obj IS NULL) THEN
        perform reclada.raise_exception('No json schema available for ' || _class_name);
    END IF;

    _class_guid := (_schema_obj->>'GUID')::uuid;

    SELECT  _schema_obj #>> '{attributes,forClass}', 
            reclada.get_validation_schema(_class_guid)
        INTO    _class_name, 
                _valid_schema;

    _attrs := _data->'attributes';
    IF (_attrs IS NULL) THEN
        perform reclada.raise_exception('The reclada object must have attributes',_f_name);
    END IF;

    IF (NOT(public.validate_json_schema(_valid_schema, _attrs))) THEN
        perform reclada.raise_exception(format('JSON invalid: %s, schema: %s', 
                                                _attrs #>> '{}'   , 
                                                _valid_schema #>> '{}'
                                            ),
                                        _f_name);
    END IF;

    RETURN QUERY
        SELECT  _valid_schema, 
                _attrs       , 
                _class_name  , 
                _class_guid  ;
END;
$$;


--
-- Name: xor(boolean, boolean); Type: FUNCTION; Schema: reclada; Owner: -
--

CREATE FUNCTION reclada.xor(a boolean, b boolean) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $$
    SELECT (a and not b) or (b and not a);
$$;


--
-- Name: listen(character varying); Type: FUNCTION; Schema: reclada_notification; Owner: -
--

CREATE FUNCTION reclada_notification.listen(channel character varying) RETURNS void
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    EXECUTE 'LISTEN ' || lower(channel);
END
$$;


--
-- Name: send(character varying, jsonb); Type: FUNCTION; Schema: reclada_notification; Owner: -
--

CREATE FUNCTION reclada_notification.send(channel character varying, payload jsonb DEFAULT NULL::jsonb) RETURNS void
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    PERFORM pg_notify(lower(channel), payload::text); 
END
$$;


--
-- Name: send_object_notification(character varying, jsonb); Type: FUNCTION; Schema: reclada_notification; Owner: -
--

CREATE FUNCTION reclada_notification.send_object_notification(event character varying, object_data jsonb) RETURNS void
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    data            jsonb;
    message         jsonb;
    msg             jsonb;
    object_class    uuid;
    class__name     varchar;
    attrs           jsonb;
    query           text;

BEGIN
    IF (jsonb_typeof(object_data) != 'array') THEN
        object_data := '[]'::jsonb || object_data;
    END IF;

    FOR data IN SELECT jsonb_array_elements(object_data) LOOP
        object_class := (data ->> 'class')::uuid;
        select for_class
            from reclada.v_class_lite cl
                where cl.obj_id = object_class
            into class__name;

        if event is null or object_class is null then
            return;
        end if;
        
        SELECT v.data
            FROM reclada.v_active_object v
                WHERE v.class_name = 'Message'
                    AND v.attrs->>'event' = event
                    AND v.attrs->>'class' = class__name
        INTO message;

        -- raise notice '%', event || ' ' || class__name;

        IF message IS NULL THEN
            RETURN;
        END IF;

        query := format(E'select to_json(x) from jsonb_to_record($1) as x(%s)',
            (
                select string_agg(s::text || ' jsonb', ',') 
                    from jsonb_array_elements(message -> 'attributes' -> 'attrs') s
            ));
        execute query into attrs using data -> 'attributes';

        msg := jsonb_build_object(
            'objectId', data -> 'GUID',
            'class', object_class,
            'event', event,
            'attributes', attrs
        );

        perform reclada_notification.send(message #>> '{attributes, channelName}', msg);

    END LOOP;
END
$_$;


--
-- Name: cast_jsonb_to_postgres(text, text, text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.cast_jsonb_to_postgres(key_path text, type text, type_of_array text DEFAULT 'text'::text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
SELECT
        CASE
            WHEN type = 'string' THEN
                format(E'(%s#>>\'{}\')::text', key_path)
            WHEN type = 'number' THEN
                format(E'(%s)::numeric', key_path)
            WHEN type = 'boolean' THEN
                format(E'(%s)::boolean', key_path)
            WHEN type = 'array' THEN
                format(
                    E'ARRAY(SELECT jsonb_array_elements_text(%s)::%s)',
                    key_path,
                     CASE
                        WHEN type_of_array = 'string' THEN 'text'
                        WHEN type_of_array = 'number' THEN 'numeric'
                        WHEN type_of_array = 'boolean' THEN 'boolean'
                     END
                    )
        END
$$;


--
-- Name: create(jsonb, jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    branch        uuid;
    _data         jsonb;
    new_data      jsonb;
    _class_name    text;
    _class_uuid   uuid;
    tran_id       bigint;
    _attrs        jsonb;
    schema        jsonb;
    _obj_guid     uuid;
    res           jsonb;
    affected      uuid[];
    inserted      uuid[];
    inserted_from_draft uuid[];
    _dup_behavior reclada.dp_bhvr;
    _is_cascade   boolean;
    _uni_field    text;
    _parent_guid  uuid;
    _parent_field   text;
    skip_insert     boolean;
    notify_res      jsonb;
    _cnt             int;
    _new_parent_guid       uuid;
    _rel_type       text := 'GUID changed for dupBehavior';
    _guid_list      text;
    _component_guid uuid;
    _row_count              int;
    _f_name         text = 'reclada_object.create';
BEGIN

    IF (jsonb_typeof(data_jsonb) != 'array') THEN
        data_jsonb := '[]'::jsonb || data_jsonb;
    END IF;

    SELECT guid 
        FROM dev.component 
        INTO _component_guid;

    /*TODO: check if some objects have revision AND others do not */
    branch:= data_jsonb->0->'branch';

    FOR _data IN SELECT jsonb_array_elements(data_jsonb) 
    LOOP

        if _component_guid is not null then
            _attrs      := _data-> 'attributes';
            _obj_guid   := _data->>'GUID'      ;    
            select obj_id, for_class 
                from reclada.v_class 
                    where _data->>'class' in (obj_id::text, for_class)
                    ORDER BY version DESC 
                    LIMIT 1
                into _class_uuid, _class_name;

            perform reclada.raise_exception('You should use reclada_object.create_subclass for new jsonschema.',_f_name)
                where _class_name = 'jsonschema';

            update dev.component_object
                set status = 'ok'
                    where status = 'need to check'
                        and _obj_guid::text      = data->>'GUID'
                        and _attrs               = data-> 'attributes'
                        and _class_uuid::text    = data->>'class'
                        and coalesce(_data->>'parentGUID','null') = coalesce(data->>'parentGUID','null') 
                        ------
                        and _obj_guid is not null;
                        ------

            GET DIAGNOSTICS _row_count := ROW_COUNT;
            if _row_count > 1 then
                perform reclada.raise_exception('Can not match component objects',_f_name);
            elsif _row_count = 1 then
                continue;
            end if;

            update dev.component_object
                set status = 'update',
                    data   = _data
                    where status = 'need to check' 
                        and _obj_guid::text = data->>'GUID'
                        ------
                        and _obj_guid is not null;
                        ------

            GET DIAGNOSTICS _row_count := ROW_COUNT;
            if _row_count > 1 then
                perform reclada.raise_exception('Can not match component objects',_f_name);
            elsif _row_count = 1 then
                continue;
            end if;
            
            with t as
            (
                select min(id) as id
                    from dev.component_object
                        where status = 'need to check'
                            and _attrs               = data-> 'attributes'
                            and _class_uuid::text    = data->>'class'
                            and coalesce(_data->>'parentGUID','null') = coalesce(data->>'parentGUID','null')
                            ------
                            and _obj_guid is null
                            ------
            )
                update dev.component_object u
                    set status = 'ok'
                        from t
                            where u.id = t.id;
                    
            GET DIAGNOSTICS _row_count := ROW_COUNT;
            if _row_count > 1 then
                perform reclada.raise_exception('Can not match component objects',_f_name);
            elsif _row_count = 1 then
                continue;
            end if;
            
            insert into dev.component_object( data, status  )
                select _data, 'create';
            continue;
            
        end if;

        SELECT  valid_schema, 
                attributes,
                class_name,
                class_guid 
            FROM reclada.validate_json_schema(_data)
            INTO    schema      , 
                    _attrs      ,
                    _class_name ,
                    _class_uuid ;

        skip_insert := false;

        tran_id := (_data->>'transactionID')::bigint;
        IF tran_id IS NULL THEN
            tran_id := reclada.get_transaction_id();
        END IF;

        IF _data->>'id' IS NOT NULL THEN
            RAISE EXCEPTION '%','Field "id" not allow!!!';
        END IF;

        SELECT prnt_guid, prnt_field
        FROM reclada_object.get_parent_guid(_data,_class_name)
            INTO _parent_guid,
                _parent_field;
        _obj_guid := _data->>'GUID';

        IF (_parent_guid IS NOT NULL) THEN
            SELECT
                attrs->>'object',
                attrs->>'dupBehavior',
                attrs->>'isCascade'
            FROM reclada.v_active_object
            WHERE class_name = 'Relationship'
                AND attrs->>'type'                      = _rel_type
                AND (attrs->>'subject')::uuid  = _parent_guid
                    INTO _new_parent_guid, _dup_behavior, _is_cascade;

            IF _new_parent_guid IS NOT NULL THEN
                _parent_guid := _new_parent_guid;
            END IF;
        END IF;
        
        IF EXISTS (
            SELECT 1
            FROM reclada.v_object_unifields
            WHERE class_uuid = _class_uuid
        )
        THEN
            IF (_parent_guid IS NOT NULL) THEN
                IF (_dup_behavior = 'Update' AND _is_cascade) THEN
                    SELECT count(DISTINCT obj_guid), string_agg(DISTINCT obj_guid::text, ',')
                    FROM reclada.get_duplicates(_attrs, _class_uuid)
                        INTO _cnt, _guid_list;
                    IF (_cnt >1) THEN
                        RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;
                    ELSIF (_cnt = 1) THEN
                        SELECT DISTINCT obj_guid, is_cascade
                        FROM reclada.get_duplicates(_attrs, _class_uuid)
                            INTO _obj_guid, _is_cascade;
                        new_data := _data;
                        IF new_data->>'GUID' IS NOT NULL THEN
                            PERFORM reclada_object.create_relationship(
                                    _rel_type,
                                    _obj_guid,
                                    (new_data->>'GUID')::uuid,
                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);
                        END IF;
                        new_data := reclada_object.remove_parent_guid(new_data, _parent_field);
                        new_data = reclada_object.update_json_by_guid(_obj_guid, new_data);
                        SELECT reclada_object.update(new_data)
                            INTO res;
                        affected := array_append( affected, _obj_guid);
                        skip_insert := true;
                    END IF;
                END IF;
                IF NOT EXISTS (
                    SELECT 1
                    FROM reclada.v_active_object
                    WHERE obj_id = _parent_guid
                )
                    AND _new_parent_guid IS NULL
                THEN
                    IF (_obj_guid IS NULL) THEN
                        RAISE EXCEPTION 'GUID is required.';
                    END IF;
                    INSERT INTO reclada.draft(guid, parent_guid, data)
                        VALUES(_obj_guid, _parent_guid, _data);
                    skip_insert := true;
                END IF;
            END IF;

            IF (NOT skip_insert) THEN
                SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg (DISTINCT obj_guid::text, ',')
                FROM reclada.get_duplicates(_attrs, _class_uuid)
                GROUP BY dup_behavior
                    INTO _cnt, _dup_behavior, _guid_list;
                IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN
                    RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;
                END IF;
                FOR _obj_guid, _dup_behavior, _is_cascade, _uni_field IN
                    SELECT obj_guid, dup_behavior, is_cascade, dup_field
                    FROM reclada.get_duplicates(_attrs, _class_uuid)
                LOOP
                    new_data := _data;
                    CASE _dup_behavior
                        WHEN 'Replace' THEN
                            IF (_is_cascade = true) THEN
                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', a)::jsonb)
                                FROM reclada.get_children(_obj_guid) a;
                            ELSE
                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);
                            END IF;
                        WHEN 'Update' THEN
                            IF new_data->>'GUID' IS NOT NULL THEN
                                PERFORM reclada_object.create_relationship(
                                    _rel_type,
                                    _obj_guid,
                                    (new_data->>'GUID')::uuid,
                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);
                            END IF;
                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);
                            new_data := reclada_object.update_json_by_guid(_obj_guid, new_data);
                            SELECT reclada_object.update(new_data)
                                INTO res;
                            affected := array_append( affected, _obj_guid);
                            skip_insert := true;
                        WHEN 'Reject' THEN
                            RAISE EXCEPTION 'The object was rejected.';
                        WHEN 'Copy'    THEN
                            _attrs := _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;
                        WHEN 'Insert' THEN
                            -- DO nothing
                        WHEN 'Merge' THEN
                            IF new_data->>'GUID' IS NOT NULL THEN
                                PERFORM reclada_object.create_relationship(
                                        _rel_type,
                                        _obj_guid,
                                        (new_data->>'GUID')::uuid,
                                        '{"dupBehavior": "Merge"}'::jsonb
                                    );
                            END IF;
                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);
                            SELECT reclada_object.update(
                                    reclada_object.merge(
                                            new_data - 'class', 
                                            data,
                                            schema
                                        ) 
                                        || format('{"GUID": "%s"}', _obj_guid)::jsonb 
                                        || format('{"transactionID": %s}', tran_id)::jsonb
                                )
                            FROM reclada.v_active_object
                            WHERE obj_id = _obj_guid
                                INTO res;
                            affected := array_append( affected, _obj_guid);
                            skip_insert := true;
                    END CASE;
                END LOOP;
            END IF;
        END IF;
        
        IF (NOT skip_insert) THEN           
            _obj_guid := _data->>'GUID';
            IF EXISTS (
                SELECT FROM reclada.object 
                    WHERE guid = _obj_guid
            ) THEN
                perform reclada.raise_exception ('GUID: '||_obj_guid::text||' is duplicate',_f_name);
            END IF;

            _obj_guid := coalesce(_obj_guid, public.uuid_generate_v4());

            INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)
                SELECT  _obj_guid AS GUID,
                        _class_uuid, 
                        _attrs,
                        tran_id,
                        _parent_guid;

            affected := array_append( affected, _obj_guid);
            inserted := array_append( inserted, _obj_guid);
            PERFORM reclada_object.object_insert
                (
                    _class_name,
                    _obj_guid,
                    _attrs
                );

            PERFORM reclada_object.refresh_mv(_class_name);
        END IF;
    END LOOP;

    SELECT array_agg(_affected_objects->>'GUID')
    FROM (
        SELECT jsonb_array_elements(_affected_objects) AS _affected_objects
        FROM (
            SELECT reclada_object.create(data) AS _affected_objects
            FROM reclada.draft
            WHERE parent_guid = ANY (affected)
        ) a
    ) b
    WHERE _affected_objects->>'GUID' IS NOT NULL
        INTO inserted_from_draft;
    affected := affected || inserted_from_draft;    

    res := array_to_json
            (
                array
                (
                    SELECT reclada.jsonb_merge(o.data, o.default_value) AS data
                    FROM reclada.v_active_object o
                    WHERE o.obj_id = ANY (affected)
                )
            )::jsonb;

    if res = '{}'::jsonb and _component_guid is not null then 
        res = '{"message": "Installing component"}'::jsonb;
    end if;

    notify_res := array_to_json
            (
                array
                (
                    SELECT o.data 
                    FROM reclada.v_active_object o
                    WHERE o.obj_id = ANY (inserted)
                )
            )::jsonb; 
    
    DELETE FROM reclada.draft 
        WHERE guid = ANY (affected);

    --PERFORM reclada.update_unique_object(affected);
        
    PERFORM reclada_notification.send_object_notification
        (
            'create',
            notify_res
        );
    RETURN res;
END;
$$;


--
-- Name: create_job(text, uuid, uuid, text, text, uuid); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.create_job(_uri text, _obj_id uuid, _new_guid uuid DEFAULT NULL::uuid, _task_guid text DEFAULT NULL::text, _task_command text DEFAULT NULL::text, _pipeline_job_guid uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    func_name       text := 'reclada_object.create_job';
    _environment    text;
    _obj            jsonb;
BEGIN
    SELECT attrs->>'Environment'
        FROM reclada.v_active_object
        WHERE class_name = 'RuntimeContext'
        ORDER BY created_time DESC
        LIMIT 1
        INTO _environment;

    IF _obj_id IS NULL THEN
        PERFORM reclada.raise_exception('Object ID is blank.', func_name);
    END IF;

    _obj := format('{
                "class": "Job",
                "attributes": {
                    "task": "%s",
                    "status": "new",
                    "command": "%s",
                    "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]
                    }
                }',
                    COALESCE(reclada.try_cast_uuid(_task_guid), 'c94bff30-15fa-427f-9954-d5c3c151e652'::uuid),
                    COALESCE(_task_command,'./run_pipeline.sh'),
                    _uri,
                    _obj_id::text
            )::jsonb;
    IF _new_guid IS NOT NULL THEN
        _obj := jsonb_set(_obj,'{GUID}',format('"%s"',_new_guid)::jsonb);
    END IF;

    _obj := jsonb_set(_obj,'{attributes,type}',format('"%s"',_environment)::jsonb);

    IF _pipeline_job_guid IS NOT NULL THEN
        _obj := jsonb_set(_obj,'{attributes,inputParameters}',_obj#>'{attributes,inputParameters}' || format('{"PipelineLiteJobGUID" :"%s"}',_pipeline_job_guid)::jsonb);
    END IF;
    RETURN reclada_object.create(_obj);
END;
$$;


--
-- Name: create_relationship(text, uuid, uuid, jsonb, uuid, bigint); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.create_relationship(_rel_type text, _obj_guid uuid, _subj_guid uuid, _extra_attrs jsonb DEFAULT '{}'::jsonb, _parent_guid uuid DEFAULT NULL::uuid, _tran_id bigint DEFAULT reclada.get_transaction_id()) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    _rel_cnt    int;
    _obj        jsonb;
BEGIN

    IF _obj_GUID IS NULL OR _subj_GUID IS NULL THEN
        RAISE EXCEPTION 'Object GUID or Subject GUID IS NULL';
    END IF;

    SELECT count(*)
    FROM reclada.v_active_object
    WHERE class_name = 'Relationship'
        AND (attrs->>'object')::uuid   = _obj_GUID
        AND (attrs->>'subject')::uuid  = _subj_GUID
        AND attrs->>'type'                      = _rel_type
            INTO _rel_cnt;
    IF (_rel_cnt = 0) THEN
        _obj := format('{
            "class": "Relationship",
            "transactionID": %s,
            "attributes": {
                    "type": "%s",
                    "object": "%s",
                    "subject": "%s"
                }
            }',
            _tran_id :: text,
            _rel_type,
            _obj_GUID,
            _subj_GUID)::jsonb;
        _obj := jsonb_set (_obj, '{attributes}', _obj->'attributes' || _extra_attrs);   
        if _parent_guid is not null then
            _obj := jsonb_set (_obj, '{parentGUID}', to_jsonb(_parent_guid) );   
        end if;

        RETURN  reclada_object.create( _obj);
    ELSE
        RETURN '{}'::jsonb;
    END IF;
END;
$$;


--
-- Name: create_subclass(jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.create_subclass(_data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $_$
DECLARE
    _class_list     jsonb;
    _res            jsonb = '{}'::jsonb;
    _class          text;
    _properties     jsonb;
    _p_properties   jsonb;
    _required       jsonb;
    _p_required     jsonb;
    _parent_list    jsonb := '[]';
    _new_class      text;
    attrs           jsonb;
    class_schema    jsonb;
    _version        integer;
    class_guid      uuid;
    _uniFields      jsonb;
    _idx_name       text;
    _f_list         text;
    _field          text;
    _f_name         text = 'reclada_object.create_subclass';
    _partial_clause text;
    _field_name     text;
    _create_obj     jsonb;
    _component_guid uuid;
    _obj_guid       uuid;
    _row_count      int;
    _defs           jsonb = '{}'::jsonb;
	_tran_id        bigint;
BEGIN

    _class_list := _data->'class';
    IF (_class_list IS NULL) THEN
        perform reclada.raise_exception('The reclada object class is not specified',_f_name);
    END IF;

    _obj_guid := COALESCE((_data->>'GUID')::uuid, public.uuid_generate_v4());
    _tran_id  := COALESCE((_data->>'transactionID')::bigint, reclada.get_transaction_id());

    IF (jsonb_typeof(_class_list) != 'array') THEN
        _class_list := '[]'::jsonb || _class_list;
    END IF;

    attrs := _data->'attributes';
    IF (attrs IS NULL) THEN
        PERFORM reclada.raise_exception('The reclada object must have attributes',_f_name);
    END IF;

    _new_class  := attrs->>'newClass';
    _properties := COALESCE(attrs -> 'properties','{}'::jsonb);
    _required   := COALESCE(attrs -> 'required'  ,'[]'::jsonb);
    _defs       := COALESCE(attrs -> '$defs'     ,'{}'::jsonb);
    SELECT guid 
        FROM dev.component 
        INTO _component_guid;

    if _component_guid is not null then
        update dev.component_object
            set status = 'ok'
            where status = 'need to check'
                and _new_class  =          data #>> '{attributes,forClass}'
                and _properties = COALESCE(data #>  '{attributes,schema,properties}','{}'::jsonb)
                and _required   = COALESCE(data #>  '{attributes,schema,required}'  ,'[]'::jsonb)
                and _defs       = COALESCE(data #>  '{attributes,schema,$defs}'     ,'{}'::jsonb)
                and jsonb_array_length(_class_list) = jsonb_array_length(data #> '{attributes,parentList}');

        GET DIAGNOSTICS _row_count := ROW_COUNT;
        if _row_count > 1 then
            perform reclada.raise_exception('Can not match component objects',_f_name);
        elsif _row_count = 1 then
            return _res;
        end if;

        -- upgrade jsonschema
        with u as (
            update dev.component_object
                set status = 'delete'
                where status = 'need to check'
                    and _new_class  = data #>> '{attributes,forClass}'
                RETURNING 1 as v
        )
        insert into dev.component_object( data, status  )
            select _data, 'create_subclass'
                from u;

        GET DIAGNOSTICS _row_count := ROW_COUNT;
        if _row_count > 1 then
            perform reclada.raise_exception('Can not match component objects',_f_name);
        elsif _row_count = 1 then
            return _res;
        end if;

        insert into dev.component_object( data, status  )
                select _data, 'create_subclass';
            return _res;
    end if;

    FOR _class IN SELECT jsonb_array_elements_text(_class_list)
    LOOP

        SELECT reclada_object.get_schema(_class) 
            INTO class_schema;

        IF (class_schema IS NULL) THEN
            perform reclada.raise_exception('No json schema available for ' || _class, _f_name);
        END IF;
        
        SELECT class_schema->>'GUID'
            INTO class_guid;
        
        _parent_list := _parent_list || to_jsonb(class_guid);

    END LOOP;
   
    SELECT max(version) + 1
    FROM reclada.v_class_lite v
    WHERE v.for_class = _new_class
        INTO _version;

    _version := coalesce(_version,1);

    _create_obj := jsonb_build_object(
        'class'         , 'jsonschema'   ,
        'GUID'          , _obj_guid::text,
        'transactionID' , _tran_id       ,
        'attributes'    , jsonb_build_object(
                'forClass'  , _new_class ,
                'version'   , _version   ,
                'parentList',_parent_list,
                'schema'    , jsonb_build_object(
                    'type'      , 'object'   ,
                    '$defs'     , _defs      ,
                    'properties', _properties,
                    'required'  , _required  
                )
            )
        );
        
    IF ( jsonb_typeof(attrs->'dupChecking') = 'array' ) THEN
        _create_obj := jsonb_set(_create_obj, '{attributes,dupChecking}',attrs->'dupChecking');
        IF ( jsonb_typeof(attrs->'dupBehavior') = 'string' ) THEN
            _create_obj := jsonb_set(_create_obj, '{attributes,dupBehavior}',attrs->'dupBehavior');
        END IF;
        IF ( jsonb_typeof(attrs->'isCascade') = 'boolean' ) THEN
            _create_obj := jsonb_set(_create_obj, '{attributes,isCascade}',attrs->'isCascade');
        END IF;
        IF ( jsonb_typeof(attrs->'copyField') = 'string' ) THEN
            _create_obj := jsonb_set(_create_obj, '{attributes,copyField}',attrs->'copyField');
        END IF;
    END IF;
    IF ( jsonb_typeof(attrs->'parentField') = 'string' ) THEN
        _create_obj := jsonb_set(_create_obj, '{attributes,parentField}',attrs->'parentField');
    END IF;
    select reclada_object.create(_create_obj)
        into _res;
    PERFORM reclada_object.refresh_mv('uniFields');
    return _res;
END;
$_$;


--
-- Name: delete(jsonb, jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.delete(data jsonb, user_info jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_obj_id              uuid;
    tran_id               bigint;
    _class_name           text;
    _class_name_from_uuid text;
    _uniFields_index_name text;
    _class_uuid           uuid;
    list_id               bigint[];
    _list_class_name      text[];
    _for_class            text;
    _exec_text            text;
    _attrs                jsonb;
    _list_id_json         jsonb;
    _id_from_list         bigint;
    _trigger_guid         uuid;
    _function_guid        uuid;
    _function_name        text;
    _query                text;
    _class_name_from_list_id text;
    _guid_for_check       uuid;
    _text_for_trigger_error text;
BEGIN

    v_obj_id := data->>'GUID';
    tran_id := (data->>'transactionID')::bigint;
    _class_name := data->>'class';

    IF (v_obj_id IS NULL AND _class_name IS NULL AND tran_id IS NULl) THEN
        RAISE EXCEPTION 'Could not delete object with no GUID, class and transactionID';
    END IF;

    _class_uuid := reclada.try_cast_uuid(_class_name);
    IF _class_uuid IS NOT NULL THEN
        SELECT v.for_class 
        FROM reclada.v_class_lite v
        WHERE _class_uuid = v.obj_id
            INTO _class_name_from_uuid;
    END IF;

    WITH t AS
    (    
        UPDATE reclada.object u
            SET status = reclada_object.get_archive_status_obj_id()
            FROM reclada.object o
                LEFT JOIN
                (   SELECT obj_id FROM reclada_object.get_guid_for_class(_class_name)
                    UNION SELECT _class_uuid WHERE _class_uuid IS NOT NULL
                ) c ON o.class = c.obj_id
                WHERE u.id = o.id AND
                (
                    (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id = o.transaction_id)

                    OR (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id IS NULL)
                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id = o.transaction_id)
                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id = o.transaction_id)

                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id IS NULL)
                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id IS NULL)
                    OR (v_obj_id IS NULL AND c.obj_id IS NULL AND tran_id = o.transaction_id)
                )
                    AND o.status != reclada_object.get_archive_status_obj_id()
                    RETURNING o.id
    ) 
        SELECT
            array
            (
                SELECT t.id FROM t
            )
        INTO list_id;
    SELECT vc.obj_id
    FROM reclada.v_class vc
        WHERE vc.for_class = 'DBTrigger'
    INTO _trigger_guid;
    FOR _id_from_list IN 
        select unnest(list_id)
    LOOP
        SELECT vao.class_name
            FROM reclada.v_object vao
                WHERE vao.id = _id_from_list
            INTO _class_name_from_list_id;
        IF _class_name_from_list_id = 'DBTriggerFunction' THEN
            SELECT vva.obj_id
                FROM reclada.v_object vva
                    WHERE vva.id = _id_from_list
                INTO _guid_for_check;
            SELECT string_agg(tn.trigger_name, ', ')
                FROM (
                    SELECT (vaa.attrs ->> 'name') as trigger_name
                        FROM reclada.v_active_object vaa
                            WHERE vaa.class_name = 'DBTrigger'
                            AND (vaa.attrs ->> 'function')::uuid = _guid_for_check
                ) tn
                INTO _text_for_trigger_error;
            IF _text_for_trigger_error IS NOT NULL THEN
                RAISE EXCEPTION 'Could not delete DBTriggerFunction with existing reference to DBTrigger: (%)',_text_for_trigger_error;  
            END IF;
        END IF; 
    END LOOP;

    PERFORM reclada_object.perform_trigger_function(list_id, 'delete');

    SELECT array_to_json
    (
        array
        (
            SELECT reclada.jsonb_merge(o.data, o.default_value) AS data
            FROM reclada.v_object o
            WHERE o.id IN (SELECT unnest(list_id))
        )
    )::jsonb
    INTO data;


    SELECT string_agg(t.q,' ')
        FROM (
            SELECT 'DROP '
                        || CASE o.class_name WHEN 'DBTriggerFunction' THEN 'Function' ELSE o.class_name END 
                        ||' reclada.'
                        ||(attrs->>'name')
                        ||';' AS q
                FROM reclada.v_object o
                WHERE o.id IN (SELECT unnest(list_id))
                    AND o.class_name in ('Index','View','Function', 'DBTriggerFunction')
        ) t
        into _exec_text;    
    if _exec_text is not null then
        EXECUTE _exec_text;
    end if;


    IF (jsonb_array_length(data) <= 1) THEN
        data := data->0;
    END IF;
    
    IF (data IS NULL) THEN
        RAISE EXCEPTION 'Could not delete object, no such GUID';
    END IF;

    SELECT array_agg(distinct class_name)
    FROM reclada.v_object vo
    WHERE class_name IN ('jsonschema','User','ObjectStatus')
        AND id = ANY(list_id)
        INTO _list_class_name;
    
    PERFORM reclada_object.refresh_mv(cn)
        FROM unnest( _list_class_name ) AS cn;

    PERFORM reclada_notification.send_object_notification('delete', data);

    RETURN data;
END;
$$;


--
-- Name: explode_jsonb(jsonb, text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.explode_jsonb(obj jsonb, addr text DEFAULT ''::text) RETURNS TABLE(f_path text, f_type text)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	_f_type	TEXT;
BEGIN
	_f_type := jsonb_typeof(obj);
	IF _f_type = 'object' THEN
		RETURN QUERY 
			SELECT b.f_path,b.f_type
			FROM jsonb_each(obj) a
			CROSS JOIN  reclada_object.explode_jsonb(value, addr || ',' || KEY) b;
	ELSE
		RETURN QUERY SELECT addr,_f_type;
	END IF;
END;
$$;


--
-- Name: get_active_status_obj_id(); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_active_status_obj_id() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
    select obj_id 
        from reclada.v_object_status 
            where caption = 'active'
$$;


--
-- Name: get_archive_status_obj_id(); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_archive_status_obj_id() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
    select obj_id 
        from reclada.v_object_status 
            where caption = 'archive'
$$;


--
-- Name: get_condition_array(jsonb, text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_condition_array(data jsonb, key_path text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
    SELECT
    CONCAT(
        key_path,
        ' ', COALESCE(data->>'operator', '='), ' ',
        format(E'\'%s\'::jsonb', data->'object'#>>'{}')) || CASE WHEN data->>'operator'='<@' THEN ' AND ' || key_path || ' != ''[]''::jsonb' ELSE '' END
$$;


--
-- Name: get_default_user_obj_id(); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_default_user_obj_id() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
    select obj_id 
        from reclada.v_user 
            where login = 'dev'
$$;


--
-- Name: get_guid_for_class(text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_guid_for_class(class text) RETURNS TABLE(obj_id uuid)
    LANGUAGE sql STABLE
    AS $$
    SELECT obj_id
        FROM reclada.v_class_lite
            WHERE for_class = class
$$;


--
-- Name: get_jsonschema_guid(); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_jsonschema_guid() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
    SELECT class
        FROM reclada.object o
            where o.GUID = 
                (
                    select class 
                        from reclada.object 
                            where class is not null 
                    limit 1
                )
$$;


--
-- Name: get_parent_guid(jsonb, text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_parent_guid(_data jsonb, _class_name text) RETURNS TABLE(prnt_guid uuid, prnt_field text)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    _parent_field   text;
    _parent_guid    uuid;
BEGIN
    SELECT parent_field
    FROM reclada.v_parent_field
    WHERE for_class = _class_name
        INTO _parent_field;

    _parent_guid = reclada.try_cast_uuid(_data->>'parentGUID');
    IF (_parent_guid IS NULL AND _parent_field IS NOT NULL) THEN
        _parent_guid = reclada.try_cast_uuid(_data->'attributes'->>_parent_field);
    END IF;

    RETURN QUERY
    SELECT _parent_guid,
        _parent_field;
END;
$$;


--
-- Name: get_query_condition(jsonb, text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_query_condition(data jsonb, key_path text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    key          text;
    operator     text;
    value        text;
    res          text;

BEGIN
    IF (data IS NULL OR data = 'null'::jsonb) THEN
        RAISE EXCEPTION 'There is no condition';
    END IF;

    IF (jsonb_typeof(data) = 'object') THEN

        IF (data->'object' IS NULL OR data->'object' = ('null'::jsonb)) THEN
            RAISE EXCEPTION 'There is no object field';
        END IF;

        IF (jsonb_typeof(data->'object') = 'object') THEN
            operator :=  data->>'operator';
            IF operator = '=' then
                key := reclada_object.cast_jsonb_to_postgres(key_path, 'string' );
                RETURN (key || ' ' || operator || ' ''' || (data->'object')::text || '''');
            ELSE
                RAISE EXCEPTION 'The input_jsonb->''object'' can not contain jsonb object';
            END If;
        END IF;

        IF (jsonb_typeof(data->'operator') != 'string' AND data->'operator' IS NOT NULL) THEN
            RAISE EXCEPTION 'The input_jsonb->''operator'' must contain string';
        END IF;

        IF (jsonb_typeof(data->'object') = 'array') THEN
            res := reclada_object.get_condition_array(data, key_path);
        ELSE
            key := reclada_object.cast_jsonb_to_postgres(key_path, jsonb_typeof(data->'object'));
            operator :=  data->>'operator';
            value := reclada_object.jsonb_to_text(data->'object');
            res := key || ' ' || operator || ' ' || value;
        END IF;
    ELSE
        key := reclada_object.cast_jsonb_to_postgres(key_path, jsonb_typeof(data));
        operator := '=';
        value := reclada_object.jsonb_to_text(data);
        res := key || ' ' || operator || ' ' || value;
    END IF;
    RETURN res;

END;
$$;


--
-- Name: get_query_condition_filter(jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_query_condition_filter(data jsonb) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    _count   INT;
    _res     TEXT;
    _f_name TEXT = 'reclada_object.get_query_condition_filter';
BEGIN

    perform reclada.validate_json(data, _f_name);
    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE
    CREATE TEMP TABLE mytable AS
        SELECT  res.lvl              AS lvl         ,
                res.rn               AS rn          ,
                res.idx              AS idx         ,
                res.prev             AS prev        ,
                res.val              AS val         ,
                res.parsed           AS parsed      ,
                coalesce(
                    po.inner_operator,
                    op.operator
                )                   AS op           ,
                coalesce
                (
                    iop.input_type,
                    op.input_type
                )                   AS input_type   ,
                case
                    when iop.input_type is not NULL
                        then NULL
                    else
                        op.output_type
                end                 AS output_type  ,
                po.operator         AS po           ,
                po.input_type       AS po_input_type,
                iop.brackets        AS po_inner_brackets
            FROM reclada_object.parse_filter(data) res
            LEFT JOIN reclada.v_filter_available_operator op
                ON res.op = op.operator
            LEFT JOIN reclada_object.parse_filter(data) p
                on  p.lvl = res.lvl-1
                    and res.prev = p.rn
            LEFT JOIN reclada.v_filter_available_operator po
                on po.operator = p.op
            LEFT JOIN reclada.v_filter_inner_operator iop
                on iop.operator = po.inner_operator;

    PERFORM reclada.raise_exception('Operator is not allowed ', _f_name)
        FROM mytable t
            WHERE t.op IS NULL;


    UPDATE mytable u
        SET parsed = to_jsonb(p.v)
            FROM mytable t
            JOIN LATERAL
            (
                SELECT  t.parsed #>> '{}' v
            ) as pt1
                ON TRUE
            LEFT JOIN reclada.v_filter_mapping fm
                ON pt1.v = fm.pattern
            JOIN LATERAL 
            (
                SELECT replace(pt1.v,'{attributes,','{') as v
            ) as pt
                ON TRUE
            JOIN LATERAL 
            (
                SELECT CASE
                        WHEN t.op LIKE '%<@%' AND t.idx=1 AND jsonb_typeof(t.parsed)='string'
                            THEN format('(COALESCE(attrs #> ''%s'', default_value -> ''attributes'' #> ''%s'')) != ''[]''::jsonb
                            AND (COALESCE(attrs #> ''%s'', default_value -> ''attributes'' #> ''%s'')) != ''{}''::jsonb
                            AND (COALESCE(attrs #> ''%s'', default_value -> ''attributes'' #> ''%s''))',
                            pt.v, pt.v, pt.v, pt.v, pt.v, pt.v)
                        WHEN fm.repl is not NULL
                            then
                                case
                                    when t.input_type in ('TEXT')
                                        then fm.repl || '::TEXT'
                                    else '(''"''||' ||fm.repl ||'||''"'')::jsonb' -- don't use FORMAT (concat null)
                                end
                        WHEN jsonb_typeof(t.parsed) in ('number', 'boolean')
                            then
                                case
                                    when t.input_type in ('NUMERIC','INT')
                                        then pt.v
                                    else '''' || pt.v || '''::jsonb'
                                end
                        WHEN jsonb_typeof(t.parsed) = 'string'
                            then
                                case
                                    WHEN pt.v LIKE '{%}'
                                        THEN
                                            case
                                                when t.input_type = 'TEXT'
                                                    then format('(COALESCE(attrs #>> ''%s'', default_value -> ''attributes'' #>> ''%s''))', pt.v, pt.v)
                                                when t.input_type = 'JSONB' or t.input_type is null
                                                    then format('(COALESCE(attrs #> ''%s'', default_value -> ''attributes'' #> ''%s''))', pt.v, pt.v)
                                                else
                                                    format('(COALESCE(attrs #>> ''%s'', default_value -> ''attributes'' #>> ''%s''))::', pt.v, pt.v) || t.input_type
                                            end
                                    when t.input_type = 'TEXT'
                                        then ''''||REPLACE(pt.v,'''','''''')||''''
                                    when t.input_type = 'JSONB' or t.input_type is null
                                        then '''"'||REPLACE(pt.v,'''','''''')||'"''::jsonb'
                                    else ''''||REPLACE(pt.v,'''','''''')||'''::'||t.input_type
                                end
                        WHEN jsonb_typeof(t.parsed) = 'null'
                            then 'null'
                        WHEN jsonb_typeof(t.parsed) = 'array'
                            then ''''||REPLACE(pt.v,'''','''''')||'''::jsonb'
                        ELSE
                            pt.v
                    END AS v
            ) as p
                ON TRUE
            WHERE t.lvl = u.lvl
                AND t.rn = u.rn
                AND t.parsed IS NOT NULL;

    update mytable u
        set op = CASE 
                    when f.btwn
                        then ' BETWEEN '
                    else u.op -- f.inop
                end,
            parsed = format(vb.operand_format,u.parsed)::jsonb
        FROM mytable t
        join lateral
        (
            select  t.op like ' %/BETWEEN ' btwn, 
                    t.po_inner_brackets is not null inop
        ) f 
            on true
        join reclada.v_filter_between vb
            on t.op = vb.operator
            WHERE t.lvl = u.lvl
                AND t.rn = u.rn
                AND (f.btwn or f.inop);


    INSERT INTO mytable (lvl,rn)
        VALUES (0,0);

    _count := 1;

    WHILE (_count>0) LOOP
        WITH r AS 
        (
            UPDATE mytable
                SET parsed = to_json(t.converted)::JSONB 
                FROM 
                (
                    SELECT     
                            res.lvl-1 lvl,
                            res.prev rn,
                            res.op,
                            1 q,
                            case 
                                when not res.po_inner_brackets 
                                    then array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) 
                                else
                                    CASE COUNT(1) 
                                        WHEN 1
                                            THEN 
                                                CASE res.output_type
                                                    when 'NUMERIC'
                                                        then format('(%s %s)::TEXT::JSONB', res.op, min(res.parsed #>> '{}') )
                                                    else 
                                                        format('(%s %s)', res.op, min(res.parsed #>> '{}') )
                                                end
                                        ELSE
                                            CASE 
                                                when res.output_type = 'TEXT'
                                                    then '(''"''||'||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||'||''"'')::JSONB'
                                                when res.output_type in ('NUMERIC','INT')
                                                    then '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')::TEXT::JSONB'
                                                else
                                                    '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')'
                                            end
                                    end
                            end AS converted
                        FROM mytable res 
                            WHERE res.parsed IS NOT NULL
                                AND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)
                            GROUP BY  res.prev, res.op, res.lvl, res.input_type, res.output_type, res.po_inner_brackets
                ) t
                WHERE
                    t.lvl = mytable.lvl
                        AND t.rn = mytable.rn
                RETURNING 1
        )
            SELECT COUNT(1) 
                FROM r
                INTO _count;
    END LOOP;
    
    SELECT parsed #>> '{}' 
        FROM mytable
            WHERE lvl = 0 AND rn = 0
        INTO _res;
    -- perform reclada.raise_notice( _res);
    DROP TABLE mytable;
    RETURN _res;
END 
$$;


--
-- Name: get_schema(text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_schema(_class text) RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
    SELECT data
    FROM reclada.v_class v
    WHERE v.for_class = _class
        OR v.obj_id::text = _class
    ORDER BY v.version DESC
    LIMIT 1
$$;


--
-- Name: get_transaction_id(jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.get_transaction_id(_data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    _action text;
    _res jsonb;
    _tran_id bigint;
    _guid uuid;
    _func_name text;
BEGIN
    _func_name := 'reclada_object.get_transaction_id';
    _action := _data ->> 'action';
    _guid := _data ->> 'GUID';

    if    _action = 'new' and _guid is null    
    then
        _tran_id := reclada.get_transaction_id();
    ELSIF _action is null  and _guid is not null 
    then
        select o.transaction_id 
            from reclada.v_object o
                where _guid = o.obj_id
        into _tran_id;
        if _tran_id is null 
        then
            perform reclada.raise_exception('GUID not found.',_func_name);
        end if;
    else 
        perform reclada.raise_exception('Parameter has to contain GUID or action.',_func_name);
    end if;

    RETURN format('{"transactionID":%s}',_tran_id):: jsonb;
END;
$$;


--
-- Name: is_equal(jsonb, jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.is_equal(lobj jsonb, robj jsonb) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		cnt 	int;
		ltype	text;
		rtype	text;
	BEGIN
		ltype := jsonb_typeof(lobj);
		rtype := jsonb_typeof(robj);
		IF ltype != rtype THEN
			RETURN False;
		END IF;
		CASE ltype 
		WHEN 'object' THEN
			SELECT count(*) INTO cnt FROM (                     -- Using joining operators compatible with merge or hash join is obligatory
				SELECT 1                                        --    with FULL OUTER JOIN. is_equal is compatible only with NESTED LOOPS
				FROM (SELECT jsonb_each(lobj) AS rec) a         --    so I use LEFT JOIN UNION ALL RIGHT JOIN insted of FULL OUTER JOIN.
				LEFT JOIN
					(SELECT jsonb_each(robj) AS rec) b
				ON (a.rec).key = (b.rec).key AND reclada_object.is_equal((a.rec).value, (b.rec).value)  
				WHERE b.rec IS NULL
            UNION ALL 
				SELECT 1
				FROM (SELECT jsonb_each(robj) AS rec) a
				LEFT JOIN
					(SELECT jsonb_each(lobj) AS rec) b
				ON (a.rec).key = (b.rec).key AND reclada_object.is_equal((a.rec).value, (b.rec).value)  
				WHERE b.rec IS NULL
			) a;
			RETURN cnt=0;
		WHEN 'array' THEN
			SELECT count(*) INTO cnt FROM (
				SELECT 1
				FROM (SELECT jsonb_array_elements (lobj) AS rec) a
				LEFT JOIN
					(SELECT jsonb_array_elements (robj) AS rec) b
				ON reclada_object.is_equal((a.rec), (b.rec))  
				WHERE b.rec IS NULL
				UNION ALL
				SELECT 1
				FROM (SELECT jsonb_array_elements (robj) AS rec) a
				LEFT JOIN
					(SELECT jsonb_array_elements (lobj) AS rec) b
				ON reclada_object.is_equal((a.rec), (b.rec))  
				WHERE b.rec IS NULL
			) a;
			RETURN cnt=0;
		WHEN 'string' THEN
			RETURN text(lobj) = text(robj);
		WHEN 'number' THEN
			RETURN lobj::numeric = robj::numeric;
		WHEN 'boolean' THEN
			RETURN lobj::boolean = robj::boolean;
		WHEN 'null' THEN
			RETURN True;                                    -- It should be Null
		ELSE
			RETURN null;
		END CASE;
	END;
$$;


--
-- Name: jsonb_to_text(jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.jsonb_to_text(data jsonb) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
    SELECT
        CASE
            WHEN jsonb_typeof(data) = 'string' THEN
                format(E'\'%s\'', data#>>'{}')
            WHEN jsonb_typeof(data) = 'array' THEN
                format('ARRAY[%s]',
                    (SELECT string_agg(
                        reclada_object.jsonb_to_text(elem),
                        ', ')
                    FROM jsonb_array_elements(data) elem))
            ELSE
                data#>>'{}'
        END
$$;


--
-- Name: list(jsonb, boolean, text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false, ver text DEFAULT '1'::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    _f_name TEXT = 'reclada_object.list';
    _class              text;
    attrs               jsonb;
    order_by_jsonb      jsonb;
    order_by            text;
    limit_              text;
    offset_             text;
    query_conditions    text;
    number_of_objects   int;
    objects             jsonb;
    res                 jsonb;
    _exec_text          text;
    _pre_query          text;
    _from               text;
    class_uuid          uuid;
    last_change         text;
    tran_id             bigint;
    _filter             jsonb;
    _object_display     jsonb;
    _order_row          jsonb;
BEGIN

    perform reclada.validate_json(data, _f_name);
    raise notice '%',data;
    if ver = '1' then
        tran_id := (data->>'transactionID')::bigint;
        _class := data->>'class';
    elseif ver = '2' then
        tran_id := (data->>'{transactionID}')::bigint;
        _class := data->>'{class}';
    end if;
    _filter = data->'filter';

    order_by_jsonb := data->'orderBy';
    IF ((order_by_jsonb IS NULL) OR
        (order_by_jsonb = 'null'::jsonb) OR
        (order_by_jsonb = '[]'::jsonb)) THEN
        
        SELECT (vod.table #> '{orderRow}') AS orderRow
            FROM reclada.v_object_display vod
            WHERE vod.class_guid = (SELECT(reclada_object.get_schema (_class)#>>'{GUID}')::uuid)
            INTO _order_row;
        IF _order_row IS NOT NULL THEN     
            SELECT jsonb_agg (
                        jsonb_build_object(
                                            'field',    replace(
                                                            replace(obf.field::text,'{',''),
                                                                '}',''
                                                        ), 
                                            'order', obf.order_by
                                        )
                            )
                FROM(
                    SELECT  je.value AS order_by, 
                            split_part (je.key, ':', 1) AS field
                        FROM jsonb_array_elements (_order_row) jae
                        CROSS JOIN jsonb_each (jae.value) je
                    ) obf
                INTO order_by_jsonb;
        ELSE
            order_by_jsonb := '[{"field": "id", "order": "ASC"}]'::jsonb;
        END IF;
    END IF;
    SELECT string_agg(
        format(
            E'obj.data#>''{%s}'' %s', 
            case ver
                when '2'
                    then REPLACE(REPLACE(T.value->>'field','{', '"{' ),'}', '}"' )
                else
                    T.value->>'field'
            end,
            COALESCE(T.value->>'order', 'ASC')),
        ' , ')
        FROM jsonb_array_elements(order_by_jsonb) T
        INTO order_by;

    limit_ := data->>'limit';
    IF (limit_ IS NULL) THEN
        limit_ := 500;
    END IF;

    offset_ := data->>'offset';
    IF (offset_ IS NULL) THEN
        offset_ := 0;
    END IF;
    
    IF (_filter IS NOT NULL) THEN
        query_conditions := reclada_object.get_query_condition_filter(_filter);
    ELSEIF ver = '1' then
        class_uuid := reclada.try_cast_uuid(_class);

        IF (class_uuid IS NULL) THEN
            SELECT v.obj_id
                FROM reclada.v_class v
                    WHERE _class = v.for_class
                    ORDER BY v.version DESC
                    limit 1 
            INTO class_uuid;
            IF (class_uuid IS NULL) THEN
                perform reclada.raise_exception(
                        format('Class not found: %s', _class),
                        _f_name
                    );
            END IF;
        end if;

        attrs := data->'attributes' || '{}'::jsonb;

        SELECT
            string_agg(
                format(
                    E'(%s)',
                    condition
                ),
                ' AND '
            )
            FROM (
                SELECT
                    format('obj.class_name = ''%s''', _class) AS condition
                        where _class is not null
                UNION
                    SELECT format('obj.class = ''%s''', class_uuid) AS condition
                        where class_uuid is not null
                            and _class is null
                UNION
                    SELECT format('obj.transaction_id = %s', tran_id) AS condition
                        where tran_id is not null
                UNION
                    SELECT CASE
                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN
                            (
                                SELECT string_agg
                                    (
                                        format(
                                            E'(%s)',
                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)
                                        ),
                                        ' AND '
                                    )
                                    FROM jsonb_array_elements(data->'GUID') AS cond
                            )
                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)
                        END AS condition
                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb
                UNION
                SELECT
                    CASE
                        WHEN jsonb_typeof(value) = 'array'
                            THEN
                                (
                                    SELECT string_agg
                                        (
                                            format
                                            (
                                                E'(%s)',
                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))
                                            ),
                                            ' AND '
                                        )
                                        FROM jsonb_array_elements(value) AS cond
                                )
                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))
                    END AS condition
                FROM jsonb_each(attrs)
                WHERE attrs != ('{}'::jsonb)
            ) conds
        INTO query_conditions;
    END IF;
    -- TODO: add ELSE
    IF ver = '2' THEN
        _pre_query := (select val from reclada.v_ui_active_object);
        _from := 'res AS obj';
        _pre_query := REPLACE(_pre_query, '#@#@#where#@#@#'  , query_conditions);
        _pre_query := REPLACE(_pre_query, '#@#@#orderby#@#@#', order_by        );
        order_by :=  REPLACE(order_by, '{', '{"{');
        order_by :=  REPLACE(order_by, '}', '}"}'); --obj.data#>'{some_field}'  -->  obj.data#>'{"{some_field}"}'

    ELSE
        _pre_query := '';
        _from := 'reclada.v_active_object AS obj
                            WHERE #@#@#where#@#@#';
        _from := REPLACE(_from, '#@#@#where#@#@#', query_conditions  );
    END IF;
    _exec_text := _pre_query ||
                'SELECT to_jsonb(array_agg(t.data))
                    FROM 
                    (
                        SELECT '
                        || CASE
                            WHEN ver = '2'
                                THEN 'obj.data '
                            ELSE 'reclada.jsonb_merge(obj.data, obj.default_value) AS data
                                 '
                        END
                            ||
                            'FROM '
                            || _from
                            || ' 
                            ORDER BY #@#@#orderby#@#@#'
                            || CASE
                                WHEN ver = '2'
                                    THEN ''
                                ELSE
                                '
                                OFFSET #@#@#offset#@#@#
                                LIMIT #@#@#limit#@#@#'
                            END
                            || '
                    ) AS t';
    _exec_text := REPLACE(_exec_text, '#@#@#orderby#@#@#'  , order_by          );
    _exec_text := REPLACE(_exec_text, '#@#@#offset#@#@#'   , offset_           );
    _exec_text := REPLACE(_exec_text, '#@#@#limit#@#@#'    , limit_            );
    -- RAISE NOTICE 'conds: %', _exec_text;

    EXECUTE _exec_text
        INTO objects;
    objects := coalesce(objects,'[]'::jsonb);
    IF gui THEN

        if ver = '2' then
            class_uuid := coalesce(class_uuid, (objects#>>'{0,"{class}"}')::uuid);
            if class_uuid is not null then
                _class :=   (
                                select cl.for_class 
                                    from reclada.v_class_lite cl
                                        where class_uuid = cl.obj_id
                                            limit 1
                            );

                _exec_text := '
                with 
                d as ( 
                    select id_unique_object
                        FROM reclada.v_active_object obj 
                        JOIN reclada.unique_object_reclada_object as uoc
                            on uoc.id_reclada_object = obj.id
                                and #@#@#where#@#@#
                        group by id_unique_object
                ),
                dd as (
                    select distinct 
                            ''{''||f.path||''}:''||f.json_type v,
                            f.json_type
                        FROM d 
                        JOIN reclada.unique_object as uo
                            on d.id_unique_object = uo.id
                        JOIN reclada.field f
                            on f.id = ANY (uo.id_field)
                    UNION
                    SELECT  pattern||'':''|| t.v,
                            t.v
                    FROM reclada.v_filter_mapping vfm
                    CROSS JOIN LATERAL 
                    (
                        SELECT  CASE 
                                    WHEN vfm.pattern=''{transactionID}'' 
                                        THEN ''number'' 
                                    ELSE ''string'' 
                                END as v
                    ) t
                ),
                on_data as 
                (
                    select  jsonb_object_agg(
                                t.v, 
                                replace(dd.template,''#@#attrname#@#'',t.v)::jsonb 
                            ) t
                        from dd as t
                        JOIN reclada.v_default_display dd
                            on t.json_type = dd.json_type
                )
                select jsonb_set(templ.v,''{table}'', od.t || coalesce(d.table,coalesce(d.table,templ.v->''table'')))
                    from on_data od
                    join (
                        select replace(template,''#@#classname#@#'','''|| _class ||''')::jsonb v
                            from reclada.v_default_display 
                                where json_type = ''ObjectDisplay''
                                    limit 1
                    ) templ
                        on true
                    left join reclada.v_object_display d
                        on d.class_guid::text = '''|| coalesce( class_uuid::text, '' ) ||'''';

                _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );
                -- raise notice '%',_exec_text;
                EXECUTE _exec_text
                    INTO _object_display;
            end if;
        end if;


        _exec_text := '
            SELECT  COUNT(1),
                    TO_CHAR(
                        MAX(
                            GREATEST(
                                obj.created_time, 
                                (
                                    SELECT  TO_TIMESTAMP(
                                                MAX(date_time),
                                                ''YYYY-MM-DD hh24:mi:ss.US TZH''
                                            )
                                        FROM reclada.v_revision vr
                                            WHERE vr.obj_id = UUID(obj.attrs ->>''revision'')
                                )
                            )
                        ),
                        ''YYYY-MM-DD hh24:mi:ss.MS TZH''
                    )
                    FROM reclada.v_active_object obj 
                        where #@#@#where#@#@#';

        _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );
        -- raise notice '%',_exec_text;
        EXECUTE _exec_text
            INTO number_of_objects, last_change;
        
        IF _object_display IS NOT NULL then
            res := jsonb_build_object(
                    'lasthange', last_change,    
                    'number', number_of_objects,
                    'objects', objects,
                    'display', _object_display
                );
        ELSE
            res := jsonb_build_object(
                    'lasthange', last_change,    
                    'number', number_of_objects,
                    'objects', objects
            );
        end if;
    ELSE
        
        res := objects;
    END IF;

    RETURN res;


END;
$$;


--
-- Name: list_add(jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.list_add(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    class          text;
    objid          uuid;
    obj            jsonb;
    values_to_add  jsonb;
    field          text;
    field_value    jsonb;
    json_path      text[];
    new_obj        jsonb;
    res            jsonb;

BEGIN

    class := data->>'class';
    IF (class IS NULL) THEN
        RAISE EXCEPTION 'The reclada object class is not specified';
    END IF;

    objid := (data->>'GUID')::uuid;
    IF (objid IS NULL) THEN
        RAISE EXCEPTION 'There is no GUID';
    END IF;

    SELECT v.data
	FROM reclada.v_active_object v
	WHERE v.obj_id = objid
	INTO obj;

    IF (obj IS NULL) THEN
        RAISE EXCEPTION 'There is no object with such id';
    END IF;

    values_to_add := data->'value';
    IF (values_to_add IS NULL OR values_to_add = 'null'::jsonb) THEN
        RAISE EXCEPTION 'The value should not be null';
    END IF;

    IF (jsonb_typeof(values_to_add) != 'array') THEN
        values_to_add := format('[%s]', values_to_add)::jsonb;
    END IF;

    field := data->>'field';
    IF (field IS NULL) THEN
        RAISE EXCEPTION 'There is no field';
    END IF;
    json_path := format('{attributes, %s}', field);
    field_value := obj#>json_path;

    IF ((field_value = 'null'::jsonb) OR (field_value IS NULL)) THEN
        SELECT jsonb_set(obj, json_path, values_to_add)
        INTO new_obj;
    ELSE
        SELECT jsonb_set(obj, json_path, field_value || values_to_add)
        INTO new_obj;
    END IF;

    SELECT reclada_object.update(new_obj) INTO res;
    RETURN res;

END;
$$;


--
-- Name: list_drop(jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.list_drop(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    class           text;
    objid           uuid;
    obj             jsonb;
    values_to_drop  jsonb;
    field           text;
    field_value     jsonb;
    json_path       text[];
    new_value       jsonb;
    new_obj         jsonb;
    res             jsonb;

BEGIN

	class := data->>'class';
	IF (class IS NULL) THEN
		RAISE EXCEPTION 'The reclada object class is not specified';
	END IF;

	objid := (data->>'GUID')::uuid;
	IF (objid IS NULL) THEN
		RAISE EXCEPTION 'There is no GUID';
	END IF;

    SELECT v.data
    FROM reclada.v_active_object v
    WHERE v.obj_id = objid
    INTO obj;

	IF (obj IS NULL) THEN
		RAISE EXCEPTION 'There is no object with such id';
	END IF;

	values_to_drop := data->'value';
	IF (values_to_drop IS NULL OR values_to_drop = 'null'::jsonb) THEN
		RAISE EXCEPTION 'The value should not be null';
	END IF;

	IF (jsonb_typeof(values_to_drop) != 'array') THEN
		values_to_drop := format('[%s]', values_to_drop)::jsonb;
	END IF;

	field := data->>'field';
	IF (field IS NULL) THEN
		RAISE EXCEPTION 'There is no field';
	END IF;
	json_path := format('{attributes, %s}', field);
	field_value := obj#>json_path;
	IF (field_value IS NULL OR field_value = 'null'::jsonb) THEN
		RAISE EXCEPTION 'The object does not have this field';
	END IF;

	SELECT jsonb_agg(elems)
	FROM
		jsonb_array_elements(field_value) elems
	WHERE
		elems NOT IN (
			SELECT jsonb_array_elements(values_to_drop))
	INTO new_value;

	SELECT jsonb_set(obj, json_path, coalesce(new_value, '[]'::jsonb))
	INTO new_obj;

	SELECT reclada_object.update(new_obj) INTO res;
	RETURN res;

END;
$$;


--
-- Name: list_related(jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.list_related(data jsonb) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    class          text;
    objid          uuid;
    field          text;
    related_class  text;
    obj            jsonb;
    list_of_ids    jsonb;
    cond           jsonb = '{}'::jsonb;
    order_by       jsonb;
    limit_         text;
    offset_        text;
    res            jsonb;

BEGIN
    class := data->>'class';
    IF (class IS NULL) THEN
        RAISE EXCEPTION 'The reclada object class is not specified';
    END IF;

    objid := (data->>'GUID')::uuid;
    IF (objid IS NULL) THEN
        RAISE EXCEPTION 'The object GUID is not specified';
    END IF;

    field := data->>'field';
    IF (field IS NULL) THEN
        RAISE EXCEPTION 'The object field is not specified';
    END IF;

    related_class := data->>'relatedClass';
    IF (related_class IS NULL) THEN
        RAISE EXCEPTION 'The related class is not specified';
    END IF;

	SELECT v.data
	FROM reclada.v_active_object v
	WHERE v.obj_id = objid
	INTO obj;

    IF (obj IS NULL) THEN
        RAISE EXCEPTION 'There is no object with such id';
    END IF;

    list_of_ids := obj#>(format('{attributes, %s}', field)::text[]);
    IF (list_of_ids IS NULL) THEN
        RAISE EXCEPTION 'The object does not have this field';
    END IF;
    IF (jsonb_typeof(list_of_ids) != 'array') THEN
        list_of_ids := '[]'::jsonb || list_of_ids;
    END IF;

    order_by := data->'orderBy';
    IF (order_by IS NOT NULL) THEN
        cond := cond || (format('{"orderBy": %s}', order_by)::jsonb);
    END IF;

    limit_ := data->>'limit';
    IF (limit_ IS NOT NULL) THEN
        cond := cond || (format('{"limit": "%s"}', limit_)::jsonb);
    END IF;

    offset_ := data->>'offset';
    IF (offset_ IS NOT NULL) THEN
        cond := cond || (format('{"offset": "%s"}', offset_)::jsonb);
    END IF;
    
    IF (list_of_ids = '[]'::jsonb) THEN
        res := '{"number": 0, "objects": []}'::jsonb;
    ELSE
        SELECT reclada_object.list(format(
            '{"class": "%s", "attributes": {}, "GUID": {"operator": "<@", "object": %s}}',
            related_class,
            list_of_ids
            )::jsonb || cond,
            true)
        INTO res;
    END IF;

    RETURN res;

END;
$$;


--
-- Name: merge(jsonb, jsonb, jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.merge(lobj jsonb, robj jsonb, schema jsonb DEFAULT NULL::jsonb) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        res     jsonb;
        ltype    text;
        rtype    text;
    BEGIN
        ltype := jsonb_typeof(lobj);
        rtype := jsonb_typeof(robj);
        IF (lobj IS NULL AND robj IS NOT NULL) THEN
            RETURN robj;
        END IF;
        IF (lobj IS NOT NULL AND robj IS NULL) THEN
            RETURN lobj;
        END IF;
        IF (ltype = 'null') THEN
            RETURN robj;
        END IF;
        IF (ltype != rtype) THEN
            RETURN lobj || robj;
        END IF;
        IF reclada_object.is_equal(lobj,robj) THEN
            RETURN lobj;
        END IF;
        CASE ltype 
        WHEN 'object' THEN
            SELECT jsonb_object_agg(key,val)
            FROM (
                SELECT key, reclada_object.merge(lval,rval) as val
                    FROM (                     -- Using joining operators compatible with merge or hash join is obligatory
                    SELECT (a.rec).key as key,
                        (a.rec).value AS lval,
                        (b.rec).value AS rval                                        --    with FULL OUTER JOIN. merge is compatible only with NESTED LOOPS
                    FROM (SELECT jsonb_each(lobj) AS rec) a         --    so I use LEFT JOIN UNION ALL RIGHT JOIN insted of FULL OUTER JOIN.
                    LEFT JOIN
                        (SELECT jsonb_each(robj) AS rec) b
                    ON (a.rec).key = (b.rec).key
                UNION
                    SELECT (a.rec).key as key,
                        (b.rec).value AS lval,
                        (a.rec).value AS rval
                    FROM (SELECT jsonb_each(robj) AS rec) a
                    LEFT JOIN
                        (SELECT jsonb_each(lobj) AS rec) b
                    ON (a.rec).key = (b.rec).key
                ) a
            ) b
                INTO res;
            IF schema IS NOT NULL AND NOT validate_json_schema(schema, res->'attributes') THEN
                RAISE EXCEPTION 'Objects aren''t mergeable. Solve duplicate conflicate manually.';
            END IF;
            RETURN res;
        WHEN 'array' THEN
            SELECT to_jsonb(array_agg(rec)) FROM (
                SELECT COALESCE(a.rec, b.rec) as rec
                FROM (SELECT jsonb_array_elements (lobj) AS rec) a
                LEFT JOIN
                    (SELECT jsonb_array_elements (robj) AS rec) b
                ON reclada_object.is_equal((a.rec), (b.rec))
                UNION
                SELECT COALESCE(a.rec, b.rec) as rec
                FROM (SELECT jsonb_array_elements (robj) AS rec) a
                LEFT JOIN
                    (SELECT jsonb_array_elements (lobj) AS rec) b
                ON reclada_object.is_equal((a.rec), (b.rec))
            ) a
                INTO res;
            RETURN res;
        WHEN 'string' THEN
            RETURN lobj || robj;
        WHEN 'number' THEN
            RETURN lobj || robj;
        WHEN 'boolean' THEN
            RETURN lobj || robj;
        WHEN 'null' THEN
            RETURN '{}'::jsonb;                                    -- It should be Null
        ELSE
            RETURN null;
        END CASE;
    END;
$$;


--
-- Name: need_flat(text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.need_flat(_class_name text) RETURNS boolean
    LANGUAGE sql STABLE
    AS $$
    select exists
        (
            select true as r
                from reclada.v_object_display d
                join reclada_object.get_guid_for_class(_class_name) tf
                    on tf.obj_id = d.class_guid
                where d.table is not null
        )
$$;


--
-- Name: object_insert(text, uuid, jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.object_insert(_class_name text, _obj_id uuid, attributes jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    _exec_text          text ;
    _where              text ;
    _fields             text ;
    _pipeline_lite      jsonb;
    _task               jsonb;
    _dataset_guid       uuid ;
    _new_guid           uuid ;
    _pipeline_job_guid  uuid ;
    _stage              text ;
    _uri                text ;
    _dataset2ds_type    text = 'defaultDataSet to DataSource';
    _f_name             text = 'reclada_object.object_insert';
    _trigger_guid       uuid;
    _function_name      text;
    _function_guid      uuid;
    _query              text;
    _current_id         bigint;
    _current_id_array   bigint[];               
BEGIN
    IF _class_name in ('DataSource','File') THEN

        _uri := attributes->>'uri';

        SELECT v.obj_id
            FROM reclada.v_active_object v
            WHERE v.class_name = 'DataSet'
                and v.attrs->>'name' = 'defaultDataSet'
            INTO _dataset_guid;

        IF (_dataset_guid IS NULL) THEN
            RAISE EXCEPTION 'Can''t found defaultDataSet';
        END IF;
        PERFORM reclada_object.create_relationship(_dataset2ds_type, _obj_id, _dataset_guid);
        IF _uri LIKE '%inbox/jobs/%' THEN
            PERFORM reclada_object.create_job(_uri, _obj_id);
        ELSE
            
            SELECT data 
                FROM reclada.v_active_object
                    WHERE class_name = 'PipelineLite'
                        LIMIT 1
                INTO _pipeline_lite;
            _new_guid := public.uuid_generate_v4();
            IF _uri LIKE '%inbox/pipelines/%/%' THEN
                
                _stage := SPLIT_PART(
                                SPLIT_PART(_uri,'inbox/pipelines/',2),
                                '/',
                                2
                            );
                _stage = replace(_stage,'.json','');
                SELECT data 
                    FROM reclada.v_active_object o
                        where o.class_name = 'Task'
                            and o.obj_id = (_pipeline_lite #>> ('{attributes,tasks,'||_stage||'}')::text[])::uuid
                    into _task;
                
                _pipeline_job_guid = reclada.try_cast_uuid(
                                        SPLIT_PART(
                                            SPLIT_PART(_uri,'inbox/pipelines/',2),
                                            '/',
                                            1
                                        )
                                    );
                IF _pipeline_job_guid IS NULL THEN
                    perform reclada.raise_exception('PIPELINE_JOB_GUID not found',_f_name);
                END IF;
                
                SELECT  data #>> '{attributes,inputParameters,0,uri}',
                        (data #>> '{attributes,inputParameters,1,dataSourceId}')::uuid
                    FROM reclada.v_active_object o
                        WHERE o.obj_id = _pipeline_job_guid
                    INTO _uri, _obj_id;

            ELSE
                SELECT data 
                    FROM reclada.v_active_object o
                        WHERE o.class_name = 'Task'
                            AND o.obj_id = (_pipeline_lite #>> '{attributes,tasks,0}')::uuid
                    INTO _task;
                IF _task IS NOT NULL THEN
                    _pipeline_job_guid := _new_guid;
                END IF;
            END IF;
            
            PERFORM reclada_object.create_job(
                _uri,
                _obj_id,
                _new_guid,
                _task->>'GUID',
                _task-> 'attributes' ->>'command',
                _pipeline_job_guid
            );
        END IF;
    
    ELSIF _class_name = 'Index' then
        _exec_text := 'DROP INDEX IF EXISTS reclada.#@#@#name#@#@#;
            CREATE INDEX #@#@#name#@#@# ON reclada.object USING #@#@#method#@#@# (#@#@#fields#@#@#) #@#@#where#@#@#;';
        _exec_text := REPLACE(_exec_text, '#@#@#name#@#@#'   , attributes->>'name'                      );
        _exec_text := REPLACE(_exec_text, '#@#@#method#@#@#' , coalesce(attributes->>'method' ,'btree') );

        _fields :=  (
                        select string_agg(value,'#@#@#sep#@#@#')
                            from jsonb_array_elements_text(attributes->'fields')
                    );
        _where := coalesce(attributes->>'wherePredicate','');

        if _where != '' then
            if _where = 'IS NOT NULL' then
                _where := REPLACE(_fields,'#@#@#sep#@#@#', ' IS NOT NULL OR ') || ' IS NOT NULL';
            end if;
            _where := 'WHERE ' || _where;
        end if;

        _fields := REPLACE(_fields,'#@#@#sep#@#@#', ' , ');

        _exec_text := REPLACE(_exec_text, '#@#@#fields#@#@#' , _fields);
        _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#'  , _where );
        EXECUTE _exec_text;

    ELSIF _class_name = 'View' then

        _exec_text := 'DROP VIEW IF EXISTS reclada.#@#@#name#@#@#;
            CREATE VIEW reclada.#@#@#name#@#@# as #@#@#query#@#@#;';
        _exec_text := REPLACE(_exec_text, '#@#@#name#@#@#'   , attributes->>'name' );
        _exec_text := REPLACE(_exec_text, '#@#@#query#@#@#' , attributes->>'query' );

        EXECUTE _exec_text;

    ELSIF _class_name IN ('Function', 'DBTriggerFunction') then

        _exec_text := 'DROP FUNCTION IF EXISTS reclada.#@#@#name#@#@#;
            CREATE FUNCTION reclada.#@#@#name#@#@#
            (
                #@#@#parameters#@#@#
            )
            RETURNS #@#@#returns#@#@# AS '||chr(36)||chr(36)||'
            DECLARE
                #@#@#declare#@#@#
            BEGIN   
                #@#@#body#@#@#
            END;
            '||chr(36)||chr(36)||' LANGUAGE ''plpgsql'' VOLATILE;';

        _exec_text := REPLACE(_exec_text, '#@#@#name#@#@#'      , attributes->>'name'   );
        _exec_text := REPLACE(_exec_text, '#@#@#returns#@#@#'   , attributes->>'returns');
        _exec_text := REPLACE(_exec_text, '#@#@#body#@#@#'      , attributes->>'body'   );

        _exec_text := REPLACE(
                _exec_text, '#@#@#parameters#@#@#', 
                (SELECT  STRING_AGG(
                            (el.value->>'name')
                                || ' '
                                || (el.value->>'type'),
                            ',' || chr(10)
                        )
                    FROM jsonb_array_elements(attributes->'parameters') el) 
            );

        _exec_text := REPLACE(
                _exec_text, '#@#@#declare#@#@#', 
                (SELECT  STRING_AGG(
                            (el.value->>'name')
                                || ' '
                                || (el.value->>'type')
                                || ';', 
                            chr(10)
                        )
                    FROM jsonb_array_elements(attributes->'declare') el )
            );

        EXECUTE _exec_text;
    END IF;
    SELECT vab.id 
        FROM reclada.v_active_object vab
            WHERE vab.obj_id = _obj_id
        INTO _current_id;
    
    _current_id_array := ARRAY[_current_id];
    
    PERFORM reclada_object.perform_trigger_function(_current_id_array, 'insert');

END;
$$;


--
-- Name: parse_filter(jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.parse_filter(data jsonb) RETURNS TABLE(lvl integer, rn bigint, idx bigint, op text, prev bigint, val jsonb, parsed jsonb)
    LANGUAGE sql IMMUTABLE
    AS $$
    WITH RECURSIVE f AS 
    (
        SELECT data AS v
    ),
    pr AS 
    (
        SELECT 	format(' %s ',f.v->>'operator') AS op, 
                val.v AS val,
                1 AS lvl,
                row_number() OVER(ORDER BY idx) AS rn,
                val.idx idx,
                0::BIGINT prev
            FROM f, jsonb_array_elements(f.v->'value') WITH ordinality AS val(v, idx)
    ),
    res AS
    (	
        SELECT 	pr.lvl	,
                pr.rn	,
                pr.idx  ,
                pr.op	,
                pr.prev ,
                pr.val	,
                CASE jsonb_typeof(pr.val) 
                    WHEN 'object'	
                        THEN NULL
                    ELSE pr.val
                END AS parsed
            FROM pr
            WHERE prev = 0 
                AND lvl = 1
        UNION ALL
        SELECT 	ttt.lvl	,
                ROW_NUMBER() OVER(ORDER BY ttt.idx) AS rn,
                ttt.idx,
                ttt.op	,
                ttt.prev,
                ttt.val ,
                CASE jsonb_typeof(ttt.val) 
                    WHEN 'object'	
                        THEN NULL
                    ELSE ttt.val
                end AS parsed
            FROM
            (
                SELECT 	res.lvl + 1 AS lvl,
                        format(' %s ',res.val->>'operator') AS op,
                        res.rn AS prev	,
                        val.v  AS val,
                        val.idx
                    FROM res, 
                         jsonb_array_elements(res.val->'value') WITH ordinality AS val(v, idx)
            ) ttt
    )
    SELECT 	r.lvl	,
            r.rn	,
            r.idx   ,
            case upper(r.op) 
                when ' XOR '
                    then ' OPERATOR(reclada.##) ' 
                else upper(r.op) 
            end,
            r.prev  ,
            r.val	,
            r.parsed
        FROM res r
$$;


--
-- Name: perform_trigger_function(bigint[], text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.perform_trigger_function(_list_id bigint[], _trigger_type text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    _query          text ;           
BEGIN
    SELECT string_agg(sbq.subquery, '')
	    FROM ( 
            SELECT  'SELECT reclada.' 
                    || vtf.function_name 
                    || '(' 
                    || idcl.id
                    || ');'
                    || chr(10) AS subquery
                FROM reclada.v_trigger vt
                    JOIN reclada.v_db_trigger_function vtf
                        ON vt.function_guid = vtf.function_guid
                    CROSS JOIN (SELECT vo.id, vo.class_name 
                            FROM reclada.v_object vo
                                WHERE vo.id IN (SELECT unnest(_list_id))
                        ) idcl
                        WHERE vt.trigger_type = _trigger_type
                            AND idcl.class_name IN (SELECT jsonb_array_elements_text(vt.for_classes))
            ) sbq
        INTO _query;

    IF _query IS NOT NULL THEN
        raise notice '(%)', _query;
        EXECUTE _query;
    END IF;
END;
$$;


--
-- Name: refresh_mv(text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.refresh_mv(class_name text) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    CASE class_name
        WHEN 'ObjectStatus' THEN
            REFRESH MATERIALIZED VIEW reclada.v_object_status;
        WHEN 'User' THEN
            REFRESH MATERIALIZED VIEW reclada.v_user;
        WHEN 'jsonschema' THEN
            REFRESH MATERIALIZED VIEW reclada.v_class_lite;
        WHEN 'uniFields' THEN
            REFRESH MATERIALIZED VIEW reclada.v_class_lite;
            REFRESH MATERIALIZED VIEW reclada.v_object_unifields;
        WHEN 'All' THEN
            REFRESH MATERIALIZED VIEW reclada.v_object_status;
            REFRESH MATERIALIZED VIEW reclada.v_user;
            REFRESH MATERIALIZED VIEW reclada.v_class_lite;
            REFRESH MATERIALIZED VIEW reclada.v_object_unifields;
        ELSE
            NULL;
    END CASE;
END;
$$;


--
-- Name: remove_parent_guid(jsonb, text); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.remove_parent_guid(_data jsonb, parent_field text) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        IF (parent_field IS NOT NULL) THEN
            _data := _data #- format('{attributes,%s}',parent_field)::text[];
        END IF;
        _data := _data - 'parent_guid';
        _data := _data - 'GUID';
        RETURN _data;
    END;
$$;


--
-- Name: update(jsonb, jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.update(_data jsonb, user_info jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    _f_name       TEXT = 'reclada_object.update';
    _class_name   text;
    _class_uuid   uuid;
    _obj_id       uuid;
    _attrs        jsonb;
    schema        jsonb;
    old_obj       jsonb;
    branch        uuid;
    revid         uuid;
    _parent_guid  uuid;
    _parent_field text;
    _obj_guid     uuid;
    _dup_behavior reclada.dp_bhvr;
    _uni_field    text;
    _cnt          int;
    _tran_id      bigint;
    _guid_list    text;
BEGIN

    SELECT  valid_schema, 
            attributes,
            class_name,
            class_guid 
        FROM reclada.validate_json_schema(_data)
        INTO    schema      , 
                _attrs      ,
                _class_name ,
                _class_uuid ;

    _obj_id := _data->>'GUID';
    IF (_obj_id IS NULL) THEN
        perform reclada.raise_exception('Could not update object with no GUID',_f_name);
    END IF;

    _tran_id = coalesce(    
                    (_data->>'transactionID')::bigint, 
                    (
                        select transaction_id 
                            from reclada.v_active_object 
                                where obj_id = _obj_id
                    )
                );

    -- don't allow update jsonschema
    if _class_name = 'jsonschema' then
        perform reclada.raise_exception('Can''t update jsonschema',_f_name);
    end if;

    SELECT 	v.data
        FROM reclada.v_object v
	        WHERE v.obj_id = _obj_id
                AND v.class_name = _class_name 
	    INTO old_obj;

    IF (old_obj IS NULL) THEN
        perform reclada.raise_exception('Could not update object, no such id');
    END IF;

    branch := _data->'branch';
    SELECT reclada_revision.create(user_info->>'sub', branch, _obj_id, _tran_id) 
        INTO revid;

    SELECT prnt_guid, prnt_field
    FROM reclada_object.get_parent_guid(_data,_class_name)
        INTO _parent_guid,
            _parent_field;

    IF (_parent_guid IS NULL) THEN
        _parent_guid := old_obj->>'parentGUID';
    END IF;
    
    IF EXISTS (
        SELECT 1
        FROM reclada.v_object_unifields
        WHERE class_uuid=_class_uuid
    )
    THEN
        SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg(DISTINCT obj_guid::text, ',')
        FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)
        GROUP BY dup_behavior
            INTO _cnt, _dup_behavior, _guid_list;
        IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN
            RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;
        END IF;
        FOR _obj_guid, _dup_behavior, _uni_field IN (
                SELECT obj_guid, dup_behavior, dup_field
                FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)
            ) LOOP
            IF _dup_behavior IN ('Update','Merge') THEN
                UPDATE reclada.object o
                    SET status = reclada_object.get_archive_status_obj_id()
                WHERE o.GUID = _obj_guid
                    AND status != reclada_object.get_archive_status_obj_id();
            END IF;
            CASE _dup_behavior
                WHEN 'Replace' THEN
                    PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);
                WHEN 'Update' THEN                    
                    _data := reclada_object.remove_parent_guid(_data, _parent_field);
                    _data := reclada_object.update_json_by_guid(_obj_guid, _data);
                    RETURN reclada_object.update(_data);
                WHEN 'Reject' THEN
                    RAISE EXCEPTION 'Duplicate found (GUID: %). Object rejected.', _obj_guid;
                WHEN 'Copy'    THEN
                    _attrs = _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;
                    IF (NOT(public.validate_json_schema(schema, _attrs))) THEN
                        RAISE EXCEPTION 'JSON invalid: %', _attrs;
                    END IF;
                WHEN 'Insert' THEN
                    -- DO nothing
                WHEN 'Merge' THEN     
                    _data := reclada_object.remove_parent_guid(_data, _parent_field);               
                    RETURN reclada_object.update(
                        reclada_object.merge(
                            _data - 'class', 
                            vao.data, 
                            schema
                        ) || format('{"GUID": "%s"}', _obj_guid)::jsonb
                    )
                        FROM reclada.v_active_object vao
                            WHERE obj_id = _obj_guid;
            END CASE;
        END LOOP;
    END IF;

    with t as 
    (
        update reclada.object o
            set status = reclada_object.get_archive_status_obj_id()
                where o.GUID = _obj_id
                    and status != reclada_object.get_archive_status_obj_id()
                        RETURNING id
    )
    INSERT INTO reclada.object( GUID,
                                class,
                                status,
                                attributes,
                                transaction_id,
                                parent_guid
                              )
        select  v.obj_id,
                _class_uuid,
                reclada_object.get_active_status_obj_id(),--status 
                _attrs || format('{"revision":"%s"}',revid)::jsonb,
                _tran_id,
                _parent_guid
            FROM reclada.v_object v
            JOIN 
            (   
                select id 
                    FROM 
                    (
                        select id, 1 as q
                            from t
                        union 
                        select id, 2 as q
                            from reclada.object ro
                                where ro.guid = _obj_id
                                    ORDER BY ID DESC 
                                        LIMIT 1
                    ) ta
                    ORDER BY q ASC 
                        LIMIT 1
            ) as tt
                on tt.id = v.id
	            WHERE v.obj_id = _obj_id;

    --PERFORM reclada.update_unique_object(ARRAY[_obj_id]);

    PERFORM reclada_object.object_insert
            (
                _class_name,
                _obj_id,
                _attrs
            );
    PERFORM reclada_object.refresh_mv(_class_name);

    IF ( _class_name = 'jsonschema' AND jsonb_typeof(_attrs->'dupChecking') = 'array') THEN
        PERFORM reclada_object.refresh_mv('uniFields');
    END IF; 

    SELECT reclada.jsonb_merge(v.data, v.default_value) AS data
        FROM reclada.v_active_object v
            WHERE v.obj_id = _obj_id
        INTO _data;
    PERFORM reclada_notification.send_object_notification('update', _data);
    RETURN _data;
END;
$$;


--
-- Name: update_json(jsonb, jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.update_json(lobj jsonb, robj jsonb) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        res     jsonb;
        ltype    text;
        rtype    text;
    BEGIN
        ltype := jsonb_typeof(lobj);
        rtype := jsonb_typeof(robj);
        IF (robj IS NULL) THEN
            RETURN lobj;
        END IF;
        IF (lobj IS NULL) THEN
            RETURN robj;
        END IF;
        IF reclada_object.is_equal(lobj,robj) THEN
            RETURN lobj;
        END IF;
        IF (ltype = 'array' and rtype != 'array') THEN
            RETURN lobj || robj;
        END IF;
        IF (ltype != rtype) THEN
            RETURN robj;
        END IF;
        CASE ltype 
        WHEN 'object' THEN
            SELECT jsonb_object_agg(key,val)
            FROM (
                SELECT key, reclada_object.update_json(lval,rval) AS val
                FROM (                     -- Using joining operators compatible with update_json or hash join is obligatory
                    SELECT (a.rec).key as key,
                        (a.rec).value AS lval,
                        (b.rec).value AS rval                                        --    with FULL OUTER JOIN. update_json is compatible only with NESTED LOOPS
                    FROM (SELECT jsonb_each(lobj) AS rec) a         --    so I use LEFT JOIN UNION ALL RIGHT JOIN insted of FULL OUTER JOIN.
                    LEFT JOIN
                        (SELECT jsonb_each(robj) AS rec) b
                    ON (a.rec).key = (b.rec).key
                UNION
                    SELECT (a.rec).key as key,
                        (b.rec).value AS lval,
                        (a.rec).value AS rval
                    FROM (SELECT jsonb_each(robj) AS rec) a
                    LEFT JOIN
                        (SELECT jsonb_each(lobj) AS rec) b
                    ON (a.rec).key = (b.rec).key
                ) a
            ) b
                INTO res;
            RETURN res;
        WHEN 'array' THEN
            RETURN robj;
        WHEN 'string' THEN
            RETURN robj;
        WHEN 'number' THEN
            RETURN robj;
        WHEN 'boolean' THEN
            RETURN robj;
        WHEN 'null' THEN
            RETURN 'null'::jsonb;   
        ELSE
            RETURN null;
        END CASE;
    END;
$$;


--
-- Name: update_json_by_guid(uuid, jsonb); Type: FUNCTION; Schema: reclada_object; Owner: -
--

CREATE FUNCTION reclada_object.update_json_by_guid(lobj uuid, robj jsonb) RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
    SELECT reclada_object.update_json(data, robj)
    FROM reclada.v_active_object
    WHERE obj_id = lobj;
$$;


--
-- Name: create(character varying, uuid, uuid, bigint); Type: FUNCTION; Schema: reclada_revision; Owner: -
--

CREATE FUNCTION reclada_revision."create"(userid character varying, branch uuid, obj uuid, tran_id bigint DEFAULT reclada.get_transaction_id()) RETURNS uuid
    LANGUAGE sql
    AS $$
    INSERT INTO reclada.object
        (
            class,
            attributes,
            transaction_id
        )
               
        VALUES
        (
            (reclada_object.get_schema('revision')->>'GUID')::uuid,-- class,
            format                    -- attributes
            (                         
                '{
                    "num": %s,
                    "user": "%s",
                    "dateTime": "%s",
                    "branch": "%s"
                }',
                (
                    select count(*) + 1
                        from reclada.object o
                            where o.GUID = obj
                ),
                userid,
                now(),
                branch
            )::jsonb,
            tran_id
        ) RETURNING (GUID)::uuid;
    --nextval('reclada.reclada_revisions'),
$$;


--
-- Name: auth_by_token(character varying); Type: FUNCTION; Schema: reclada_user; Owner: -
--

CREATE FUNCTION reclada_user.auth_by_token(token character varying) RETURNS jsonb
    LANGUAGE sql IMMUTABLE
    AS $$
    SELECT '{}'::jsonb
$$;


--
-- Name: disable_auth(jsonb); Type: FUNCTION; Schema: reclada_user; Owner: -
--

CREATE FUNCTION reclada_user.disable_auth(data jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM reclada.auth_setting;
END;
$$;


--
-- Name: is_allowed(jsonb, text, text); Type: FUNCTION; Schema: reclada_user; Owner: -
--

CREATE FUNCTION reclada_user.is_allowed(jsonb, text, text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN TRUE;
END;
$$;


--
-- Name: refresh_jwk(jsonb); Type: FUNCTION; Schema: reclada_user; Owner: -
--

CREATE FUNCTION reclada_user.refresh_jwk(data jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_oidc_url VARCHAR;
    new_jwk JSONB;
BEGIN
    SELECT oidc_url INTO current_oidc_url FROM reclada.auth_setting FOR UPDATE;
    new_jwk := reclada_user.get_jwk(current_oidc_url);
    UPDATE reclada.auth_setting SET jwk=new_jwk WHERE oidc_url=current_oidc_url;
END;
$$;


--
-- Name: setup_keycloak(jsonb); Type: FUNCTION; Schema: reclada_user; Owner: -
--

CREATE FUNCTION reclada_user.setup_keycloak(data jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    oidc_url VARCHAR;
    jwk JSONB;
BEGIN
    -- check if allowed?
    oidc_url := format(
        '%s/auth/realms/%s/protocol/openid-connect',
        data->>'baseUrl', data->>'realm'
    );
    jwk := reclada_user.get_jwk(oidc_url);

    DELETE FROM reclada.auth_setting;
    INSERT INTO reclada.auth_setting
        (oidc_url, oidc_client_id, oidc_redirect_url, jwk)
    VALUES
        (oidc_url, data->>'clientId', data->>'redirectUrl', jwk);
END;
$$;


--
-- Name: jsonb_object_agg(jsonb); Type: AGGREGATE; Schema: reclada; Owner: -
--

CREATE AGGREGATE reclada.jsonb_object_agg(jsonb) (
    SFUNC = jsonb_concat,
    STYPE = jsonb,
    INITCOND = '{}'
);


--
-- Name: ##; Type: OPERATOR; Schema: reclada; Owner: -
--

CREATE OPERATOR reclada.## (
    FUNCTION = reclada.xor,
    LEFTARG = boolean,
    RIGHTARG = boolean
);


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: component; Type: TABLE; Schema: dev; Owner: -
--

CREATE TABLE dev.component (
    name text NOT NULL,
    repository text NOT NULL,
    commit_hash text NOT NULL,
    guid uuid NOT NULL,
    parent_component_name text
);


--
-- Name: component_object; Type: TABLE; Schema: dev; Owner: -
--

CREATE TABLE dev.component_object (
    id bigint NOT NULL,
    status text DEFAULT 'need to check'::text NOT NULL,
    data jsonb NOT NULL
);


--
-- Name: component_object_id_seq; Type: SEQUENCE; Schema: dev; Owner: -
--

ALTER TABLE dev.component_object ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dev.component_object_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: meta_data; Type: TABLE; Schema: dev; Owner: -
--

CREATE TABLE dev.meta_data (
    id bigint NOT NULL,
    ver bigint,
    data jsonb
);


--
-- Name: meta_data_id_seq; Type: SEQUENCE; Schema: dev; Owner: -
--

ALTER TABLE dev.meta_data ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dev.meta_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: t_dbg; Type: TABLE; Schema: dev; Owner: -
--

CREATE TABLE dev.t_dbg (
    id integer NOT NULL,
    msg text NOT NULL,
    time_when timestamp with time zone DEFAULT now()
);


--
-- Name: t_dbg_id_seq; Type: SEQUENCE; Schema: dev; Owner: -
--

ALTER TABLE dev.t_dbg ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dev.t_dbg_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: ver; Type: TABLE; Schema: dev; Owner: -
--

CREATE TABLE dev.ver (
    id integer NOT NULL,
    ver integer NOT NULL,
    ver_str text,
    upgrade_script text NOT NULL,
    downgrade_script text NOT NULL,
    run_at timestamp with time zone DEFAULT now()
);


--
-- Name: ver_id_seq; Type: SEQUENCE; Schema: dev; Owner: -
--

ALTER TABLE dev.ver ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dev.ver_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: auth_setting; Type: TABLE; Schema: reclada; Owner: -
--

CREATE TABLE reclada.auth_setting (
    oidc_url character varying,
    oidc_client_id character varying,
    oidc_redirect_url character varying,
    jwk jsonb
);


--
-- Name: draft; Type: TABLE; Schema: reclada; Owner: -
--

CREATE TABLE reclada.draft (
    id bigint NOT NULL,
    guid uuid NOT NULL,
    user_guid uuid DEFAULT reclada_object.get_default_user_obj_id(),
    data jsonb NOT NULL,
    parent_guid uuid
);


--
-- Name: draft_id_seq; Type: SEQUENCE; Schema: reclada; Owner: -
--

ALTER TABLE reclada.draft ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME reclada.draft_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: object; Type: TABLE; Schema: reclada; Owner: -
--

CREATE TABLE reclada.object (
    id bigint NOT NULL,
    status uuid DEFAULT reclada_object.get_active_status_obj_id() NOT NULL,
    attributes jsonb NOT NULL,
    transaction_id bigint NOT NULL,
    created_time timestamp with time zone DEFAULT now(),
    created_by uuid DEFAULT reclada_object.get_default_user_obj_id(),
    class uuid NOT NULL,
    guid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    parent_guid uuid
);


--
-- Name: object_id_seq; Type: SEQUENCE; Schema: reclada; Owner: -
--

ALTER TABLE reclada.object ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME reclada.object_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 10
);


--
-- Name: staging; Type: TABLE; Schema: reclada; Owner: -
--

CREATE TABLE reclada.staging (
    data jsonb NOT NULL
);


--
-- Name: transaction_id; Type: SEQUENCE; Schema: reclada; Owner: -
--

CREATE SEQUENCE reclada.transaction_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: v_class_lite; Type: MATERIALIZED VIEW; Schema: reclada; Owner: -
--

CREATE MATERIALIZED VIEW reclada.v_class_lite AS
 WITH RECURSIVE objects_schemas AS (
         SELECT obj_1.id,
            obj_1.guid AS obj_id,
            (obj_1.attributes ->> 'forClass'::text) AS for_class,
            ((obj_1.attributes ->> 'version'::text))::bigint AS version,
            obj_1.created_time,
            obj_1.attributes,
            obj_1.status
           FROM reclada.object obj_1
          WHERE (obj_1.class = reclada_object.get_jsonschema_guid())
        ), paths_to_default AS (
         SELECT ((('{'::text || row_attrs_base.key) || '}'::text))::text[] AS path_head,
            row_attrs_base.value AS path_tail,
            o.obj_id
           FROM (objects_schemas o
             CROSS JOIN LATERAL jsonb_each(o.attributes) row_attrs_base(key, value))
          WHERE ((jsonb_typeof(row_attrs_base.value) = 'object'::text) AND ((o.attributes)::text ~~ '%default%'::text))
        UNION ALL
         SELECT (p.path_head || row_attrs_rec.key) AS path_head,
            row_attrs_rec.value AS path_tail,
            p.obj_id
           FROM (paths_to_default p
             CROSS JOIN LATERAL jsonb_each(p.path_tail) row_attrs_rec(key, value))
          WHERE (jsonb_typeof(row_attrs_rec.value) = 'object'::text)
        ), tmp AS (
         SELECT reclada.jsonb_deep_set('{}'::jsonb, t.path_head[(array_position(t.path_head, 'properties'::text) + 1):], (t.path_tail -> 'default'::text)) AS default_jsonb,
            t.obj_id
           FROM paths_to_default t
          WHERE ((t.path_tail -> 'default'::text) IS NOT NULL)
        ), default_field AS (
         SELECT (format('{"attributes": %s}'::text, reclada.jsonb_object_agg(tmp.default_jsonb)))::jsonb AS default_value,
            tmp.obj_id
           FROM tmp
          GROUP BY tmp.obj_id
        )
 SELECT obj.id,
    obj.obj_id,
    obj.for_class,
    obj.version,
    obj.created_time,
    obj.attributes,
    obj.status,
    def.default_value
   FROM (objects_schemas obj
     LEFT JOIN default_field def ON ((def.obj_id = obj.obj_id)))
  WITH NO DATA;


--
-- Name: v_object_status; Type: MATERIALIZED VIEW; Schema: reclada; Owner: -
--

CREATE MATERIALIZED VIEW reclada.v_object_status AS
 SELECT obj.id,
    obj.guid AS obj_id,
    (obj.attributes ->> 'caption'::text) AS caption,
    obj.created_time,
    obj.attributes AS attrs
   FROM reclada.object obj
  WHERE (obj.class IN ( SELECT reclada_object.get_guid_for_class('ObjectStatus'::text) AS get_guid_for_class))
  WITH NO DATA;


--
-- Name: v_user; Type: MATERIALIZED VIEW; Schema: reclada; Owner: -
--

CREATE MATERIALIZED VIEW reclada.v_user AS
 SELECT obj.id,
    obj.guid AS obj_id,
    (obj.attributes ->> 'login'::text) AS login,
    obj.created_time,
    obj.attributes AS attrs
   FROM reclada.object obj
  WHERE ((obj.class IN ( SELECT reclada_object.get_guid_for_class('User'::text) AS get_guid_for_class)) AND (obj.status = reclada_object.get_active_status_obj_id()))
  WITH NO DATA;


--
-- Name: v_object; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_object AS
 SELECT t.id,
    t.guid AS obj_id,
    t.class,
    ( SELECT ((r.attributes ->> 'num'::text))::bigint AS num
           FROM reclada.object r
          WHERE ((r.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class)) AND (r.guid = (NULLIF((t.attributes ->> 'revision'::text), ''::text))::uuid))
         LIMIT 1) AS revision_num,
    os.caption AS status_caption,
    (NULLIF((t.attributes ->> 'revision'::text), ''::text))::uuid AS revision,
    t.created_time,
    t.attributes AS attrs,
    cl.for_class AS class_name,
    cl.default_value,
    (( SELECT (json_agg(tmp.*) -> 0)
           FROM ( SELECT t.guid AS "GUID",
                    t.class,
                    os.caption AS status,
                    t.attributes,
                    t.transaction_id AS "transactionID",
                    t.parent_guid AS "parentGUID",
                    t.created_by AS "createdBy",
                    t.created_time AS "createdTime") tmp))::jsonb AS data,
    u.login AS login_created_by,
    t.created_by,
    t.status,
    t.transaction_id,
    t.parent_guid
   FROM (((reclada.object t
     LEFT JOIN reclada.v_object_status os ON ((t.status = os.obj_id)))
     LEFT JOIN reclada.v_user u ON ((u.obj_id = t.created_by)))
     LEFT JOIN reclada.v_class_lite cl ON ((cl.obj_id = t.class)));


--
-- Name: v_active_object; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_active_object AS
 SELECT t.id,
    t.obj_id,
    t.class,
    t.revision_num,
    t.status,
    t.status_caption,
    t.revision,
    t.created_time,
    t.class_name,
    t.attrs,
    t.data,
    t.transaction_id,
    t.parent_guid,
    t.default_value
   FROM reclada.v_object t
  WHERE (t.status = reclada_object.get_active_status_obj_id());


--
-- Name: v_class; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_class AS
 SELECT obj.id,
    obj.obj_id,
    cl.for_class,
    cl.version,
    obj.revision_num,
    obj.status_caption,
    obj.revision,
    obj.created_time,
    obj.attrs,
    obj.status,
    obj.data,
    obj.parent_guid,
    cl.default_value
   FROM (reclada.v_class_lite cl
     JOIN reclada.v_active_object obj ON ((cl.id = obj.id)));


--
-- Name: v_component; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_component AS
 SELECT obj.id,
    obj.obj_id AS guid,
    (obj.attrs ->> 'name'::text) AS name,
    (obj.attrs ->> 'repository'::text) AS repository,
    (obj.attrs ->> 'commitHash'::text) AS commit_hash,
    obj.transaction_id,
    obj.revision_num,
    obj.status_caption,
    obj.revision,
    obj.created_time,
    obj.attrs,
    obj.status,
    obj.data
   FROM reclada.v_active_object obj
  WHERE (obj.class_name = 'Component'::text);


--
-- Name: v_relationship; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_relationship AS
 SELECT obj.id,
    obj.obj_id AS guid,
    (obj.attrs ->> 'type'::text) AS type,
    ((obj.attrs ->> 'object'::text))::uuid AS object,
    ((obj.attrs ->> 'subject'::text))::uuid AS subject,
    obj.parent_guid,
    obj.revision_num,
    obj.status_caption,
    obj.revision,
    obj.created_time,
    obj.attrs,
    obj.status,
    obj.data
   FROM reclada.v_active_object obj
  WHERE (obj.class_name = 'Relationship'::text);


--
-- Name: v_component_object; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_component_object AS
 SELECT o.id,
    c.name AS component_name,
    c.guid AS component_guid,
    o.transaction_id,
    o.class_name,
    o.obj_id,
    o.data AS obj_data,
    r.guid AS relationship_guid
   FROM ((reclada.v_component c
     JOIN reclada.v_relationship r ON (((r.parent_guid = c.guid) AND ('data of reclada-component'::text = r.type))))
     JOIN reclada.v_active_object o ON ((o.obj_id = r.subject)));


--
-- Name: v_db_trigger_function; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_db_trigger_function AS
 SELECT vo.obj_id AS function_guid,
    (vo.data #>> '{attributes,name}'::text[]) AS function_name
   FROM reclada.v_active_object vo
  WHERE (vo.class_name = 'DBTriggerFunction'::text);


--
-- Name: v_default_display; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_default_display AS
 SELECT 'string'::text AS json_type,
    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template
UNION
 SELECT 'number'::text AS json_type,
    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template
UNION
 SELECT 'boolean'::text AS json_type,
    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template
UNION
 SELECT 'ObjectDisplay'::text AS json_type,
    '{
                        "classGUID": null,
                        "caption": "#@#classname#@#",
                        "table": {
                            "{status}:string":{
                                "caption": "Status",
                                "width": 250,
                                "displayCSS": "status"
                            },
                            "{createdTime}:string":{
                                "caption": "Created time",
                                "width": 250,
                                "displayCSS": "createdTime"
                            },
                            "{transactionID}:number":{
                                "caption": "Transaction",
                                "width": 250,
                                "displayCSS": "transactionID"
                            },
                            "{GUID}:string":{
                                "caption": "GUID",
                                "width": 250,
                                "displayCSS": "GUID"
                            },
                            "orderRow": [
                                {"{transactionID}:number":"DESC"}
                            ],
                            "orderColumn": []
                        },
                        "card":{
                            "{status}:string":{
                                "caption": "Status",
                                "width": 250,
                                "displayCSS": "status"
                            },
                            "{createdTime}:string":{
                                "caption": "Created time",
                                "width": 250,
                                "displayCSS": "createdTime"
                            },
                            "{transactionID}:number":{
                                "caption": "Transaction",
                                "width": 250,
                                "displayCSS": "transactionID"
                            },
                            "{GUID}:string":{
                                "caption": "GUID",
                                "width": 250,
                                "displayCSS": "GUID"
                            },
                            "orderRow": [
                                {"{transactionID}:number":"DESC"}
                            ],
                            "orderColumn": []
                        },
                        "preview":{
                            "{status}:string":{
                                "caption": "Status",
                                "width": 250,
                                "displayCSS": "status"
                            },
                            "{createdTime}:string":{
                                "caption": "Created time",
                                "width": 250,
                                "displayCSS": "createdTime"
                            },
                            "{transactionID}:number":{
                                "caption": "Transaction",
                                "width": 250,
                                "displayCSS": "transactionID"
                            },
                            "{GUID}:string":{
                                "caption": "GUID",
                                "width": 250,
                                "displayCSS": "GUID"
                            },
                            "orderRow": [
                                {"{transactionID}:number":"DESC"}
                            ],
                            "orderColumn": []
                        },
                        "list":{
                            "{status}:string":{
                                "caption": "Status",
                                "width": 250,
                                "displayCSS": "status"
                            },
                            "{createdTime}:string":{
                                "caption": "Created time",
                                "width": 250,
                                "displayCSS": "createdTime"
                            },
                            "{transactionID}:number":{
                                "caption": "Transaction",
                                "width": 250,
                                "displayCSS": "transactionID"
                            },
                            "{GUID}:string":{
                                "caption": "GUID",
                                "width": 250,
                                "displayCSS": "GUID"
                            },
                            "orderRow": [
                                {"{transactionID}:number":"DESC"}
                            ],
                            "orderColumn": []
                        }
                        
                    }'::text AS template;


--
-- Name: v_dto_json_schema; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_dto_json_schema AS
 SELECT obj.id,
    obj.obj_id,
    (obj.attrs ->> 'function'::text) AS function,
    (obj.attrs -> 'schema'::text) AS schema,
    obj.revision_num,
    obj.status_caption,
    obj.revision,
    obj.created_time,
    obj.attrs,
    obj.status,
    obj.data,
    obj.parent_guid
   FROM reclada.v_active_object obj
  WHERE (obj.class_name = 'DTOJsonSchema'::text);


--
-- Name: v_filter_available_operator; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_filter_available_operator AS
 SELECT ' = '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' LIKE '::text AS operator,
    'TEXT'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' NOT LIKE '::text AS operator,
    'TEXT'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' || '::text AS operator,
    'TEXT'::text AS input_type,
    'TEXT'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' ~ '::text AS operator,
    'TEXT'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' !~ '::text AS operator,
    'TEXT'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' ~* '::text AS operator,
    'TEXT'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' !~* '::text AS operator,
    'TEXT'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' SIMILAR TO '::text AS operator,
    'TEXT'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' > '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' < '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' <= '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' != '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' >= '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' AND '::text AS operator,
    'BOOL'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' OR '::text AS operator,
    'BOOL'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' NOT '::text AS operator,
    'BOOL'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' XOR '::text AS operator,
    'BOOL'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' OPERATOR(reclada.##) '::text AS operator,
    'BOOL'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' IS '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' IS NOT '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' IN '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    ' , '::text AS inner_operator
UNION
 SELECT ' @> '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' <@ '::text AS operator,
    'JSONB'::text AS input_type,
    'BOOL'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' + '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' - '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' * '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' / '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' % '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' ^ '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' |/ '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' ||/ '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' !! '::text AS operator,
    'INT'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' @ '::text AS operator,
    'NUMERIC'::text AS input_type,
    'NUMERIC'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' & '::text AS operator,
    'INT'::text AS input_type,
    'INT'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' | '::text AS operator,
    'INT'::text AS input_type,
    'INT'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' # '::text AS operator,
    'INT'::text AS input_type,
    'INT'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' << '::text AS operator,
    'INT'::text AS input_type,
    'INT'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' >> '::text AS operator,
    'INT'::text AS input_type,
    'INT'::text AS output_type,
    NULL::text AS inner_operator
UNION
 SELECT ' BETWEEN '::text AS operator,
    'TIMESTAMP WITH TIME ZONE'::text AS input_type,
    'BOOL'::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' Y/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' MON/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' D/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' H/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' MIN/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' S/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' DOW/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' DOY/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' Q/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator
UNION
 SELECT ' W/BETWEEN '::text AS operator,
    NULL::text AS input_type,
    NULL::text AS output_type,
    ' AND '::text AS inner_operator;


--
-- Name: v_filter_between; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_filter_between AS
 SELECT ' Y/BETWEEN '::text AS operator,
    'date_part(''YEAR''   , TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format
UNION
 SELECT ' MON/BETWEEN '::text AS operator,
    'date_part(''MONTH''  , TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format
UNION
 SELECT ' D/BETWEEN '::text AS operator,
    'date_part(''DAY''    , TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format
UNION
 SELECT ' H/BETWEEN '::text AS operator,
    'date_part(''HOUR''   , TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format
UNION
 SELECT ' MIN/BETWEEN '::text AS operator,
    'date_part(''MINUTE'' , TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format
UNION
 SELECT ' S/BETWEEN '::text AS operator,
    'date_part(''SECOND'' , TIMESTAMP WITH TIME ZONE %s)::int'::text AS operand_format
UNION
 SELECT ' DOW/BETWEEN '::text AS operator,
    'date_part(''DOW''    , TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format
UNION
 SELECT ' DOY/BETWEEN '::text AS operator,
    'date_part(''DOY''    , TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format
UNION
 SELECT ' Q/BETWEEN '::text AS operator,
    'date_part(''QUARTER'', TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format
UNION
 SELECT ' W/BETWEEN '::text AS operator,
    'date_part(''WEEK''   , TIMESTAMP WITH TIME ZONE %s)'::text AS operand_format;


--
-- Name: v_filter_inner_operator; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_filter_inner_operator AS
 SELECT ' , '::text AS operator,
    'JSONB'::text AS input_type,
    true AS brackets
UNION
 SELECT ' AND '::text AS operator,
    'TIMESTAMP WITH TIME ZONE'::text AS input_type,
    false AS brackets;


--
-- Name: v_filter_mapping; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_filter_mapping AS
 SELECT '{class}'::text AS pattern,
    'class_name'::text AS repl
UNION
 SELECT '{status}'::text AS pattern,
    'status_caption'::text AS repl
UNION
 SELECT '{GUID}'::text AS pattern,
    'obj_id'::text AS repl
UNION
 SELECT '{transactionID}'::text AS pattern,
    'transaction_id'::text AS repl
UNION
 SELECT '{createdTime}'::text AS pattern,
    'created_time'::text AS repl
UNION
 SELECT '{createdBy}'::text AS pattern,
    'created_by'::text AS repl
UNION
 SELECT '{classGUID}'::text AS pattern,
    'class'::text AS repl
UNION
 SELECT '{parentGUID}'::text AS pattern,
    'parent_guid'::text AS repl;


--
-- Name: v_get_duplicates_query; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_get_duplicates_query AS
 SELECT 'SELECT ''
    SELECT vao.obj_id, 
            '''''' || dup_behavior || ''''''::reclada.dp_bhvr,
            '' || is_cascade || '',
            '''''' || COALESCE (copy_field,'''') ||'''''' FROM reclada.v_active_object vao WHERE '' ||  string_agg(predicate, '' OR '') @#@#@exclude_uuid@#@#@
          FROM (SELECT string_agg(''(vao.attrs ->>'''''' || unifield || '''''')'', ''||'' ORDER BY field_number) || ''='''''' || string_agg(COALESCE((''@#@#@attrs@#@#@''::jsonb) ->> unifield,''''),''''  ORDER BY field_number) || '''''''' AS predicate,
          dup_behavior , is_cascade , copy_field
          FROM reclada.v_object_unifields vou 
          WHERE class_uuid = ''@#@#@class_uuid@#@#@''
            AND is_mandatory
          GROUP BY uni_number, dup_behavior , is_cascade , copy_field) a
         GROUP BY dup_behavior , is_cascade , copy_field
'::text AS val;


--
-- Name: v_import_info; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_import_info AS
 SELECT obj.id,
    obj.obj_id AS guid,
    ((obj.attrs ->> 'tranID'::text))::bigint AS tran_id,
    (obj.attrs ->> 'name'::text) AS name,
    obj.revision_num,
    obj.status_caption,
    obj.revision,
    obj.created_time,
    obj.attrs,
    obj.status,
    obj.data
   FROM reclada.v_active_object obj
  WHERE (obj.class_name = 'ImportInfo'::text);


--
-- Name: v_object_display; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_object_display AS
 SELECT obj.id,
    obj.guid,
    ((obj.attributes ->> 'classGUID'::text))::uuid AS class_guid,
    (obj.attributes ->> 'caption'::text) AS caption,
    (obj.attributes -> 'table'::text) AS "table",
    (obj.attributes -> 'card'::text) AS card,
    (obj.attributes -> 'preview'::text) AS preview,
    (obj.attributes -> 'list'::text) AS list,
    obj.created_time,
    obj.attributes,
    obj.status
   FROM reclada.object obj
  WHERE ((obj.class IN ( SELECT reclada_object.get_guid_for_class('ObjectDisplay'::text) AS get_guid_for_class)) AND (obj.status = reclada_object.get_active_status_obj_id()));


--
-- Name: v_object_unifields; Type: MATERIALIZED VIEW; Schema: reclada; Owner: -
--

CREATE MATERIALIZED VIEW reclada.v_object_unifields AS
 SELECT b.for_class,
    b.class_uuid,
    (b.dup_behavior)::reclada.dp_bhvr AS dup_behavior,
    b.is_cascade,
    b.is_mandatory,
    b.uf AS unifield,
    b.uni_number,
    row_number() OVER (PARTITION BY b.for_class, b.uni_number ORDER BY b.uf) AS field_number,
    b.copy_field
   FROM ( SELECT a.for_class,
            a.obj_id AS class_uuid,
            a.dup_behavior,
            (a.is_cascade)::boolean AS is_cascade,
            ((a.dc ->> 'isMandatory'::text))::boolean AS is_mandatory,
            jsonb_array_elements_text((a.dc -> 'uniFields'::text)) AS uf,
            (a.dc -> 'uniFields'::text) AS field_list,
            row_number() OVER (PARTITION BY a.for_class ORDER BY (a.dc -> 'uniFields'::text)) AS uni_number,
            a.copy_field
           FROM ( SELECT vc.for_class,
                    (vc.attributes ->> 'dupBehavior'::text) AS dup_behavior,
                    (vc.attributes ->> 'isCascade'::text) AS is_cascade,
                    jsonb_array_elements((vc.attributes -> 'dupChecking'::text)) AS dc,
                    vc.obj_id,
                    (vc.attributes ->> 'copyField'::text) AS copy_field
                   FROM reclada.v_class_lite vc
                  WHERE (((vc.attributes -> 'dupChecking'::text) IS NOT NULL) AND (vc.status = reclada_object.get_active_status_obj_id()))) a) b
  WITH NO DATA;


--
-- Name: v_parent_field; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_parent_field AS
 SELECT v_class.for_class,
    v_class.obj_id AS class_uuid,
    (v_class.attributes ->> 'parentField'::text) AS parent_field
   FROM reclada.v_class_lite v_class
  WHERE ((v_class.attributes ->> 'parentField'::text) IS NOT NULL);


--
-- Name: v_revision; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_revision AS
 SELECT obj.id,
    obj.obj_id,
    ((obj.attrs ->> 'num'::text))::bigint AS num,
    (obj.attrs ->> 'branch'::text) AS branch,
    (obj.attrs ->> 'user'::text) AS "user",
    (obj.attrs ->> 'dateTime'::text) AS date_time,
    (obj.attrs ->> 'old_num'::text) AS old_num,
    obj.revision_num,
    obj.status_caption,
    obj.revision,
    obj.created_time,
    obj.attrs,
    obj.status,
    obj.data
   FROM reclada.v_active_object obj
  WHERE (obj.class_name = 'revision'::text);


--
-- Name: v_task; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_task AS
 SELECT obj.id,
    obj.obj_id AS guid,
    (obj.attrs ->> 'type'::text) AS type,
    (obj.attrs ->> 'command'::text) AS command,
    obj.revision_num,
    obj.status_caption,
    obj.revision,
    obj.created_time,
    obj.attrs,
    obj.status,
    obj.data
   FROM reclada.v_active_object obj
  WHERE (obj.class_name = 'Task'::text);


--
-- Name: v_trigger; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_trigger AS
 SELECT vo.obj_id AS trigger_guid,
    ((vo.data #>> '{attributes,function}'::text[]))::uuid AS function_guid,
    (vo.data #>> '{attributes,action}'::text[]) AS trigger_type,
    (vo.data #> '{attributes,forClasses}'::text[]) AS for_classes
   FROM reclada.v_active_object vo
  WHERE (vo.class_name = 'DBTrigger'::text);


--
-- Name: v_ui_active_object; Type: VIEW; Schema: reclada; Owner: -
--

CREATE VIEW reclada.v_ui_active_object AS
 SELECT 'with recursive 
d as ( 
    SELECT  reclada.jsonb_merge(obj.data, obj.default_value) AS data,
            obj_id,
            created_time,
            attrs
        FROM reclada.v_active_object obj 
            where #@#@#where#@#@#
                ORDER BY #@#@#orderby#@#@#
                OFFSET #@#@#offset#@#@#
                LIMIT #@#@#limit#@#@#
),
t as
(
    SELECT  je.key,
            1 as q,
            jsonb_typeof(je.value) typ,
            d.obj_id,
            je.value
        from d 
        JOIN LATERAL jsonb_each(d.data) je
            on true
        -- where jsonb_typeof(je.value) != ''null''
    union
    SELECT 
            d.key ||'',''|| je.key as key ,
            d.q,
            jsonb_typeof(je.value) typ,
            d.obj_id,
            je.value
        from (
            select  d.data #> (''{''||t.key||''}'')::text[] as data, 
                    t.q+1 as q,
                    t.key,
                    d.obj_id
            from t 
            join d
                on t.typ = ''object''
        ) d
        JOIN LATERAL jsonb_each(d.data) je
            on true
        -- where jsonb_typeof(je.value) != ''null''
),
res as
(
    select  rr.obj_id,
            rr.data,
            rr.display_key,
            o.attrs,
            o.created_time,
            o.id
        from
        (
            select  t.obj_id,
                    jsonb_object_agg
                    (
                        ''{''||t.key||''}'',
                        t.value
                    ) as data,
                    array_agg(
                        t.key||''#@#@#separator#@#@#''||t.typ 
                    ) as display_key
                from t 
                    where t.typ != ''object''
                    group by t.obj_id
        ) rr
        join reclada.v_active_object o
            on o.obj_id = rr.obj_id
)
'::text AS val;


--
-- Data for Name: component; Type: TABLE DATA; Schema: dev; Owner: -
--

COPY dev.component (name, repository, commit_hash, guid, parent_component_name) FROM stdin;
\.


--
-- Data for Name: component_object; Type: TABLE DATA; Schema: dev; Owner: -
--

COPY dev.component_object (id, status, data) FROM stdin;
\.


--
-- Data for Name: meta_data; Type: TABLE DATA; Schema: dev; Owner: -
--

COPY dev.meta_data (id, ver, data) FROM stdin;
\.


--
-- Data for Name: t_dbg; Type: TABLE DATA; Schema: dev; Owner: -
--

COPY dev.t_dbg (id, msg, time_when) FROM stdin;
\.


--
-- Data for Name: ver; Type: TABLE DATA; Schema: dev; Owner: -
--

COPY dev.ver (id, ver, ver_str, upgrade_script, downgrade_script, run_at) FROM stdin;
1	0	0	select public.raise_exception ('This is 0 version');	select public.raise_exception ('This is 0 version');	2021-09-22 14:50:17.832813+00
2	1	\N	begin;\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 1 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select \t'drop '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n' as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.str = tmp.str \n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n\tyou can use "i 'function/reclada_object.get_schema.sql'"\n\tto run text script of functions\n*/\nCREATE EXTENSION IF NOT EXISTS aws_lambda CASCADE;\ni 'function/api.storage_generate_presigned_get.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\nDROP EXTENSION IF EXISTS aws_lambda CASCADE;\ndrop function IF EXISTS api.storage_generate_presigned_get ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_get(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    credentials  jsonb;\r\n    object_data  jsonb;\r\n    object_id    uuid;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF(NOT(reclada_user.is_allowed(user_info, 'generate presigned post', '{}'))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    SELECT reclada_object.list('{"class": "S3Config", "attrs": {}}')::jsonb -> 0 INTO credentials;\r\n\r\n    -- TODO: check user's permissions for reclada object access?\r\n    object_id := data->>'objectId';\r\n    SELECT reclada_object.list(format(\r\n        '{"class": "File", "attrs": {}, "id": "%s"}',\r\n        object_id\r\n    )::jsonb) -> 0 INTO object_data;\r\n\r\n    SELECT reclada_storage.s3_generate_presigned_get(credentials, object_data) INTO result;\r\n    RETURN result;\r\nEND;\r\n$function$\n	2021-09-22 14:50:40.276561+00
3	2	\N	begin;\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 2 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select \t'drop '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n' as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.str = tmp.str \n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n\tyou can use "i 'function/reclada_object.get_schema.sql'"\n\tto run text script of functions\n*/\nCREATE EXTENSION IF NOT EXISTS aws_lambda CASCADE;\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/api.storage_generate_presigned_post.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\nDROP EXTENSION IF EXISTS aws_lambda CASCADE;\ndrop function IF EXISTS api.storage_generate_presigned_get ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_get(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    credentials  jsonb;\r\n    object_data  jsonb;\r\n    object_id    uuid;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF(NOT(reclada_user.is_allowed(user_info, 'generate presigned post', '{}'))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    SELECT reclada_object.list('{"class": "S3Config", "attrs": {}}')::jsonb -> 0 INTO credentials;\r\n\r\n    -- TODO: check user's permissions for reclada object access?\r\n    object_id := data->>'objectId';\r\n    SELECT reclada_object.list(format(\r\n        '{"class": "File", "attrs": {}, "id": "%s"}',\r\n        object_id\r\n    )::jsonb) -> 0 INTO object_data;\r\n\r\n    SELECT payload\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n            's3_get_presigned_url_dev1',\r\n            'eu-west-1'\r\n            ),\r\n        format('{"uri": "%s", "expiration": 3600}', object_data->'attrs'->> 'uri')::jsonb)\r\n    INTO result;\r\n    RETURN result;\r\nEND;\r\n$function$\n	2021-09-22 14:50:43.856449+00
4	3	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 3 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select \t'drop '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n' as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.str = tmp.str \n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/public.try_cast_int.sql'\n\n\n-- create table reclada.object_status\n-- (\n--     id      bigint GENERATED ALWAYS AS IDENTITY primary KEY,\n--     caption text not null\n-- );\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attrs": {\n        "newClass": "ObjectStatus",\n        "properties": {\n            "caption": {"type": "string"}\n        },\n        "required": ["caption"]\n    }\n}'::jsonb);\n-- insert into reclada.object_status(caption)\n--     select 'active';\nSELECT reclada_object.create('{\n    "class": "ObjectStatus",\n    "attrs": {\n        "caption": "active"\n    }\n}'::jsonb);\n-- insert into reclada.object_status(caption)\n--     select 'archive';\nSELECT reclada_object.create('{\n    "class": "ObjectStatus",\n    "attrs": {\n        "caption": "archive"\n    }\n}'::jsonb);\n\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attrs": {\n        "newClass": "User",\n        "properties": {\n            "login": {"type": "string"}\n        },\n        "required": ["login"]\n    }\n}'::jsonb);\nSELECT reclada_object.create('{\n    "class": "User",\n    "attrs": {\n        "login": "dev"\n    }\n}'::jsonb);\n\n\n\n--SHOW search_path;        \nSET search_path TO public;\nDROP EXTENSION IF EXISTS "uuid-ossp";\nCREATE EXTENSION "uuid-ossp" SCHEMA public;\n\nalter table reclada.object\n    add id bigint GENERATED ALWAYS AS IDENTITY primary KEY,\n    add obj_id       uuid   default public.uuid_generate_v4(),\n    add revision     uuid   ,\n    add obj_id_int   int    ,\n    add revision_int bigint ,\n    add class        text   ,\n    add status       uuid   ,--DEFAULT reclada_object.get_active_status_obj_id(),\n    add attributes   jsonb  ,\n    add transaction_id bigint ,\n    add created_time timestamp with time zone DEFAULT now(),\n    add created_by   uuid  ;--DEFAULT reclada_object.get_default_user_obj_id();\n\ndrop VIEW if EXISTS reclada.v_class;\ndrop VIEW if EXISTS reclada.v_object_status;\n\ni 'view/reclada.v_object_status.sql'\ni 'function/reclada_object.get_active_status_obj_id.sql'\ni 'function/reclada_object.get_archive_status_obj_id.sql'\n\nupdate reclada.object \n    set class      = data->>'class',\n        attributes = data->'attrs' ;\nupdate reclada.object \n    set obj_id_int = public.try_cast_int(data->>'id'),\n        revision_int  = (data->'revision')::bigint   \n        -- status  = (data->'isDeleted')::boolean::int+1,\n        ;\nupdate reclada.object \n    set obj_id = (data->>'id')::uuid\n        WHERE obj_id_int is null;\n\nupdate reclada.object \n    set status  = \n        case coalesce((data->'isDeleted')::boolean::int+1,1)\n            when 1 \n                then reclada_object.get_active_status_obj_id()\n            else reclada_object.get_archive_status_obj_id()\n        end;\n\ni 'view/reclada.v_user.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'function/reclada_object.get_default_user_obj_id.sql'\n\nalter table reclada.object\n    alter COLUMN status \n        set DEFAULT reclada_object.get_active_status_obj_id(),\n    alter COLUMN created_by \n        set DEFAULT reclada_object.get_default_user_obj_id();\n\nupdate reclada.object set created_by = reclada_object.get_default_user_obj_id();\n\n-- ,   id   \nselect public.raise_exception('exist numeric id for other class!!!')\n    where exists\n    (\n        select 1 \n            from reclada.object \n                where obj_id_int is not null \n                    and class != 'revision'\n    );\n\nupdate reclada.object --  ,     \n    set status = reclada_object.get_active_status_obj_id()\n        WHERE status is null;\n\n\n--  obj_id    \nupdate reclada.object as o\n    set obj_id = g.obj_id\n    from \n    (\n        select  g.obj_id_int ,\n                public.uuid_generate_v4() as obj_id\n            from reclada.object g\n            GROUP BY g.obj_id_int\n            HAVING g.obj_id_int is not NULL\n    ) g\n        where g.obj_id_int = o.obj_id_int;\n\n--     attrs\nupdate reclada.object o\n    set attributes = o.attributes \n                || jsonb ('{"num":'|| \n                    (\n                        select count(1)+1 \n                            from reclada.object c\n                                where c.obj_id = o.obj_id \n                                    and c.obj_id_int< o.obj_id_int\n                    )::text ||'}')\n                --       \n                || jsonb ('{"old_num":'|| o.obj_id_int::text ||'}')\n        where o.obj_id_int is not null;\n\n--     \nupdate reclada.object as o\n    set revision = g.obj_id\n    from \n    (\n        select  g.obj_id_int ,\n                g.obj_id\n            from reclada.object g\n            GROUP BY    g.obj_id_int ,\n                        g.obj_id\n            HAVING g.obj_id_int is not NULL\n    ) g\n        where o.revision_int = g.obj_id_int;\nalter table reclada.object alter column data drop not null;\n\nalter table reclada.object \n    alter column attributes set not null,\n    alter column class set not null,\n    alter column status set not null,\n    alter column obj_id set not null;\n\n-- delete from reclada.object where attrs is null\n\ni 'view/reclada.v_class.sql'\ni 'view/reclada.v_revision.sql'\ni 'function/reclada.datasource_insert_trigger_fnc.sql'\ni 'function/reclada_object.get_schema.sql'\ni 'function/reclada.load_staging.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.delete.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_revision.create.sql'\n\n\n--   \nalter table reclada.object\n    drop column revision_int,\n    drop column data,\n    drop column obj_id_int;\n\n\n--{ indexes\nDROP INDEX IF EXISTS reclada.class_index;\nCREATE INDEX class_index \n\tON reclada.object(class);\n\nDROP INDEX IF EXISTS reclada.obj_id_index;\nCREATE INDEX obj_id_index \n\tON reclada.object(obj_id);\n\nDROP INDEX IF EXISTS reclada.revision_index;\nCREATE INDEX revision_index \n\tON reclada.object(revision);\n\nDROP INDEX IF EXISTS reclada.status_index;\nCREATE INDEX status_index \n\tON reclada.object(status);\n\nDROP INDEX IF EXISTS reclada.job_status_index;\nCREATE INDEX job_status_index \n\tON reclada.object((attributes->'status'))\n\tWHERE class = 'Job';\n\nDROP INDEX IF EXISTS reclada.runner_status_index;\nCREATE INDEX runner_status_index\n\tON reclada.object((attributes->'status'))\n\tWHERE class = 'Runner';\n\nDROP INDEX IF EXISTS reclada.runner_type_index;\nCREATE INDEX runner_type_index \n\tON reclada.object((attributes->'type'))\n\tWHERE class = 'Runner';\n--} indexes\n\nupdate reclada.object o \n    set attributes = o.attributes || format('{"revision":"%s"}',o.revision)::jsonb\n        where o.revision is not null;\n\nalter table reclada.object\n    drop COLUMN revision;\n\n\ni 'function/reclada_notification.send_object_notification.sql'\ni 'function/reclada_object.list_add.sql'\ni 'function/reclada_object.list_drop.sql'\ni 'function/reclada_object.list_related.sql'\ni 'function/api.reclada_object_create.sql'\ni 'function/api.reclada_object_delete.sql'\ni 'function/api.reclada_object_list.sql'\ni 'function/api.reclada_object_list_add.sql'\ni 'function/api.reclada_object_list_drop.sql'\ni 'function/api.reclada_object_list_related.sql'\ni 'function/api.storage_generate_presigned_get.sql'\n\n\n--select dlkfmdlknfal();\n\n-- test 1\n-- select reclada_revision.create('123', null,'e2bdd471-cf23-46a9-84cf-f9e15db7887d')\n-- SELECT reclada_object.create('\n--   {\n--        "class": "Job",\n--        "revision": 10,\n--        "attrs": {\n--            "task": "c94bff30-15fa-427f-9954-d5c3c151e652",\n--            "status": "new",\n--            "type": "K8S",\n--            "command": "./run_pipeline.sh",\n--            "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\n--            }\n--        }'::jsonb);\n--\n-- SELECT reclada_object.update('\n--   {\n--      "id": "f47596e6-3117-419e-ab6d-2174f0ebf471",\n-- \t \t"class": "Job",\n--        "attrs": {\n--            "task": "c94bff30-15fa-427f-9954-d5c3c151e652",\n--            "status": "new",\n--            "type": "K8S",\n--            "command": "./run_pipeline.sh",\n--            "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\n--            }\n--        }'::jsonb);\n\n-- SELECT reclada_object.delete( '{\n--       "id": "6cff152e-8391-4997-8134-8257e2717ac4"}')\n\n\n--select count(1)+1 \n--                        from reclada.object o\n--                            where o.obj_id = 'e2bdd471-cf23-46a9-84cf-f9e15db7887d'\n--\n--SELECT * FROM reclada.v_revision ORDER BY ID DESC -- 77\n--    LIMIT 300\n-- insert into staging\n--\tselect '{"id": "feb80c85-b0a7-40f8-864a-c874ff919bd1", "attrs": {"name": "Tmtagg tes2t f1ile.xlsx"}, "class": "Document", "fileId": "25ca0de7-e5b5-45f3-a368-788fe7eaecf8"}'\n\n-- select reclada_object.get_schema('Job')\n--update\n-- +"reclada_object.list"\n-- + "reclada_object.update"\n-- + "reclada_object.delete"\n-- + "reclada_object.create"\n-- + "reclada.load_staging"\n-- + "reclada_object.get_schema"\n-- + "reclada_revision.create"\n\n-- test\n-- + reclada.datasource_insert_trigger_fnc\n-- + reclada.load_staging\n-- + reclada_object.list\n-- + reclada_object.get_schema\n-- + reclada_object.delete\n-- + reclada_object.create\n-- + reclada_object.update\n-- + reclada_revision.create\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');\n	2021-09-22 14:50:50.411942+00
5	4	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 4 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select \t'drop '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n' as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.str = tmp.str \n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada.datasource_insert_trigger_fnc.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');\n	2021-09-22 14:51:02.230956+00
6	5	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 5 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select \t'drop '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n' as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.str = tmp.str \n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.delete.sql'\ni 'function/reclada_object.list_add.sql'\ni 'function/reclada_object.list_drop.sql'\ni 'function/reclada_object.list_related.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');\n	2021-09-22 14:51:05.402513+00
7	6	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 6 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select \t'drop '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n' as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.str = tmp.str \n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.list_related.sql'\ni 'function/api.reclada_object_list.sql'\ni 'function/api.reclada_object_list_related.sql'\ni 'reclada.datasource_insert_trigger_fnc.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');\n	2021-09-22 14:51:09.193017+00
28	27	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 27 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nDELETE FROM reclada.object\nWHERE GUID IS NULL;\n\nALTER TABLE reclada.object\n    ALTER COLUMN GUID SET NOT NULL;\nALTER TABLE reclada.object\n    ALTER GUID SET DEFAULT public.uuid_generate_v4();\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-22 14:52:40.006303+00
8	7	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 7 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select \t'drop '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n' as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.str = tmp.str \n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.list.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');\n	2021-09-22 14:51:12.92018+00
9	8	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 8 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nDROP TRIGGER IF EXISTS datasource_insert_trigger ON reclada.object;\nCREATE TRIGGER datasource_insert_trigger\n  BEFORE INSERT\n  ON reclada.object FOR EACH ROW\n  EXECUTE PROCEDURE reclada.datasource_insert_trigger_fnc();\n\n/*\n    if we use AFTER trigger \n    code from reclada_object.create:\n        with inserted as \n        (\n            INSERT INTO reclada.object(class,attributes)\n                select class, attrs\n                    RETURNING obj_id\n        ) \n        insert into tmp(id)\n            select obj_id \n                from inserted;\n    twice returns obj_id for object which created from trigger (Job).\n    \n    As result query:\n        SELECT reclada_object.create('{"id": "", "class": "File", \n\t\t\t\t\t\t\t \t"attrs":{\n\t\t\t\t\t\t\t \t\t"name": "SCkyqZSNmCFlWxPNSHWl", \n\t\t\t\t\t\t\t\t \t"checksum": "", \n\t\t\t\t\t\t\t\t \t"mimeType": "application/pdf", \n\t\t\t\t\t\t\t \t\t"uri": "s3://test-reclada-bucket/inbox/SCkyqZSNmCFlWxPNSHWl"\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t }', null);\n    selects only Job object.\n*/\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n--select public.raise_exception('Downgrade script not support');\nDROP function IF EXISTS dev.downgrade_version ;\nCREATE OR REPLACE FUNCTION dev.downgrade_version()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\ndeclare \r\n    current_ver int; \r\n    downgrade_script text;\r\n    v_state   TEXT;\r\n    v_msg     TEXT;\r\n    v_detail  TEXT;\r\n    v_hint    TEXT;\r\n    v_context TEXT;\r\nBEGIN\r\n\r\n    select max(ver) \r\n        from dev.VER\r\n    into current_ver;\r\n    \r\n    select v.downgrade_script \r\n        from dev.VER v\r\n            WHERE current_ver = v.ver\r\n        into downgrade_script;\r\n\r\n    if COALESCE(downgrade_script,'') = '' then\r\n        RAISE EXCEPTION 'downgrade_script is empty! from dev.downgrade_version()';\r\n    end if;\r\n\r\n    EXECUTE downgrade_script;\r\n\r\n    -- mark, that chanches applied\r\n    delete \r\n        from dev.VER v\r\n            where v.ver = current_ver;\r\n\r\n    v_msg = 'OK, curren version: ' || (current_ver-1)::text;\r\n    perform public.raise_notice(v_msg);\r\nEXCEPTION when OTHERS then \r\n\tget stacked diagnostics\r\n        v_state   = returned_sqlstate,\r\n        v_msg     = message_text,\r\n        v_detail  = pg_exception_detail,\r\n        v_hint    = pg_exception_hint,\r\n        v_context = pg_exception_context;\r\n\r\n    v_state := format('Got exception:\r\nstate   : %s\r\nmessage : %s\r\ndetail  : %s\r\nhint    : %s\r\ncontext : %s\r\nSQLSTATE: %s\r\nSQLERRM : %s', \r\n                v_state, \r\n                v_msg, \r\n                v_detail, \r\n                v_hint, \r\n                v_context,\r\n                SQLSTATE,\r\n                SQLERRM);\r\n    perform dev.reg_notice(v_state);\r\nEND\r\n$function$\n;\n\n	2021-09-22 14:51:16.142437+00
10	9	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 9 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\ni 'function/dev.downgrade_version.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS dev.downgrade_version ;\nCREATE OR REPLACE FUNCTION dev.downgrade_version()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\ndeclare \r\n    current_ver int; \r\n    downgrade_script text;\r\n    v_state   TEXT;\r\n    v_msg     TEXT;\r\n    v_detail  TEXT;\r\n    v_hint    TEXT;\r\n    v_context TEXT;\r\nBEGIN\r\n\r\n    select max(ver) \r\n        from dev.VER\r\n    into current_ver;\r\n    \r\n    select v.downgrade_script \r\n        from dev.VER v\r\n            WHERE current_ver = v.ver\r\n        into downgrade_script;\r\n\r\n    if COALESCE(downgrade_script,'') = '' then\r\n        RAISE EXCEPTION 'downgrade_script is empty! from dev.downgrade_version()';\r\n    end if;\r\n\r\n    EXECUTE downgrade_script;\r\n\r\n    -- mark, that chanches applied\r\n    delete \r\n        from dev.VER v\r\n            where v.ver = current_ver;\r\n\r\n    v_msg = 'OK, curren version: ' || (current_ver-1)::text;\r\n    perform public.raise_notice(v_msg);\r\nEXCEPTION when OTHERS then \r\n\tget stacked diagnostics\r\n        v_state   = returned_sqlstate,\r\n        v_msg     = message_text,\r\n        v_detail  = pg_exception_detail,\r\n        v_hint    = pg_exception_hint,\r\n        v_context = pg_exception_context;\r\n\r\n    v_state := format('Got exception:\r\nstate   : %s\r\nmessage : %s\r\ndetail  : %s\r\nhint    : %s\r\ncontext : %s\r\nSQLSTATE: %s\r\nSQLERRM : %s', \r\n                v_state, \r\n                v_msg, \r\n                v_detail, \r\n                v_hint, \r\n                v_context,\r\n                SQLSTATE,\r\n                SQLERRM);\r\n    perform dev.reg_notice(v_state);\r\nEND\r\n$function$\n;\n\n	2021-09-22 14:51:19.308047+00
11	10	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 10 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/reclada_object.get_condition_array.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS api.storage_generate_presigned_get ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_get(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    credentials  jsonb;\r\n    object_data  jsonb;\r\n    object_id    uuid;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF(NOT(reclada_user.is_allowed(user_info, 'generate presigned post', '{}'))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    SELECT reclada_object.list('{"class": "S3Config", "attrs": {}}')::jsonb -> 0 INTO credentials;\r\n\r\n    -- TODO: check user's permissions for reclada object access?\r\n    object_id := data->>'objectId';\r\n    SELECT reclada_object.list(format(\r\n        '{"class": "File", "attrs": {}, "id": "%s"}',\r\n        object_id\r\n    )::jsonb) -> 0 INTO object_data;\r\n\r\n    SELECT payload\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n            's3_get_presigned_url_dev1',\r\n            'eu-west-1'\r\n            ),\r\n        format('{\r\n            "type": "get",\r\n            "uri": "%s",\r\n            "expiration": 3600}',\r\n            object_data->'attrs'->>'uri'\r\n            )::jsonb)\r\n    INTO result;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.storage_generate_presigned_post ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_post(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    bucket_name  varchar;\r\n    credentials  jsonb;\r\n    file_type    varchar;\r\n    object       jsonb;\r\n    object_id    uuid;\r\n    object_name  varchar;\r\n    object_path  varchar;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\n    uri          varchar;\r\n    url          varchar;\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF(NOT(reclada_user.is_allowed(user_info, 'generate presigned post', '{}'))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    SELECT reclada_object.list('{"class": "S3Config", "attrs": {}}')::jsonb -> 0 INTO credentials;\r\n\r\n    object_name := data->>'objectName';\r\n    file_type := data->>'fileType';\r\n    bucket_name := credentials->'attrs'->>'bucketName';\r\n    SELECT uuid_generate_v4() INTO object_id;\r\n    object_path := object_id;\r\n    uri := 's3://' || bucket_name || '/' || object_path;\r\n\r\n    -- TODO: remove checksum from required attrs for File class?\r\n    SELECT reclada_object.create(format(\r\n        '{"class": "File", "attrs": {"name": "%s", "mimeType": "%s", "uri": "%s", "checksum": "tempChecksum"}}',\r\n        object_name,\r\n        file_type,\r\n        uri\r\n    )::jsonb)->0 INTO object;\r\n\r\n    --data := data || format('{"objectPath": "%s"}', object_path)::jsonb;\r\n    --SELECT reclada_storage.s3_generate_presigned_post(data, credentials)::jsonb INTO url;\r\n    SELECT payload::jsonb\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n            's3_get_presigned_url_dev1',\r\n            'eu-west-1'\r\n            ),\r\n        format('{\r\n            "type": "post",\r\n            "bucketName": "%s",\r\n            "fileName": "%s",\r\n            "fileType": "%s",\r\n            "fileSize": "%s",\r\n            "expiration": 3600}',\r\n            bucket_name,\r\n            object_name,\r\n            file_type,\r\n            data->>'fileSize'\r\n            )::jsonb)\r\n    INTO url;\r\n\r\n    result = format(\r\n        '{"object": %s, "uploadUrl": %s}',\r\n        object,\r\n        url\r\n    )::jsonb;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_condition_array ;\nCREATE OR REPLACE FUNCTION reclada_object.get_condition_array(data jsonb, key_path text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\n    SELECT\r\n    CONCAT(\r\n        key_path,\r\n        ' ', data->>'operator', ' ',\r\n        format(E'\\'%s\\'::jsonb', data->'object'#>>'{}'))\r\n$function$\n;\n	2021-09-22 14:51:22.336077+00
12	11	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 11 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ndrop VIEW if EXISTS reclada.v_revision;\ndrop VIEW if EXISTS reclada.v_class;\ndrop VIEW if EXISTS v_active_object;\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_class.sql'\ni 'view/reclada.v_revision.sql'\n\ni 'function/api.reclada_object_create.sql'\ni 'function/api.reclada_object_list.sql'\ni 'function/api.reclada_object_update.sql'\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/reclada_notification.send_object_notification.sql'\ni 'function/reclada_object.cast_jsonb_to_postgres.sql'\ni 'function/reclada_object.create_subclass.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.get_query_condition.sql'\ni 'function/reclada_object.list_add.sql'\ni 'function/reclada_object.list_drop.sql'\ni 'function/reclada_object.list_related.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_revision.create.sql'\ni 'function/reclada.datasource_insert_trigger_fnc.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\ndrop VIEW if EXISTS reclada.v_revision;\ndrop VIEW if EXISTS reclada.v_class;\ndrop VIEW if EXISTS v_active_object;\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n WITH t AS (\n         SELECT obj.id,\n            obj.obj_id,\n            obj.class,\n            r.num,\n            NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n            obj.attributes AS attrs,\n            obj.status,\n            obj.created_time,\n            obj.created_by\n           FROM object obj\n             LEFT JOIN ( SELECT (r_1.attributes -> 'num'::text)::bigint AS num,\n                    r_1.obj_id\n                   FROM object r_1\n                  WHERE r_1.class = 'revision'::text) r ON r.obj_id = NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid\n        )\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.num AS revision_num,\n    os.caption AS status_caption,\n    t.revision,\n    t.created_time,\n    t.attrs,\n    format('{\r\n                    "id": "%s",\r\n                    "class": "%s",\r\n                    "revision": %s, \r\n                    "status": "%s",\r\n                    "attrs": %s\r\n                }'::text, t.obj_id, t.class, COALESCE(('"'::text || t.revision::text) || '"'::text, 'null'::text), os.caption, t.attrs)::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status\n   FROM t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.attrs,\n    t.data\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class = 'revision'::text;\nDROP function IF EXISTS api.reclada_object_create ;\nCREATE OR REPLACE FUNCTION api.reclada_object_create(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    data_jsonb       jsonb;\r\n    class            jsonb;\r\n    user_info        jsonb;\r\n    attrs            jsonb;\r\n    data_to_create   jsonb = '[]'::jsonb;\r\n    result           jsonb;\r\n\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data) != 'array') THEN\r\n        data := '[]'::jsonb || data;\r\n    END IF;\r\n\r\n    FOR data_jsonb IN SELECT jsonb_array_elements(data) LOOP\r\n\r\n        class := data_jsonb->'class';\r\n        IF (class IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n\r\n        SELECT reclada_user.auth_by_token(data_jsonb->>'accessToken') INTO user_info;\r\n        data_jsonb := data_jsonb - 'accessToken';\r\n\r\n        IF (NOT(reclada_user.is_allowed(user_info, 'create', class))) THEN\r\n            RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'create', class;\r\n        END IF;\r\n\r\n        attrs := data_jsonb->'attrs';\r\n        IF (attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attrs';\r\n        END IF;\r\n\r\n        data_to_create := data_to_create || data_jsonb;\r\n    END LOOP;\r\n\r\n    SELECT reclada_object.create(data_to_create, user_info) INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_list ;\nCREATE OR REPLACE FUNCTION api.reclada_object_list(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               jsonb;\r\n    user_info           jsonb;\r\n    result              jsonb;\r\n\r\nBEGIN\r\n\r\n    class := data->'class';\r\n    IF(class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'list', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.list(data, true) INTO result;\r\n\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_update ;\nCREATE OR REPLACE FUNCTION api.reclada_object_update(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class         jsonb;\r\n    objid         uuid;\r\n    attrs         jsonb;\r\n    user_info     jsonb;\r\n    result        jsonb;\r\n\r\nBEGIN\r\n\r\n    class := data->'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    objid := data->>'id';\r\n    IF (objid IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no id';\r\n    END IF;\r\n\r\n    attrs := data->'attrs';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object must have attrs';\r\n    END IF;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'update', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'update', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.update(data, user_info) INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.storage_generate_presigned_post ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_post(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    bucket_name  varchar;\r\n    file_type    varchar;\r\n    object       jsonb;\r\n    object_id    uuid;\r\n    object_name  varchar;\r\n    object_path  varchar;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\n    uri          varchar;\r\n    url          varchar;\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF(NOT(reclada_user.is_allowed(user_info, 'generate presigned post', '{}'))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    object_name := data->>'objectName';\r\n    file_type := data->>'fileType';\r\n    bucket_name := data->>'bucketName';\r\n    SELECT uuid_generate_v4() INTO object_id;\r\n    object_path := object_id;\r\n    uri := 's3://' || bucket_name || '/' || object_path;\r\n\r\n    -- TODO: remove checksum from required attrs for File class?\r\n    SELECT reclada_object.create(format(\r\n        '{"class": "File", "attrs": {"name": "%s", "mimeType": "%s", "uri": "%s", "checksum": "tempChecksum"}}',\r\n        object_name,\r\n        file_type,\r\n        uri\r\n    )::jsonb)->0 INTO object;\r\n\r\n    SELECT payload::jsonb\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n            's3_get_presigned_url_test',\r\n            'eu-west-1'\r\n            ),\r\n        format('{\r\n            "type": "post",\r\n            "bucketName": "%s",\r\n            "fileName": "%s",\r\n            "fileType": "%s",\r\n            "fileSize": "%s",\r\n            "expiration": 3600}',\r\n            bucket_name,\r\n            object_name,\r\n            file_type,\r\n            data->>'fileSize'\r\n            )::jsonb)\r\n    INTO url;\r\n\r\n    result = format(\r\n        '{"object": %s, "uploadUrl": %s}',\r\n        object,\r\n        url\r\n    )::jsonb;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.storage_generate_presigned_get ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_get(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    object_data  jsonb;\r\n    object_id    uuid;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF(NOT(reclada_user.is_allowed(user_info, 'generate presigned post', '{}'))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    -- TODO: check user's permissions for reclada object access?\r\n    object_id := data->>'objectId';\r\n    SELECT reclada_object.list(format(\r\n        '{"class": "File", "attrs": {}, "id": "%s"}',\r\n        object_id\r\n    )::jsonb) -> 0 INTO object_data;\r\n\r\n    SELECT payload\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n            's3_get_presigned_url_test',\r\n            'eu-west-1'\r\n            ),\r\n        format('{\r\n            "type": "get",\r\n            "uri": "%s",\r\n            "expiration": 3600}',\r\n            object_data->'attrs'->>'uri'\r\n            )::jsonb)\r\n    INTO result;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_notification.send_object_notification ;\nCREATE OR REPLACE FUNCTION reclada_notification.send_object_notification(event character varying, object_data jsonb)\n RETURNS void\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    data            jsonb;\r\n    message         jsonb;\r\n    msg             jsonb;\r\n    object_class    varchar;\r\n    attrs           jsonb;\r\n    query           text;\r\n\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(object_data) != 'array') THEN\r\n        object_data := '[]'::jsonb || object_data;\r\n    END IF;\r\n\r\n    FOR data IN SELECT jsonb_array_elements(object_data) LOOP\r\n        object_class := data ->> 'class';\r\n\r\n        if event is null or object_class is null then\r\n            return;\r\n        end if;\r\n        \r\n        SELECT v.data \r\n            FROM reclada.v_active_object v\r\n                WHERE v.class = 'Message'\r\n                    AND v.attrs->>'event' = event\r\n                    AND v.attrs->>'class' = object_class\r\n        INTO message;\r\n\r\n        IF message IS NULL THEN\r\n            RETURN;\r\n        END IF;\r\n\r\n        query := format(E'select to_json(x) from jsonb_to_record($1) as x(%s)',\r\n            (select string_agg(s::text || ' jsonb', ',') from jsonb_array_elements(message -> 'attrs' -> 'attrs') s));\r\n        execute query into attrs using data -> 'attrs';\r\n\r\n        msg := jsonb_build_object(\r\n            'objectId', data -> 'id',\r\n            'class', object_class,\r\n            'event', event,\r\n            'attrs', attrs\r\n        );\r\n\r\n        perform reclada_notification.send(message #>> '{attrs, channelName}', msg);\r\n\r\n    END LOOP;\r\nEND\r\n$function$\n;\nDROP function IF EXISTS reclada_object.cast_jsonb_to_postgres ;\nCREATE OR REPLACE FUNCTION reclada_object.cast_jsonb_to_postgres(key_path text, type text, type_of_array text DEFAULT 'text'::text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\nSELECT\r\n        CASE\r\n            WHEN type = 'string' THEN\r\n                format(E'(%s#>>\\'{}\\')::text', key_path)\r\n            WHEN type = 'number' THEN\r\n                format(E'(%s)::numeric', key_path)\r\n            WHEN type = 'boolean' THEN\r\n                format(E'(%s)::boolean', key_path)\r\n            WHEN type = 'array' THEN\r\n                format(\r\n                    E'ARRAY(SELECT jsonb_array_elements_text(%s)::%s)',\r\n                    key_path,\r\n                     CASE\r\n                        WHEN type_of_array = 'string' THEN 'text'\r\n                        WHEN type_of_array = 'number' THEN 'numeric'\r\n                        WHEN type_of_array = 'boolean' THEN 'boolean'\r\n                     END\r\n                    )\r\n        END\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    attrs := data->'attrs';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attrs';\r\n    END IF;\r\n\r\n    SELECT reclada_object.get_schema(class) INTO class_schema;\r\n    IF (class_schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', class;\r\n    END IF;\r\n\r\n    class_schema := class_schema->'attrs'->'schema';\r\n\r\n    PERFORM reclada_object.create(format('{\r\n        "class": "jsonschema",\r\n        "attrs": {\r\n            "forClass": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n                }\r\n            }\r\n        }',\r\n        attrs->>'newClass',\r\n        (class_schema->'properties') || (attrs->'properties'),\r\n        (SELECT jsonb_agg(el) FROM (SELECT DISTINCT pg_catalog.jsonb_array_elements((class_schema -> 'required') || (attrs -> 'required')) el) arr)\r\n    )::jsonb);\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch     uuid;\r\n    data       jsonb;\r\n    class      text;\r\n    attrs      jsonb;\r\n    schema     jsonb;\r\n    res        jsonb;\r\n\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision and others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n    create temp table IF NOT EXISTS tmp(id uuid)\r\n    ON COMMIT drop;\r\n    delete from tmp;\r\n    FOR data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n\r\n        class := data->>'class';\r\n        IF (class IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n\r\n        attrs := data->'attrs';\r\n        IF (attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attrs';\r\n        END IF;\r\n\r\n        SELECT reclada_object.get_schema(class) \r\n            INTO schema;\r\n\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', class;\r\n        END IF;\r\n\r\n        IF (NOT(validate_json_schema(schema->'attrs'->'schema', attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: %', attrs;\r\n        END IF;\r\n\r\n        with inserted as \r\n        (\r\n            INSERT INTO reclada.object(class,attributes)\r\n                select class, attrs\r\n                    RETURNING obj_id\r\n        ) \r\n        insert into tmp(id)\r\n            select obj_id \r\n                from inserted;\r\n\r\n    END LOOP;\r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    select o.data \r\n                        from reclada.v_active_object o\r\n                        join tmp t\r\n                            on t.id = o.obj_id\r\n                )\r\n            )::jsonb; \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            res\r\n        );\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_query_condition ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition(data jsonb, key_path text)\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    key          text;\r\n    operator     text;\r\n    value        text;\r\n    res          text;\r\n\r\nBEGIN\r\n    IF (data IS NULL OR data = 'null'::jsonb) THEN\r\n        RAISE EXCEPTION 'There is no condition';\r\n    END IF;\r\n\r\n    IF (jsonb_typeof(data) = 'object') THEN\r\n\r\n        IF (data->'object' IS NULL OR data->'object' = ('null'::jsonb)) THEN\r\n            RAISE EXCEPTION 'There is no object field';\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'object') = 'object') THEN\r\n            RAISE EXCEPTION 'The input_jsonb->''object'' can not contain jsonb object';\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'operator') != 'string' AND data->'operator' IS NOT NULL) THEN\r\n            RAISE EXCEPTION 'The input_jsonb->''operator'' must contain string';\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'object') = 'array') THEN\r\n            res := reclada_object.get_condition_array(data, key_path);\r\n        ELSE\r\n            key := reclada_object.cast_jsonb_to_postgres(key_path, jsonb_typeof(data->'object'));\r\n            operator :=  data->>'operator';\r\n            value := reclada_object.jsonb_to_text(data->'object');\r\n            res := key || ' ' || operator || ' ' || value;\r\n        END IF;\r\n    ELSE\r\n        key := reclada_object.cast_jsonb_to_postgres(key_path, jsonb_typeof(data));\r\n        operator := '=';\r\n        value := reclada_object.jsonb_to_text(data);\r\n        res := key || ' ' || operator || ' ' || value;\r\n    END IF;\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list_add ;\nCREATE OR REPLACE FUNCTION reclada_object.list_add(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class          text;\r\n    objid          uuid;\r\n    obj            jsonb;\r\n    values_to_add  jsonb;\r\n    field          text;\r\n    field_value    jsonb;\r\n    json_path      text[];\r\n    new_obj        jsonb;\r\n    res            jsonb;\r\n\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    objid := (data->>'id')::uuid;\r\n    IF (objid IS NULL) THEN\r\n        RAISE EXCEPTION 'There is no id';\r\n    END IF;\r\n\r\n    SELECT v.data\r\n\tFROM reclada.v_active_object v\r\n\tWHERE v.obj_id = objid\r\n\tINTO obj;\r\n\r\n    IF (obj IS NULL) THEN\r\n        RAISE EXCEPTION 'There is no object with such id';\r\n    END IF;\r\n\r\n    values_to_add := data->'value';\r\n    IF (values_to_add IS NULL OR values_to_add = 'null'::jsonb) THEN\r\n        RAISE EXCEPTION 'The value should not be null';\r\n    END IF;\r\n\r\n    IF (jsonb_typeof(values_to_add) != 'array') THEN\r\n        values_to_add := format('[%s]', values_to_add)::jsonb;\r\n    END IF;\r\n\r\n    field := data->>'field';\r\n    IF (field IS NULL) THEN\r\n        RAISE EXCEPTION 'There is no field';\r\n    END IF;\r\n    json_path := format('{attrs, %s}', field);\r\n    field_value := obj#>json_path;\r\n\r\n    IF ((field_value = 'null'::jsonb) OR (field_value IS NULL)) THEN\r\n        SELECT jsonb_set(obj, json_path, values_to_add)\r\n        INTO new_obj;\r\n    ELSE\r\n        SELECT jsonb_set(obj, json_path, field_value || values_to_add)\r\n        INTO new_obj;\r\n    END IF;\r\n\r\n    SELECT reclada_object.update(new_obj) INTO res;\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list_drop ;\nCREATE OR REPLACE FUNCTION reclada_object.list_drop(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    objid           uuid;\r\n    obj             jsonb;\r\n    values_to_drop  jsonb;\r\n    field           text;\r\n    field_value     jsonb;\r\n    json_path       text[];\r\n    new_value       jsonb;\r\n    new_obj         jsonb;\r\n    res             jsonb;\r\n\r\nBEGIN\r\n\r\n\tclass := data->>'class';\r\n\tIF (class IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The reclada object class is not specified';\r\n\tEND IF;\r\n\r\n\tobjid := (data->>'id')::uuid;\r\n\tIF (objid IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The is no id';\r\n\tEND IF;\r\n\r\n    SELECT v.data\r\n    FROM reclada.v_active_object v\r\n    WHERE v.obj_id = objid\r\n    INTO obj;\r\n\r\n\tIF (obj IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The is no object with such id';\r\n\tEND IF;\r\n\r\n\tvalues_to_drop := data->'value';\r\n\tIF (values_to_drop IS NULL OR values_to_drop = 'null'::jsonb) THEN\r\n\t\tRAISE EXCEPTION 'The value should not be null';\r\n\tEND IF;\r\n\r\n\tIF (jsonb_typeof(values_to_drop) != 'array') THEN\r\n\t\tvalues_to_drop := format('[%s]', values_to_drop)::jsonb;\r\n\tEND IF;\r\n\r\n\tfield := data->>'field';\r\n\tIF (field IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'There is no field';\r\n\tEND IF;\r\n\tjson_path := format('{attrs, %s}', field);\r\n\tfield_value := obj#>json_path;\r\n\tIF (field_value IS NULL OR field_value = 'null'::jsonb) THEN\r\n\t\tRAISE EXCEPTION 'The object does not have this field';\r\n\tEND IF;\r\n\r\n\tSELECT jsonb_agg(elems)\r\n\tFROM\r\n\t\tjsonb_array_elements(field_value) elems\r\n\tWHERE\r\n\t\telems NOT IN (\r\n\t\t\tSELECT jsonb_array_elements(values_to_drop))\r\n\tINTO new_value;\r\n\r\n\tSELECT jsonb_set(obj, json_path, coalesce(new_value, '[]'::jsonb))\r\n\tINTO new_obj;\r\n\r\n\tSELECT reclada_object.update(new_obj) INTO res;\r\n\tRETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list_related ;\nCREATE OR REPLACE FUNCTION reclada_object.list_related(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class          text;\r\n    objid          uuid;\r\n    field          text;\r\n    related_class  text;\r\n    obj            jsonb;\r\n    list_of_ids    jsonb;\r\n    cond           jsonb = '{}'::jsonb;\r\n    order_by       jsonb;\r\n    limit_         text;\r\n    offset_        text;\r\n    res            jsonb;\r\n\r\nBEGIN\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    objid := (data->>'id')::uuid;\r\n    IF (objid IS NULL) THEN\r\n        RAISE EXCEPTION 'The object id is not specified';\r\n    END IF;\r\n\r\n    field := data->>'field';\r\n    IF (field IS NULL) THEN\r\n        RAISE EXCEPTION 'The object field is not specified';\r\n    END IF;\r\n\r\n    related_class := data->>'relatedClass';\r\n    IF (related_class IS NULL) THEN\r\n        RAISE EXCEPTION 'The related class is not specified';\r\n    END IF;\r\n\r\n\tSELECT v.data\r\n\tFROM reclada.v_active_object v\r\n\tWHERE v.obj_id = objid\r\n\tINTO obj;\r\n\r\n    IF (obj IS NULL) THEN\r\n        RAISE EXCEPTION 'There is no object with such id';\r\n    END IF;\r\n\r\n    list_of_ids := obj#>(format('{attrs, %s}', field)::text[]);\r\n    IF (list_of_ids IS NULL) THEN\r\n        RAISE EXCEPTION 'The object does not have this field';\r\n    END IF;\r\n\r\n    order_by := data->'orderBy';\r\n    IF (order_by IS NOT NULL) THEN\r\n        cond := cond || (format('{"orderBy": %s}', order_by)::jsonb);\r\n    END IF;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NOT NULL) THEN\r\n        cond := cond || (format('{"limit": "%s"}', limit_)::jsonb);\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NOT NULL) THEN\r\n        cond := cond || (format('{"offset": "%s"}', offset_)::jsonb);\r\n    END IF;\r\n\r\n    SELECT reclada_object.list(format(\r\n        '{"class": "%s", "attrs": {}, "id": {"operator": "<@", "object": %s}}',\r\n        related_class,\r\n        list_of_ids\r\n        )::jsonb || cond,\r\n        true)\r\n    INTO res;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, with_number boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    attrs := data->'attrs' || '{}'::jsonb;\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "id", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    IF (jsonb_typeof(order_by_jsonb) != 'array') THEN\r\n    \t\torder_by_jsonb := format('[%s]', order_by_jsonb);\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n    FROM jsonb_array_elements(order_by_jsonb) T\r\n    INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n    IF ((limit_ ~ '(\\D+)') AND (limit_ != 'ALL')) THEN\r\n    \t\tRAISE EXCEPTION 'The limit must be an integer number or "ALL"';\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    IF (offset_ ~ '(\\D+)') THEN\r\n    \t\tRAISE EXCEPTION 'The offset must be an integer number';\r\n    END IF;\r\n\r\n    SELECT\r\n        string_agg(\r\n            format(\r\n                E'(%s)',\r\n                condition\r\n            ),\r\n            ' AND '\r\n        )\r\n        FROM (\r\n            SELECT\r\n                -- ((('"'||class||'"')::jsonb#>>'{}')::text = 'Job')\r\n                --reclada_object.get_query_condition(class, E'data->''class''') AS condition\r\n                --'class = data->>''class''' AS condition\r\n                format('obj.class = ''%s''', class) AS condition\r\n            UNION\r\n            SELECT  CASE\r\n                        WHEN jsonb_typeof(data->'id') = 'array' THEN\r\n                        (\r\n                            SELECT string_agg\r\n                                (\r\n                                    format(\r\n                                        E'(%s)',\r\n                                        reclada_object.get_query_condition(cond, E'data->''id''')\r\n                                    ),\r\n                                    ' AND '\r\n                                )\r\n                                FROM jsonb_array_elements(data->'id') AS cond\r\n                        )\r\n                        ELSE reclada_object.get_query_condition(data->'id', E'data->''id''')\r\n                    END AS condition\r\n                WHERE coalesce(data->'id','null'::jsonb) != 'null'::jsonb\r\n            -- UNION\r\n            -- SELECT 'obj.data->>''status''=''active'''-- TODO: change working with revision\r\n            -- UNION SELECT\r\n            --     CASE WHEN data->'revision' IS NULL THEN\r\n            --         E'(data->>''revision''):: numeric = (SELECT max((objrev.data -> ''revision'')::numeric)\r\n            --         FROM reclada.v_object objrev WHERE\r\n            --         objrev.data -> ''id'' = obj.data -> ''id'')'\r\n            --     WHEN jsonb_typeof(data->'revision') = 'array' THEN\r\n            --         (SELECT string_agg(\r\n            --             format(\r\n            --                 E'(%s)',\r\n            --                 reclada_object.get_query_condition(cond, E'data->''revision''')\r\n            --             ),\r\n            --             ' AND '\r\n            --         )\r\n            --         FROM jsonb_array_elements(data->'revision') AS cond)\r\n            --     ELSE reclada_object.get_query_condition(data->'revision', E'data->''revision''') END AS condition\r\n            UNION\r\n            SELECT\r\n                CASE\r\n                    WHEN jsonb_typeof(value) = 'array'\r\n                        THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format\r\n                                        (\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, format(E'data->''attrs''->%L', key))\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(value) AS cond\r\n                            )\r\n                    ELSE reclada_object.get_query_condition(value, format(E'data->''attrs''->%L', key))\r\n                END AS condition\r\n            FROM jsonb_each(attrs)\r\n            WHERE data->'attrs' != ('{}'::jsonb)\r\n        ) conds\r\n    INTO query_conditions;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             FROM reclada.v_object obj\r\n    --             WHERE ' || query_conditions ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n    query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n    raise notice 'query: %', query;\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    IF with_number THEN\r\n\r\n        EXECUTE E'SELECT count(1)\r\n        '|| query\r\n        INTO number_of_objects;\r\n\r\n        res := jsonb_build_object(\r\n        'number', number_of_objects,\r\n        'objects', objects);\r\n    ELSE\r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_class         text;\r\n    v_obj_id        uuid;\r\n    v_attrs         jsonb;\r\n    schema        jsonb;\r\n    old_obj       jsonb;\r\n    branch        uuid;\r\n    revid         uuid;\r\n\r\nBEGIN\r\n\r\n    v_class := data->>'class';\r\n    IF (v_class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    v_obj_id := data->>'id';\r\n    IF (v_obj_id IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no id';\r\n    END IF;\r\n\r\n    v_attrs := data->'attrs';\r\n    IF (v_attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attrs';\r\n    END IF;\r\n\r\n    SELECT reclada_object.get_schema(v_class) \r\n        INTO schema;\r\n\r\n    IF (schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', v_class;\r\n    END IF;\r\n\r\n    IF (NOT(validate_json_schema(schema->'attrs'->'schema', v_attrs))) THEN\r\n        RAISE EXCEPTION 'JSON invalid: %', v_attrs;\r\n    END IF;\r\n\r\n    SELECT \tv.data\r\n        FROM reclada.v_active_object v\r\n\t        WHERE v.obj_id = v_obj_id\r\n\t    INTO old_obj;\r\n\r\n    IF (old_obj IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object, no such id';\r\n    END IF;\r\n\r\n    branch := data->'branch';\r\n    SELECT reclada_revision.create(user_info->>'sub', branch, v_obj_id) \r\n        INTO revid;\r\n    \r\n    with t as \r\n    (\r\n        update reclada.object o\r\n            set status = reclada_object.get_archive_status_obj_id()\r\n                where o.obj_id = v_obj_id\r\n                    and status != reclada_object.get_archive_status_obj_id()\r\n                        RETURNING id\r\n    )\r\n    INSERT INTO reclada.object( obj_id,\r\n                                class,\r\n                                status,\r\n                                attributes\r\n                              )\r\n        select  v.obj_id,\r\n                v_class,\r\n                reclada_object.get_active_status_obj_id(),--status \r\n                v_attrs || format('{"revision":"%s"}',revid)::jsonb\r\n            FROM reclada.v_object v\r\n            JOIN t \r\n                on t.id = v.id\r\n\t            WHERE v.obj_id = v_obj_id;\r\n                    \r\n    select v.data \r\n        FROM reclada.v_active_object v\r\n            WHERE v.obj_id = v_obj_id\r\n        into data;\r\n    PERFORM reclada_notification.send_object_notification('update', data);\r\n    RETURN data;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_revision.create ;\nCREATE OR REPLACE FUNCTION reclada_revision."create"(userid character varying, branch uuid, obj uuid)\n RETURNS uuid\n LANGUAGE sql\nAS $function$\r\n    INSERT INTO reclada.object\r\n        (\r\n            class,\r\n            attributes\r\n        )\r\n               \r\n        VALUES\r\n        (\r\n            'revision'               ,-- class,\r\n            format                    -- attrs\r\n            (                         \r\n                '{\r\n                    "num": %s,\r\n                    "user": "%s",\r\n                    "dateTime": "%s",\r\n                    "branch": "%s"\r\n                }',\r\n                (\r\n                    select count(*)\r\n                        from reclada.object o\r\n                            where o.obj_id = obj\r\n                ),\r\n                userid,\r\n                now(),\r\n                branch\r\n            )::jsonb\r\n        ) RETURNING (obj_id)::uuid;\r\n    --nextval('reclada.reclada_revisions'),\r\n$function$\n;\nDROP TRIGGER IF EXISTS datasource_insert_trigger ON reclada.object;\nDROP function IF EXISTS reclada.datasource_insert_trigger_fnc ;\nCREATE OR REPLACE FUNCTION reclada.datasource_insert_trigger_fnc()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    obj_id         uuid;\r\n    dataset       jsonb;\r\n    uri           text;\r\n\r\nBEGIN\r\n    IF (NEW.class = 'DataSource') OR (NEW.class = 'File') THEN\r\n\r\n        obj_id := NEW.obj_id;\r\n\r\n        SELECT v.data\r\n        FROM reclada.v_active_object v\r\n\t    WHERE v.attrs->>'name' = 'defaultDataSet'\r\n\t    INTO dataset;\r\n\r\n        dataset := jsonb_set(dataset, '{attrs, dataSources}', dataset->'attrs'->'dataSources' || format('["%s"]', obj_id)::jsonb);\r\n\r\n        PERFORM reclada_object.update(dataset);\r\n\r\n        uri := NEW.attributes->>'uri';\r\n\r\n        PERFORM reclada_object.create(\r\n            format('{\r\n                "class": "Job",\r\n                "attrs": {\r\n                    "task": "c94bff30-15fa-427f-9954-d5c3c151e652",\r\n                    "status": "new",\r\n                    "type": "K8S",\r\n                    "command": "./run_pipeline.sh",\r\n                    "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\r\n                    }\r\n                }', uri, obj_id)::jsonb);\r\n\r\n    END IF;\r\n\r\nRETURN NEW;\r\nEND;\r\n$function$\n;\nCREATE TRIGGER datasource_insert_trigger\n  BEFORE INSERT\n  ON reclada.object FOR EACH ROW\n  EXECUTE PROCEDURE reclada.datasource_insert_trigger_fnc();	2021-09-22 14:51:25.925445+00
13	12	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 12 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\n\ni 'function/reclada_revision.create.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS reclada_revision.create ;\nCREATE OR REPLACE FUNCTION reclada_revision."create"(userid character varying, branch uuid, obj uuid)\n RETURNS uuid\n LANGUAGE sql\nAS $function$\r\n    INSERT INTO reclada.object\r\n        (\r\n            class,\r\n            attributes\r\n        )\r\n               \r\n        VALUES\r\n        (\r\n            'revision'               ,-- class,\r\n            format                    -- attributes\r\n            (                         \r\n                '{\r\n                    "num": %s,\r\n                    "user": "%s",\r\n                    "dateTime": "%s",\r\n                    "branch": "%s"\r\n                }',\r\n                (\r\n                    select count(*)\r\n                        from reclada.object o\r\n                            where o.obj_id = obj\r\n                ),\r\n                userid,\r\n                now(),\r\n                branch\r\n            )::jsonb\r\n        ) RETURNING (obj_id)::uuid;\r\n    --nextval('reclada.reclada_revisions'),\r\n$function$\n;	2021-09-22 14:51:33.946132+00
14	13	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 13 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ndrop VIEW if EXISTS reclada.v_class;\ndrop VIEW if EXISTS reclada.v_revision ;\ndrop VIEW if EXISTS reclada.v_active_object;\n\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_revision.sql'\ni 'view/reclada.v_class.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\ndrop VIEW if EXISTS reclada.v_class;\ndrop VIEW if EXISTS reclada.v_revision;\ndrop VIEW if EXISTS reclada.v_active_object;\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n WITH t AS (\n         SELECT obj.id,\n            obj.obj_id,\n            obj.class,\n            r.num,\n            NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n            obj.attributes AS attrs,\n            obj.status,\n            obj.created_time,\n            obj.created_by\n           FROM object obj\n             LEFT JOIN ( SELECT (r_1.attributes -> 'num'::text)::bigint AS num,\n                    r_1.obj_id\n                   FROM object r_1\n                  WHERE r_1.class = 'revision'::text) r ON r.obj_id = NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid\n        )\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.num AS revision_num,\n    os.caption AS status_caption,\n    t.revision,\n    t.created_time,\n    t.attrs,\n    format('{\r\n                    "id": "%s",\r\n                    "class": "%s",\r\n                    "revision": %s, \r\n                    "status": "%s",\r\n                    "attributes": %s\r\n                }'::text, t.obj_id, t.class, COALESCE(('"'::text || t.revision::text) || '"'::text, 'null'::text), os.caption, t.attrs)::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status\n   FROM t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.attrs,\n    t.data\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class = 'revision'::text;\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class = 'jsonschema'::text;	2021-09-22 14:51:37.1906+00
29	28	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 28 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.list.sql'\n\n\ni 'function/api.auth_get_login_url copy.sql'\ni 'function/api.auth_get_login_url.sql'\ni 'function/api.hello_world.sql'\ni 'function/api.reclada_object_create.sql'\ni 'function/api.reclada_object_delete.sql'\ni 'function/api.reclada_object_list.sql'\ni 'function/api.reclada_object_list_add.sql'\ni 'function/api.reclada_object_list_drop.sql'\ni 'function/api.reclada_object_list_related.sql'\ni 'function/api.reclada_object_update.sql'\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/dev.downgrade_version.sql'\ni 'function/dev.reg_notice.sql'\ni 'function/reclada.datasource_insert_trigger_fnc.sql'\ni 'function/reclada.load_staging.sql'\ni 'function/reclada.raise_exception.sql'\ni 'function/reclada.raise_notice.sql'\ni 'function/reclada.try_cast_int.sql'\ni 'function/reclada.try_cast_uuid.sql'\ni 'function/reclada_notification.listen.sql'\ni 'function/reclada_notification.send.sql'\ni 'function/reclada_notification.send_object_notification.sql'\ni 'function/reclada_object.cast_jsonb_to_postgres.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.create_subclass.sql'\ni 'function/reclada_object.delete.sql'\ni 'function/reclada_object.get_archive_status_obj_id.sql'\ni 'function/reclada_object.get_condition_array.sql'\ni 'function/reclada_object.get_query_condition.sql'\ni 'function/reclada_object.get_schema.sql'\ni 'function/reclada_object.jsonb_to_text.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.list_add.sql'\ni 'function/reclada_object.list_drop.sql'\ni 'function/reclada_object.list_related.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_revision.create.sql'\ni 'function/reclada_user.auth_by_token.sql'\ni 'function/reclada_user.disable_auth.sql'\ni 'function/reclada_user.is_allowed.sql'\ni 'function/reclada_user.setup_keycloak.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-22 14:52:44.849474+00
15	14	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 14 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.get_query_condition.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS reclada_object.get_query_condition ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition(data jsonb, key_path text)\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    key          text;\r\n    operator     text;\r\n    value        text;\r\n    res          text;\r\n\r\nBEGIN\r\n    IF (data IS NULL OR data = 'null'::jsonb) THEN\r\n        RAISE EXCEPTION 'There is no condition';\r\n    END IF;\r\n\r\n    IF (jsonb_typeof(data) = 'object') THEN\r\n\r\n        IF (data->'object' IS NULL OR data->'object' = ('null'::jsonb)) THEN\r\n            RAISE EXCEPTION 'There is no object field';\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'object') = 'object') THEN\r\n            RAISE EXCEPTION 'The input_jsonb->''object'' can not contain jsonb object';\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'operator') != 'string' AND data->'operator' IS NOT NULL) THEN\r\n            RAISE EXCEPTION 'The input_jsonb->''operator'' must contain string';\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'object') = 'array') THEN\r\n            res := reclada_object.get_condition_array(data, key_path);\r\n        ELSE\r\n            key := reclada_object.cast_jsonb_to_postgres(key_path, jsonb_typeof(data->'object'));\r\n            operator :=  data->>'operator';\r\n            value := reclada_object.jsonb_to_text(data->'object');\r\n            res := key || ' ' || operator || ' ' || value;\r\n        END IF;\r\n    ELSE\r\n        key := reclada_object.cast_jsonb_to_postgres(key_path, jsonb_typeof(data));\r\n        operator := '=';\r\n        value := reclada_object.jsonb_to_text(data);\r\n        res := key || ' ' || operator || ' ' || value;\r\n    END IF;\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;	2021-09-22 14:51:41.568627+00
16	15	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 15 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.list.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, with_number boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "id", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    IF (jsonb_typeof(order_by_jsonb) != 'array') THEN\r\n    \t\torder_by_jsonb := format('[%s]', order_by_jsonb);\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n    FROM jsonb_array_elements(order_by_jsonb) T\r\n    INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n    IF ((limit_ ~ '(\\D+)') AND (limit_ != 'ALL')) THEN\r\n    \t\tRAISE EXCEPTION 'The limit must be an integer number or "ALL"';\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    IF (offset_ ~ '(\\D+)') THEN\r\n    \t\tRAISE EXCEPTION 'The offset must be an integer number';\r\n    END IF;\r\n\r\n    SELECT\r\n        string_agg(\r\n            format(\r\n                E'(%s)',\r\n                condition\r\n            ),\r\n            ' AND '\r\n        )\r\n        FROM (\r\n            SELECT\r\n                -- ((('"'||class||'"')::jsonb#>>'{}')::text = 'Job')\r\n                --reclada_object.get_query_condition(class, E'data->''class''') AS condition\r\n                --'class = data->>''class''' AS condition\r\n                format('obj.class = ''%s''', class) AS condition\r\n            UNION\r\n            SELECT  CASE\r\n                        WHEN jsonb_typeof(data->'id') = 'array' THEN\r\n                        (\r\n                            SELECT string_agg\r\n                                (\r\n                                    format(\r\n                                        E'(%s)',\r\n                                        reclada_object.get_query_condition(cond, E'data->''id''')\r\n                                    ),\r\n                                    ' AND '\r\n                                )\r\n                                FROM jsonb_array_elements(data->'id') AS cond\r\n                        )\r\n                        ELSE reclada_object.get_query_condition(data->'id', E'data->''id''')\r\n                    END AS condition\r\n                WHERE coalesce(data->'id','null'::jsonb) != 'null'::jsonb\r\n            -- UNION\r\n            -- SELECT 'obj.data->>''status''=''active'''-- TODO: change working with revision\r\n            -- UNION SELECT\r\n            --     CASE WHEN data->'revision' IS NULL THEN\r\n            --         E'(data->>''revision''):: numeric = (SELECT max((objrev.data -> ''revision'')::numeric)\r\n            --         FROM reclada.v_object objrev WHERE\r\n            --         objrev.data -> ''id'' = obj.data -> ''id'')'\r\n            --     WHEN jsonb_typeof(data->'revision') = 'array' THEN\r\n            --         (SELECT string_agg(\r\n            --             format(\r\n            --                 E'(%s)',\r\n            --                 reclada_object.get_query_condition(cond, E'data->''revision''')\r\n            --             ),\r\n            --             ' AND '\r\n            --         )\r\n            --         FROM jsonb_array_elements(data->'revision') AS cond)\r\n            --     ELSE reclada_object.get_query_condition(data->'revision', E'data->''revision''') END AS condition\r\n            UNION\r\n            SELECT\r\n                CASE\r\n                    WHEN jsonb_typeof(value) = 'array'\r\n                        THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format\r\n                                        (\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, format(E'data->''attributes''->%L', key))\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(value) AS cond\r\n                            )\r\n                    ELSE reclada_object.get_query_condition(value, format(E'data->''attributes''->%L', key))\r\n                END AS condition\r\n            FROM jsonb_each(attrs)\r\n            WHERE data->'attributes' != ('{}'::jsonb)\r\n        ) conds\r\n    INTO query_conditions;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             FROM reclada.v_object obj\r\n    --             WHERE ' || query_conditions ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n    query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n    raise notice 'query: %', query;\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    IF with_number THEN\r\n\r\n        EXECUTE E'SELECT count(1)\r\n        '|| query\r\n        INTO number_of_objects;\r\n\r\n        res := jsonb_build_object(\r\n        'number', number_of_objects,\r\n        'objects', objects);\r\n    ELSE\r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;	2021-09-22 14:51:44.777124+00
17	16	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 16 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.create.sql'\n\n\nCREATE UNIQUE INDEX unique_guid_revision \n    ON reclada.object((attributes->>'revision'),obj_id);\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch     uuid;\r\n    data       jsonb;\r\n    class      text;\r\n    attrs      jsonb;\r\n    schema     jsonb;\r\n    res        jsonb;\r\n\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision and others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n    create temp table IF NOT EXISTS tmp(id uuid)\r\n    ON COMMIT drop;\r\n    delete from tmp;\r\n    FOR data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n\r\n        class := data->>'class';\r\n        IF (class IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n\r\n        attrs := data->'attributes';\r\n        IF (attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        SELECT reclada_object.get_schema(class) \r\n            INTO schema;\r\n\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', class;\r\n        END IF;\r\n\r\n        IF (NOT(validate_json_schema(schema->'attributes'->'schema', attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: %', attrs;\r\n        END IF;\r\n\r\n        with inserted as \r\n        (\r\n            INSERT INTO reclada.object(class,attributes)\r\n                select class, attrs\r\n                    RETURNING obj_id\r\n        ) \r\n        insert into tmp(id)\r\n            select obj_id \r\n                from inserted;\r\n\r\n    END LOOP;\r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    select o.data \r\n                        from reclada.v_active_object o\r\n                        join tmp t\r\n                            on t.id = o.obj_id\r\n                )\r\n            )::jsonb; \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            res\r\n        );\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\n\ndrop index unique_guid_revision;	2021-09-22 14:51:47.856222+00
18	17	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 17 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n\n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\nDROP TABLE IF EXISTS reclada.staging;\ni 'function/reclada.load_staging.sql'\ni 'view/reclada.staging.sql'\ni 'trigger/load_staging.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\nSELECT public.raise_notice('Downscript is not supported');	2021-09-22 14:51:51.217026+00
19	18	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 18 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "revision",\n        "properties": {\n            "num": {"type": "number"},\n            "user": {"type": "string"},\n            "branch": {"type": "string"},\n            "dateTime": {"type": "string"}  \n        },\n        "required": ["dateTime"]\n    }\n}'::jsonb);\n\n\nalter table reclada.object\n    add column class_guid uuid;\n\n\nupdate reclada.object o\n    set class_guid = c.obj_id\n        from v_class c\n            where c.for_class = o.class;\n\ndrop VIEW reclada.v_class;\ndrop VIEW reclada.v_revision;\ndrop VIEW reclada.v_active_object;\ndrop VIEW reclada.v_object;\ndrop VIEW reclada.v_object_status;\ndrop VIEW reclada.v_user;\nalter table reclada.object\n    drop column class;\n\nalter table reclada.object\n    add column class uuid;\n\nupdate reclada.object o\n    set class = c.class_guid\n        from reclada.object c\n            where c.id = o.id;\n\nalter table reclada.object\n    drop column class_guid;\n\ncreate index class_index \n    ON reclada.object(class);\n\ni 'function/public.try_cast_uuid.sql'\ni 'function/reclada_object.get_jsonschema_GUID.sql'\ni 'view/reclada.v_class_lite.sql'\ni 'function/reclada_object.get_GUID_for_class.sql'\n\ndelete \n--select *\n    from reclada.v_class_lite c\n    where c.id = \n        (\n            SELECT min(id) min_id\n                FROM reclada.v_class_lite\n                GROUP BY for_class\n                HAVING count(*)>1\n        );\n\nselect public.raise_exception('find more then 1 version for some class')\n    where exists(\n        select for_class\n            from reclada.v_class_lite\n            GROUP BY for_class\n            HAVING count(*)>1\n    );\n\nUPDATE reclada.object o\n    set attributes = c.attributes || '{"version":1}'::jsonb\n        from v_class_lite c\n            where c.id = o.id;\n\ni 'view/reclada.v_object_status.sql'\ni 'view/reclada.v_user.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_revision.sql'\ni 'view/reclada.v_class.sql'\n\ni 'function/reclada_object.get_schema.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada.datasource_insert_trigger_fnc.sql'\ni 'function/reclada_notification.send_object_notification.sql'\ni 'function/reclada_revision.create.sql'\n\n\n\n\n-- ,   reclada_object.get_GUID_for_class    \n\n-- SELECT * FROM reclada.object where class is null;\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');	2021-09-22 14:51:54.773219+00
20	19	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 19 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nalter table reclada.object\n    add column GUID uuid;\n\nupdate reclada.object o\n    set GUID = c.obj_id\n        from reclada.object c\n            where c.id = o.id;\n\n\ndrop VIEW reclada.v_class;\ndrop VIEW reclada.v_revision;\ndrop VIEW reclada.v_active_object;\ndrop VIEW reclada.v_object;\ndrop VIEW reclada.v_class_lite;\ndrop VIEW reclada.v_object_status;\ndrop VIEW reclada.v_user;\nalter table reclada.object\n    drop column obj_id;\n\ncreate index GUID_index \n    ON reclada.object(GUID);\n\n-- delete from reclada.object where class is null;\nalter table reclada.object \n    alter column class set not null;\n\ni 'function/reclada_object.get_jsonschema_GUID.sql'\ni 'view/reclada.v_class_lite.sql'\ni 'view/reclada.v_object_status.sql'\ni 'view/reclada.v_user.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_class.sql'\ni 'view/reclada.v_revision.sql'\ni 'function/reclada.datasource_insert_trigger_fnc.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.delete.sql'\ni 'function/reclada_object.list.sql'\n\ni 'function/reclada_object.list_add.sql'\ni 'function/reclada_object.list_drop.sql'\ni 'function/reclada_object.list_related.sql'\n\ni 'function/api.reclada_object_delete.sql'\ni 'function/api.reclada_object_list_add.sql'\ni 'function/api.reclada_object_list_drop.sql'\ni 'function/api.reclada_object_list_related.sql'\ni 'function/api.reclada_object_update.sql'\ni 'function/reclada_revision.create.sql'\ni 'function/reclada_notification.send_object_notification.sql'\n\n\n\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');	2021-09-22 14:52:02.849993+00
21	20	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 20 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\n\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_class.sql'\ni 'view/reclada.v_revision.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.list_related.sql'\n\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/api.reclada_object_list_drop.sql'\ni 'function/api.reclada_object_list_related.sql'\n\n\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');	2021-09-22 14:52:11.560797+00
22	21	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 21 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\n\ni 'function/reclada_object.create_subclass.sql'\ni 'function/reclada_object.list_related.sql'\ni 'function/api.storage_generate_presigned_post.sql'\n\nupdate v_class_lite\n\tset attributes = attributes || '{"version":1}'\n\t\twhere attributes->>'version' is null;\n\n\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');	2021-09-22 14:52:17.117935+00
23	22	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 22 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.create_subclass.sql'\n\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Lambda",\n        "properties": {\n            "name": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/reclada.datasource_insert_trigger_fnc.sql'\n\n\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect public.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect public.raise_exception('Downgrade script not support');	2021-09-22 14:52:20.777627+00
24	23	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect public.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 23 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nDROP FUNCTION IF EXISTS public.raise_exception;\nDROP FUNCTION IF EXISTS public.raise_notice;\nDROP FUNCTION IF EXISTS public.try_cast_uuid;\nDROP FUNCTION IF EXISTS public.try_cast_int;\n\ni 'function/reclada.raise_exception.sql'\ni 'function/reclada.raise_notice.sql'\ni 'function/reclada.try_cast_uuid.sql'\ni 'function/reclada.try_cast_int.sql'\ni 'function/dev.downgrade_version.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.update.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-22 14:52:24.586095+00
25	24	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 24 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/dev.reg_notice.sql'\n\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Context",\n        "properties": {\n            "Lambda": {"type": "string"}\n\t\t\t,"Environment": {"type": "string"}\n        },\n        "required": ["Environment"]\n    }\n}'::jsonb);\n\n\nDELETE\nFROM reclada.object\nWHERE class = reclada_object.get_jsonschema_GUID() and attributes->>'forClass'='Lambda';\n\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/reclada.datasource_insert_trigger_fnc.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-22 14:52:29.56296+00
26	25	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 25 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-22 14:52:33.297062+00
27	26	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 26 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.update.sql'\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-22 14:52:36.392408+00
30	29	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 29 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.create.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-22 14:53:19.718582+00
31	30	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 30 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ndrop SEQUENCE IF EXISTS reclada.reclada_revisions;\n\nCREATE SEQUENCE IF not EXISTS reclada.transaction_id\n    START WITH 1\n    INCREMENT BY 1\n    NO MINVALUE\n    NO MAXVALUE\n    CACHE 1;\n\ni 'function/reclada.get_transaction_id.sql' \ni 'function/reclada_object.create.sql' \ni 'function/reclada_object.delete.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'function/reclada_object.list.sql'\n\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-23 08:01:33.105744+00
32	31	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 31 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "ImportInfo",\n        "properties": {\n            "name": {\n                "type": "string"\n            },\n            "tranID": {\n                "type": "number"\n            }\n        },\n        "required": ["name","tranID"]\n    }\n}'::jsonb);\n\n\ni 'function/reclada.raise_exception.sql'\ni 'function/reclada_object.create.sql' \ni 'view/reclada.v_import_info.sql'\ni 'view/reclada.v_object.sql'\ni 'function/reclada.get_transaction_id_for_import.sql'\ni 'function/reclada_object.delete.sql'\ni 'function/reclada_object.is_equal.sql'\ni 'function/reclada.rollback_import.sql'\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-24 09:46:22.790044+00
33	32	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 32 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\n-- remove revision from object\ni 'view/reclada.v_object.sql'\n\nupdate reclada.object\nset transaction_id = reclada.get_transaction_id()\n\twhere transaction_id is null;\n\nalter table reclada.object\n    alter COLUMN transaction_id set not null;\n\n-- improve for {"class": "609ed4a4-f73a-4c05-9057-57bd212ef8ff"} \ni 'function/reclada_object.list.sql'\n\ni 'function/reclada_object.get_transaction_id.sql'\ni 'function/api.reclada_object_get_transaction_id.sql'\ni 'function/reclada_revision.create.sql'\ni 'function/reclada_object.update.sql'\n\nCREATE INDEX transaction_id_index ON reclada.object (transaction_id);\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-27 11:09:01.274324+00
34	33	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 33 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'view/reclada.v_PK_for_class.sql'\ni 'function/reclada_object.create.sql'\n\n/*\n    tests:\n        SELECT  guid,\n                for_class,\n                pk \n            FROM reclada.v_pk_for_class;\n    --x3\n    select reclada_object.create('\n    {\n        "class":"File",\n        "attributes":{\n            "uri": "123",\n            "name": "123",\n            "tags": [],\n            "checksum": "123",\n            "mimeType": "pdf"\n        }\n    }');\n    select reclada_object.create('\n    {\n        "class":"File",\n        "attributes":{\n            "uri": "1234",\n            "name": "123",\n            "tags": [],\n            "checksum": "123",\n            "mimeType": "pdf"\n        }\n    }');\n\n*/\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-28 12:35:37.837433+00
35	34	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 34 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.create.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-09-29 16:57:53.636568+00
36	35	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 35 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'view/reclada.v_PK_for_class.sql'\ni 'function/reclada.get_transaction_id_for_import.sql'\ni 'function/reclada.rollback_import.sql'\n\ni 'function/reclada_user.is_allowed.sql'\ni 'function/api.reclada_object_create.sql'\ni 'function/api.reclada_object_delete.sql'\ni 'function/api.reclada_object_get_transaction_id.sql'\ni 'function/api.reclada_object_list.sql'\ni 'function/api.reclada_object_list_add.sql'\ni 'function/api.reclada_object_list_drop.sql'\ni 'function/api.reclada_object_list_related.sql'\ni 'function/api.reclada_object_update.sql'\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/reclada_object.list.sql'\n\n\n\nupdate reclada.object \n    set class = '00000000-0000-0000-0000-000000000d0c'\n    WHERE class = \n    (\n        select guid \n            from reclada.object \n                where class = reclada_object.get_jsonschema_GUID()\n                    and attributes->>'forClass' = 'Document'\n    ); \nupdate reclada.object \n    set class = '00000000-0000-0000-0000-000000000f1e'\n    WHERE class = \n    (\n        select guid \n            from reclada.object \n                where class = reclada_object.get_jsonschema_GUID()\n                    and attributes->>'forClass' = 'File'\n    ); \n\nDELETE FROM reclada.object\n    WHERE class = reclada_object.get_jsonschema_GUID()\n        and attributes->>'forClass' = 'Document';\nDELETE FROM reclada.object\n    WHERE class = reclada_object.get_jsonschema_GUID()\n        and attributes->>'forClass' = 'File';\n\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Document",\n        "properties": {\n            "name": {"type": "string"},\n            "fileGUID": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n\nSELECT reclada_object.create_subclass('{\n    "class": "DataSource",\n    "attributes": {\n        "newClass": "File",\n        "properties": {\n            "checksum": {"type": "string"},\n            "mimeType": {"type": "string"},\n            "uri": {"type": "string"}\n        },\n        "required": ["checksum", "mimeType"]\n    }\n}'::jsonb);\n\nupdate reclada.object \n    set class = \n    (\n        select guid \n            from reclada.object \n                where class = reclada_object.get_jsonschema_GUID()\n                    and attributes->>'forClass' = 'Document'\n    )\n    WHERE class = '00000000-0000-0000-0000-000000000d0c'; \n\nupdate reclada.object \n    set class = \n    (\n        select guid \n            from reclada.object \n                where class = reclada_object.get_jsonschema_GUID()\n                    and attributes->>'forClass' = 'File'\n    )\n    WHERE class = '00000000-0000-0000-0000-000000000f1e'; \n\nCREATE INDEX IF NOT EXISTS revision_index ON reclada.object ((attributes->>'revision'));\nCREATE INDEX IF NOT EXISTS job_status_index ON reclada.object ((attributes->>'status'));\nCREATE INDEX IF NOT EXISTS runner_type_index  ON reclada.object ((attributes->>'type'));\nCREATE INDEX IF NOT EXISTS file_uri_index  ON reclada.object ((attributes->>'uri'));\nCREATE INDEX IF NOT EXISTS document_fileGUID_index  ON reclada.object ((attributes->>'fileGUID'));\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('Downgrade script not support');	2021-10-04 08:06:30.979167+00
37	36	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 36 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_pk_for_class;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\n\nDROP VIEW IF EXISTS reclada.v_object_status;\nDROP VIEW IF EXISTS reclada.v_user;\nDROP VIEW IF EXISTS reclada.v_class_lite;\n\ni 'view/reclada.v_class_lite.sql'\ni 'view/reclada.v_object_status.sql'\ni 'view/reclada.v_user.sql'\n\n\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_class.sql'\ni 'view/reclada.v_pk_for_class.sql'\ni 'view/reclada.v_import_info.sql'\ni 'view/reclada.v_revision.sql'\n\ni 'function/reclada_object.refresh_mv.sql'\ni 'function/reclada_object.datasource_insert.sql'\n\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.create_subclass.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.delete.sql'\n\nDROP TRIGGER IF EXISTS datasource_insert_trigger ON reclada.object;\nDROP FUNCTION IF EXISTS reclada.datasource_insert_trigger_fnc;\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\nDROP function IF EXISTS reclada.datasource_insert_trigger_fnc ;\nCREATE OR REPLACE FUNCTION reclada.datasource_insert_trigger_fnc()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    obj_id         uuid;\n    dataset       jsonb;\n    uri           text;\n    environment   varchar;\nBEGIN\n    IF NEW.class in \n            (select reclada_object.get_GUID_for_class('DataSource'))\n        OR NEW.class in (select reclada_object.get_GUID_for_class('File')) THEN\n\n        obj_id := NEW.GUID;\n\n        SELECT v.data\n        FROM reclada.v_active_object v\n\t    WHERE v.attrs->>'name' = 'defaultDataSet'\n\t    INTO dataset;\n\n        dataset := jsonb_set(dataset, '{attributes, dataSources}', dataset->'attributes'->'dataSources' || format('["%s"]', obj_id)::jsonb);\n\n        PERFORM reclada_object.update(dataset);\n\n        uri := NEW.attributes->>'uri';\n\n        SELECT attrs->>'Environment'\n        FROM reclada.v_active_object\n        WHERE class_name = 'Context'\n        ORDER BY created_time DESC\n        LIMIT 1\n        INTO environment;\n\n        PERFORM reclada_object.create(\n            format('{\n                "class": "Job",\n                "attributes": {\n                    "task": "c94bff30-15fa-427f-9954-d5c3c151e652",\n                    "status": "new",\n                    "type": "%s",\n                    "command": "./run_pipeline.sh",\n                    "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\n                    }\n                }', environment, uri, obj_id)::jsonb);\n\n    END IF;\n\nRETURN NEW;\nEND;\n$function$\n;\n\ncreate trigger datasource_insert_trigger before\ninsert\n    on\n    reclada.object for each row execute function datasource_insert_trigger_fnc();\n\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_pk_for_class;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\n\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_status;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_user;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_class_lite;\n\nDROP view IF EXISTS reclada.v_class_lite ;\nCREATE OR REPLACE VIEW reclada.v_class_lite\nAS\n SELECT obj.id,\n    obj.guid AS obj_id,\n    obj.attributes ->> 'forClass'::text AS for_class,\n    (obj.attributes ->> 'version'::text)::bigint AS version,\n    obj.created_time,\n    obj.attributes,\n    obj.status\n   FROM object obj\n  WHERE obj.class = reclada_object.get_jsonschema_guid();\nDROP view IF EXISTS reclada.v_object_status ;\nCREATE OR REPLACE VIEW reclada.v_object_status\nAS\n SELECT obj.id,\n    obj.guid AS obj_id,\n    obj.attributes ->> 'caption'::text AS caption,\n    obj.created_time,\n    obj.attributes AS attrs\n   FROM object obj\n  WHERE (obj.class IN ( SELECT reclada_object.get_guid_for_class('ObjectStatus'::text) AS get_guid_for_class));\nDROP view IF EXISTS reclada.v_user ;\nCREATE OR REPLACE VIEW reclada.v_user\nAS\n SELECT obj.id,\n    obj.guid AS obj_id,\n    obj.attributes ->> 'login'::text AS login,\n    obj.created_time,\n    obj.attributes AS attrs\n   FROM object obj\n  WHERE (obj.class IN ( SELECT reclada_object.get_guid_for_class('User'::text) AS get_guid_for_class)) AND obj.status = reclada_object.get_active_status_obj_id();\n\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n WITH t AS (\n         SELECT obj.id,\n            obj.guid,\n            obj.class,\n            r.num,\n            NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n            obj.attributes,\n            obj.status,\n            obj.created_time,\n            obj.created_by,\n            obj.transaction_id\n           FROM object obj\n             LEFT JOIN ( SELECT (r_1.attributes ->> 'num'::text)::bigint AS num,\n                    r_1.guid\n                   FROM object r_1\n                  WHERE (r_1.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class))) r ON r.guid = NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid\n        )\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    t.num AS revision_num,\n    os.caption AS status_caption,\n    t.revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID") tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id\n   FROM t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    (obj.attrs ->> 'version'::text)::bigint AS version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_pk_for_class ;\nCREATE OR REPLACE VIEW reclada.v_pk_for_class\nAS\n SELECT obj.obj_id AS guid,\n    obj.for_class,\n    pk.pk\n   FROM v_class obj\n     JOIN ( SELECT 'File'::text AS class_name,\n            'uri'::text AS pk) pk ON pk.class_name = obj.for_class;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\n\nDROP FUNCTION reclada_object.refresh_mv;\nDROP FUNCTION reclada_object.datasource_insert;\n\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    class           text;\n    new_class       text;\n    attrs           jsonb;\n    class_schema    jsonb;\n    version_         integer;\n\nBEGIN\n\n    class := data->>'class';\n    IF (class IS NULL) THEN\n        RAISE EXCEPTION 'The reclada object class is not specified';\n    END IF;\n\n    attrs := data->'attributes';\n    IF (attrs IS NULL) THEN\n        RAISE EXCEPTION 'The reclada object must have attributes';\n    END IF;\n\n    new_class = attrs->>'newClass';\n\n    SELECT reclada_object.get_schema(class) INTO class_schema;\n\n    IF (class_schema IS NULL) THEN\n        RAISE EXCEPTION 'No json schema available for %', class;\n    END IF;\n\n    SELECT max(version) + 1\n    FROM reclada.v_class_lite v\n    WHERE v.for_class = new_class\n    INTO version_;\n\n    version_ := coalesce(version_,1);\n    class_schema := class_schema->'attributes'->'schema';\n\n    PERFORM reclada_object.create(format('{\n        "class": "jsonschema",\n        "attributes": {\n            "forClass": "%s",\n            "version": "%s",\n            "schema": {\n                "type": "object",\n                "properties": %s,\n                "required": %s\n            }\n        }\n    }',\n    new_class,\n    version_,\n    (class_schema->'properties') || (attrs->'properties'),\n    (SELECT jsonb_agg(el) FROM (\n        SELECT DISTINCT pg_catalog.jsonb_array_elements(\n            (class_schema -> 'required') || (attrs -> 'required')\n        ) el) arr)\n    )::jsonb);\n\nEND;\n$function$\n;\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    branch        uuid;\n    data          jsonb;\n    class_name    text;\n    class_uuid    uuid;\n    tran_id       bigint;\n    _attrs         jsonb;\n    schema        jsonb;\n    obj_GUID      uuid;\n    res           jsonb;\n    affected      uuid[];\nBEGIN\n\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\n        data_jsonb := '[]'::jsonb || data_jsonb;\n    END IF;\n    /*TODO: check if some objects have revision and others do not */\n    branch:= data_jsonb->0->'branch';\n\n    FOR data IN SELECT jsonb_array_elements(data_jsonb) \n    LOOP\n\n        class_name := data->>'class';\n\n        IF (class_name IS NULL) THEN\n            RAISE EXCEPTION 'The reclada object class is not specified';\n        END IF;\n        class_uuid := reclada.try_cast_uuid(class_name);\n\n        _attrs := data->'attributes';\n        IF (_attrs IS NULL) THEN\n            RAISE EXCEPTION 'The reclada object must have attributes';\n        END IF;\n\n        tran_id := (data->>'transactionID')::bigint;\n        if tran_id is null then\n            tran_id := reclada.get_transaction_id();\n        end if;\n\n        IF class_uuid IS NULL THEN\n            SELECT reclada_object.get_schema(class_name) \n            INTO schema;\n            class_uuid := (schema->>'GUID')::uuid;\n        ELSE\n            SELECT v.data \n            FROM reclada.v_class v\n            WHERE class_uuid = v.obj_id\n            INTO schema;\n        END IF;\n        IF (schema IS NULL) THEN\n            RAISE EXCEPTION 'No json schema available for %', class_name;\n        END IF;\n\n        IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', _attrs))) THEN\n            RAISE EXCEPTION 'JSON invalid: %', _attrs;\n        END IF;\n        \n        IF data->>'id' IS NOT NULL THEN\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\n        END IF;\n\n        IF class_uuid IN (SELECT guid FROM reclada.v_PK_for_class)\n        THEN\n            SELECT o.obj_id\n                FROM reclada.v_object o\n                JOIN reclada.v_PK_for_class pk\n                    on pk.guid = o.class\n                        and class_uuid = o.class\n                where o.attrs->>pk.pk = _attrs ->> pk.pk\n                LIMIT 1\n            INTO obj_GUID;\n            IF obj_GUID IS NOT NULL THEN\n                SELECT reclada_object.update(data || format('{"GUID": "%s"}', obj_GUID)::jsonb)\n                    INTO res;\n                    RETURN '[]'::jsonb || res;\n            END IF;\n        END IF;\n\n        obj_GUID := (data->>'GUID')::uuid;\n        IF EXISTS (\n            SELECT 1\n            FROM reclada.object \n            WHERE GUID = obj_GUID\n        ) THEN\n            RAISE EXCEPTION 'GUID: % is duplicate', obj_GUID;\n        END IF;\n        --raise notice 'schema: %',schema;\n\n        INSERT INTO reclada.object(GUID,class,attributes,transaction_id)\n            SELECT  CASE\n                        WHEN obj_GUID IS NULL\n                            THEN public.uuid_generate_v4()\n                        ELSE obj_GUID\n                    END AS GUID,\n                    class_uuid, \n                    _attrs,\n                    tran_id\n        RETURNING GUID INTO obj_GUID;\n        affected := array_append( affected, obj_GUID);\n\n    END LOOP;\n\n    res := array_to_json\n            (\n                array\n                (\n                    SELECT o.data \n                    FROM reclada.v_active_object o\n                    WHERE o.obj_id = ANY (affected)\n                )\n            )::jsonb; \n    PERFORM reclada_notification.send_object_notification\n        (\n            'create',\n            res\n        );\n    RETURN res;\n\nEND;\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    class_name     text;\n    class_uuid     uuid;\n    v_obj_id       uuid;\n    v_attrs        jsonb;\n    schema        jsonb;\n    old_obj       jsonb;\n    branch        uuid;\n    revid         uuid;\n\nBEGIN\n\n    class_name := data->>'class';\n    IF (class_name IS NULL) THEN\n        RAISE EXCEPTION 'The reclada object class is not specified';\n    END IF;\n    class_uuid := reclada.try_cast_uuid(class_name);\n    v_obj_id := data->>'GUID';\n    IF (v_obj_id IS NULL) THEN\n        RAISE EXCEPTION 'Could not update object with no GUID';\n    END IF;\n\n    v_attrs := data->'attributes';\n    IF (v_attrs IS NULL) THEN\n        RAISE EXCEPTION 'The reclada object must have attributes';\n    END IF;\n\n    SELECT reclada_object.get_schema(class_name) \n        INTO schema;\n\n    if class_uuid is null then\n        SELECT reclada_object.get_schema(class_name) \n            INTO schema;\n    else\n        select v.data \n            from reclada.v_class v\n                where class_uuid = v.obj_id\n            INTO schema;\n    end if;\n    -- TODO: don't allow update jsonschema\n    IF (schema IS NULL) THEN\n        RAISE EXCEPTION 'No json schema available for %', class_name;\n    END IF;\n\n    IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', v_attrs))) THEN\n        RAISE EXCEPTION 'JSON invalid: %', v_attrs;\n    END IF;\n\n    SELECT \tv.data\n        FROM reclada.v_active_object v\n\t        WHERE v.obj_id = v_obj_id\n\t    INTO old_obj;\n\n    IF (old_obj IS NULL) THEN\n        RAISE EXCEPTION 'Could not update object, no such id';\n    END IF;\n\n    branch := data->'branch';\n    SELECT reclada_revision.create(user_info->>'sub', branch, v_obj_id) \n        INTO revid;\n    \n    with t as \n    (\n        update reclada.object o\n            set status = reclada_object.get_archive_status_obj_id()\n                where o.GUID = v_obj_id\n                    and status != reclada_object.get_archive_status_obj_id()\n                        RETURNING id\n    )\n    INSERT INTO reclada.object( GUID,\n                                class,\n                                status,\n                                attributes,\n                                transaction_id\n                              )\n        select  v.obj_id,\n                (schema->>'GUID')::uuid,\n                reclada_object.get_active_status_obj_id(),--status \n                v_attrs || format('{"revision":"%s"}',revid)::jsonb,\n                transaction_id\n            FROM reclada.v_object v\n            JOIN t \n                on t.id = v.id\n\t            WHERE v.obj_id = v_obj_id;\n                    \n    select v.data \n        FROM reclada.v_active_object v\n            WHERE v.obj_id = v_obj_id\n        into data;\n    PERFORM reclada_notification.send_object_notification('update', data);\n    RETURN data;\nEND;\n$function$\n;\nDROP function IF EXISTS reclada_object.delete ;\nCREATE OR REPLACE FUNCTION reclada_object.delete(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_obj_id            uuid;\n    tran_id             bigint;\n    class               text;\n    class_uuid          uuid;\n    list_id             bigint[];\n\nBEGIN\n\n    v_obj_id := data->>'GUID';\n    tran_id := (data->>'transactionID')::bigint;\n    class := data->>'class';\n\n    IF (v_obj_id IS NULL AND class IS NULL AND tran_id IS NULl) THEN\n        RAISE EXCEPTION 'Could not delete object with no GUID, class and transactionID';\n    END IF;\n\n    class_uuid := reclada.try_cast_uuid(class);\n\n    WITH t AS\n    (    \n        UPDATE reclada.object u\n            SET status = reclada_object.get_archive_status_obj_id()\n            FROM reclada.object o\n                LEFT JOIN\n                (   SELECT obj_id FROM reclada_object.get_GUID_for_class(class)\n                    UNION SELECT class_uuid WHERE class_uuid IS NOT NULL\n                ) c ON o.class = c.obj_id\n                WHERE u.id = o.id AND\n                (\n                    (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id = o.transaction_id)\n\n                    OR (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id IS NULL)\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id = o.transaction_id)\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id = o.transaction_id)\n\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id IS NULL)\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id IS NULL)\n                    OR (v_obj_id IS NULL AND c.obj_id IS NULL AND tran_id = o.transaction_id)\n                )\n                    AND o.status != reclada_object.get_archive_status_obj_id()\n                    RETURNING o.id\n    ) \n        SELECT\n            array\n            (\n                SELECT t.id FROM t\n            )\n        INTO list_id;\n\n    SELECT array_to_json\n    (\n        array\n        (\n            SELECT o.data\n            FROM reclada.v_object o\n            WHERE o.id IN (SELECT unnest(list_id))\n        )\n    )::jsonb\n    INTO data;\n\n    IF (jsonb_array_length(data) = 1) THEN\n        data := data->0;\n    END IF;\n    \n    IF (data IS NULL) THEN\n        RAISE EXCEPTION 'Could not delete object, no such GUID';\n    END IF;\n\n    PERFORM reclada_notification.send_object_notification('delete', data);\n\n    RETURN data;\nEND;\n$function$\n;	2021-10-07 11:23:22.77559+00
38	37	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 37 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/reclada_object.list_drop.sql'\ni 'api.reclada_object_list_drop.sql'\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/reclada_object.list.sql'\n\ni 'function/reclada_object.get_condition_array.sql'\ni 'function/reclada_object.get_query_condition.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\nDROP function IF EXISTS api.storage_generate_presigned_post ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_post(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    lambda_name  varchar;\r\n    file_type    varchar;\r\n    object       jsonb;\r\n    object_id    uuid;\r\n    object_name  varchar;\r\n    object_path  varchar;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\n    uri          varchar;\r\n    url          varchar;\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF(NOT(reclada_user.is_allowed(user_info, 'generate presigned post', ''))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    object_name := data->>'objectName';\r\n    file_type := data->>'fileType';\r\n\r\n    SELECT attrs->>'Lambda'\r\n    FROM reclada.v_active_object\r\n    WHERE class_name = 'Context'\r\n    ORDER BY created_time DESC\r\n    LIMIT 1\r\n    INTO lambda_name;\r\n\r\n    SELECT payload::jsonb\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n                format('%s', lambda_name),\r\n                'eu-west-1'\r\n        ),\r\n        format('{\r\n            "type": "post",\r\n            "fileName": "%s",\r\n            "fileType": "%s",\r\n            "fileSize": "%s",\r\n            "expiration": 3600}',\r\n            object_name,\r\n            file_type,\r\n            data->>'fileSize'\r\n            )::jsonb)\r\n    INTO url;\r\n\r\n    result = format(\r\n        '{"uploadUrl": %s}',\r\n        url\r\n    )::jsonb;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.storage_generate_presigned_get ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_get(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    object_data  jsonb;\r\n    object_id    uuid;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\n    lambda_name  varchar;\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF(NOT(reclada_user.is_allowed(user_info, 'generate presigned get', ''))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned get';\r\n    END IF;\r\n\r\n    -- TODO: check user's permissions for reclada object access?\r\n    object_id := data->>'objectId';\r\n    SELECT reclada_object.list(format(\r\n        '{"class": "File", "attributes": {}, "GUID": "%s"}',\r\n        object_id\r\n    )::jsonb) -> 0 INTO object_data;\r\n\r\n    SELECT attrs->>'Lambda'\r\n    FROM reclada.v_active_object\r\n    WHERE class_name = 'Context'\r\n    ORDER BY created_time DESC\r\n    LIMIT 1\r\n    INTO lambda_name;\r\n\r\n    SELECT payload\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n            format('%s', lambda_name),\r\n            'eu-west-1'\r\n            ),\r\n        format('{\r\n            "type": "get",\r\n            "uri": "%s",\r\n            "expiration": 3600}',\r\n            object_data->'attributes'->>'uri'\r\n            )::jsonb)\r\n    INTO result;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list_drop ;\nCREATE OR REPLACE FUNCTION reclada_object.list_drop(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    objid           uuid;\r\n    obj             jsonb;\r\n    values_to_drop  jsonb;\r\n    field           text;\r\n    field_value     jsonb;\r\n    json_path       text[];\r\n    new_value       jsonb;\r\n    new_obj         jsonb;\r\n    res             jsonb;\r\n\r\nBEGIN\r\n\r\n\tclass := data->>'class';\r\n\tIF (class IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The reclada object class is not specified';\r\n\tEND IF;\r\n\r\n\tobjid := (data->>'GUID')::uuid;\r\n\tIF (objid IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The is no GUID';\r\n\tEND IF;\r\n\r\n    SELECT v.data\r\n    FROM reclada.v_active_object v\r\n    WHERE v.obj_id = objid\r\n    INTO obj;\r\n\r\n\tIF (obj IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The is no object with such id';\r\n\tEND IF;\r\n\r\n\tvalues_to_drop := data->'value';\r\n\tIF (values_to_drop IS NULL OR values_to_drop = 'null'::jsonb) THEN\r\n\t\tRAISE EXCEPTION 'The value should not be null';\r\n\tEND IF;\r\n\r\n\tIF (jsonb_typeof(values_to_drop) != 'array') THEN\r\n\t\tvalues_to_drop := format('[%s]', values_to_drop)::jsonb;\r\n\tEND IF;\r\n\r\n\tfield := data->>'field';\r\n\tIF (field IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'There is no field';\r\n\tEND IF;\r\n\tjson_path := format('{attributes, %s}', field);\r\n\tfield_value := obj#>json_path;\r\n\tIF (field_value IS NULL OR field_value = 'null'::jsonb) THEN\r\n\t\tRAISE EXCEPTION 'The object does not have this field';\r\n\tEND IF;\r\n\r\n\tSELECT jsonb_agg(elems)\r\n\tFROM\r\n\t\tjsonb_array_elements(field_value) elems\r\n\tWHERE\r\n\t\telems NOT IN (\r\n\t\t\tSELECT jsonb_array_elements(values_to_drop))\r\n\tINTO new_value;\r\n\r\n\tSELECT jsonb_set(obj, json_path, coalesce(new_value, '[]'::jsonb))\r\n\tINTO new_obj;\r\n\r\n\tSELECT reclada_object.update(new_obj) INTO res;\r\n\tRETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_list_drop ;\nCREATE OR REPLACE FUNCTION api.reclada_object_list_drop(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    obj_id          uuid;\r\n    user_info       jsonb;\r\n    field_value     jsonb;\r\n    values_to_drop  jsonb;\r\n    result          jsonb;\r\n\r\nBEGIN\r\n\r\n\tclass := data->>'class';\r\n\tIF (class IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The reclada object class is not specified';\r\n\tEND IF;\r\n\r\n\tobj_id := (data->>'GUID')::uuid;\r\n\tIF (obj_id IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The is no GUID';\r\n\tEND IF;\r\n\r\n\tfield_value := data->'field';\r\n\tIF (field_value IS NULL OR field_value = 'null'::jsonb) THEN\r\n\t\tRAISE EXCEPTION 'There is no field';\r\n\tEND IF;\r\n\r\n\tvalues_to_drop := data->'value';\r\n\tIF (values_to_drop IS NULL OR values_to_drop = 'null'::jsonb) THEN\r\n\t\tRAISE EXCEPTION 'The value should not be null';\r\n\tEND IF;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'list_add', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list_add', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.list_drop(data) INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\n\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\nBEGIN\r\n\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    class := data->>'class';\r\n    IF (class IS NULL and tran_id IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class and transactionID are not specified';\r\n    END IF;\r\n    class_uuid := reclada.try_cast_uuid(class);\r\n\r\n    if class_uuid is not null then\r\n        select v.for_class \r\n            from reclada.v_class_lite v\r\n                where class_uuid = v.obj_id\r\n        into class;\r\n\r\n        IF (class IS NULL) THEN\r\n            RAISE EXCEPTION 'Class not found by GUID: %', class_uuid::text;\r\n        END IF;\r\n    end if;\r\n\r\n    attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    IF (jsonb_typeof(order_by_jsonb) != 'array') THEN\r\n    \t\torder_by_jsonb := format('[%s]', order_by_jsonb);\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n    FROM jsonb_array_elements(order_by_jsonb) T\r\n    INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n    IF ((limit_ ~ '(\\D+)') AND (limit_ != 'ALL')) THEN\r\n    \t\tRAISE EXCEPTION 'The limit must be an integer number or "ALL"';\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    IF (offset_ ~ '(\\D+)') THEN\r\n    \t\tRAISE EXCEPTION 'The offset must be an integer number';\r\n    END IF;\r\n\r\n    SELECT\r\n        string_agg(\r\n            format(\r\n                E'(%s)',\r\n                condition\r\n            ),\r\n            ' AND '\r\n        )\r\n        FROM (\r\n            SELECT\r\n                format('obj.class_name = ''%s''', class) AS condition\r\n                    where class is not null \r\n                        and class_uuid is null\r\n            UNION\r\n                SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                    where class_uuid is not null\r\n            UNION\r\n                SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                    where tran_id is not null\r\n            UNION \r\n                SELECT CASE\r\n                        WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                        (\r\n                            SELECT string_agg\r\n                                (\r\n                                    format(\r\n                                        E'(%s)',\r\n                                        reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                    ),\r\n                                    ' AND '\r\n                                )\r\n                                FROM jsonb_array_elements(data->'GUID') AS cond\r\n                        )\r\n                        ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                    END AS condition\r\n                WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n            UNION\r\n            SELECT\r\n                CASE\r\n                    WHEN jsonb_typeof(value) = 'array'\r\n                        THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format\r\n                                        (\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(value) AS cond\r\n                            )\r\n                    ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                END AS condition\r\n            FROM jsonb_each(attrs)\r\n            WHERE attrs != ('{}'::jsonb)\r\n        ) conds\r\n    INTO query_conditions;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             FROM reclada.v_object obj\r\n    --             WHERE ' || query_conditions ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n    query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n    --raise notice 'query: %', query;\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    IF gui THEN\r\n\r\n        EXECUTE E'SELECT count(1)\r\n        '|| query\r\n        INTO number_of_objects;\r\n\r\n        EXECUTE E'SELECT TO_CHAR(\r\n\tMAX(\r\n\t\tGREATEST(obj.created_time, (\r\n\t\t\tSELECT TO_TIMESTAMP(MAX(date_time),\\'YYYY-MM-DD hh24:mi:ss.US TZH\\')\r\n\t\t\tFROM reclada.v_revision vr\r\n\t\t\tWHERE vr.obj_id = UUID(obj.attrs ->>\\'revision\\'))\r\n\t\t)\r\n\t),\\'YYYY-MM-DD hh24:mi:ss.MS TZH\\')\r\n        '|| query\r\n        INTO last_change;\r\n\r\n        res := jsonb_build_object(\r\n        'last_change', last_change,    \r\n        'number', number_of_objects,\r\n        'objects', objects);\r\n    ELSE\r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\n\n\nDROP function IF EXISTS reclada_object.get_condition_array ;\nCREATE OR REPLACE FUNCTION reclada_object.get_condition_array(data jsonb, key_path text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\n    SELECT\r\n    CONCAT(\r\n        key_path,\r\n        ' ', COALESCE(data->>'operator', '='), ' ',\r\n        format(E'\\'%s\\'::jsonb', data->'object'#>>'{}'))\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_query_condition ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition(data jsonb, key_path text)\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    key          text;\r\n    operator     text;\r\n    value        text;\r\n    res          text;\r\n\r\nBEGIN\r\n    IF (data IS NULL OR data = 'null'::jsonb) THEN\r\n        RAISE EXCEPTION 'There is no condition';\r\n    END IF;\r\n\r\n    IF (jsonb_typeof(data) = 'object') THEN\r\n\r\n        IF (data->'object' IS NULL OR data->'object' = ('null'::jsonb)) THEN\r\n            RAISE EXCEPTION 'There is no object field';\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'object') = 'object') THEN\r\n            operator :=  data->>'operator';\r\n            IF operator = '=' then\r\n                key := reclada_object.cast_jsonb_to_postgres(key_path, 'string' );\r\n                RETURN (key || ' ' || operator || ' ''' || (data->'object')::text || '''');\r\n            ELSE\r\n                RAISE EXCEPTION 'The input_jsonb->''object'' can not contain jsonb object';\r\n            END If;\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'operator') != 'string' AND data->'operator' IS NOT NULL) THEN\r\n            RAISE EXCEPTION 'The input_jsonb->''operator'' must contain string';\r\n        END IF;\r\n\r\n        IF (jsonb_typeof(data->'object') = 'array') THEN\r\n            res := reclada_object.get_condition_array(data, key_path);\r\n        ELSE\r\n            key := reclada_object.cast_jsonb_to_postgres(key_path, jsonb_typeof(data->'object'));\r\n            operator :=  data->>'operator';\r\n            value := reclada_object.jsonb_to_text(data->'object');\r\n            res := key || ' ' || operator || ' ' || value;\r\n        END IF;\r\n    ELSE\r\n        key := reclada_object.cast_jsonb_to_postgres(key_path, jsonb_typeof(data));\r\n        operator := '=';\r\n        value := reclada_object.jsonb_to_text(data);\r\n        res := key || ' ' || operator || ' ' || value;\r\n    END IF;\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;	2021-10-13 15:06:36.060425+00
39	38	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n\t\tupgrade_script text,\n\t\tdowngrade_script text\n    );\n\t\ninsert into var_table(ver)\t\n\tselect max(ver) + 1\n        from dev.VER;\n\t\t\nselect reclada.raise_exception('Can not apply this version!') \n\twhere not exists\n\t(\n\t\tselect ver from var_table where ver = 38 --!!! write current version HERE !!!\n\t);\n\nCREATE TEMP TABLE tmp\n(\n\tid int GENERATED ALWAYS AS IDENTITY,\n\tstr text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n\tfrom tmp ttt\n\tinner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n\tinner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n        \t\tsplit_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n\t\tinner JOIN LATERAL\n    (\n        select case\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t    (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n\tinner JOIN LATERAL\n    (\n        select case \n\t\t\t\twhen obj.typ in ('function', 'procedure')\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tSELECT 1 a\n\t\t\t\t\t\t\t\t\t\tFROM pg_proc p \n\t\t\t\t\t\t\t\t\t\tjoin pg_namespace n \n\t\t\t\t\t\t\t\t\t\t\ton p.pronamespace = n.oid \n\t\t\t\t\t\t\t\t\t\t\twhere n.nspname||'.'||p.proname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'view'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase \n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a \n\t\t\t\t\t\t\t\t\t\tfrom pg_views v \n\t\t\t\t\t\t\t\t\t\t\twhere v.schemaname||'.'||v.viewname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tthen E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\twhen obj.typ = 'trigger'\n\t\t\t\t\tthen\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\twhen EXISTS\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\tselect 1 a\n\t\t\t\t\t\t\t\t\t\tfrom pg_trigger v\n                                            where v.tgname = obj.nam\n\t\t\t\t\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tthen (select pg_catalog.pg_get_triggerdef(oid, true)\n\t\t\t\t\t\t\t\t        from pg_trigger\n\t\t\t\t\t\t\t\t        where tgname = obj.nam)||';'\n\t\t\t\t\t\t\telse ''\n\t\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tttt.str\n\t\t\tend as v\n    )  scr ON TRUE\n\twhere ttt.id = tmp.id\n\t\tand tmp.str like '--{%/%}';\n\t\nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/api.reclada_object_list_drop.sql'\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n\tselect ver, upgrade_script, downgrade_script\n\t\tfrom var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n\t\t\t\t\t\t\t|| (select ver from var_table)::text\n\t\t\t\t\t\t  );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS reclada_object.list_drop ;\nCREATE OR REPLACE FUNCTION reclada_object.list_drop(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    objid           uuid;\r\n    obj             jsonb;\r\n    values_to_drop  jsonb;\r\n    field           text;\r\n    field_value     jsonb;\r\n    json_path       text[];\r\n    new_value       jsonb;\r\n    new_obj         jsonb;\r\n    res             jsonb;\r\n\r\nBEGIN\r\n\r\n\tclass := data->>'class';\r\n\tIF (class IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'The reclada object class is not specified';\r\n\tEND IF;\r\n\r\n\tobjid := (data->>'GUID')::uuid;\r\n\tIF (objid IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'There is no GUID';\r\n\tEND IF;\r\n\r\n    SELECT v.data\r\n    FROM reclada.v_active_object v\r\n    WHERE v.obj_id = objid\r\n    INTO obj;\r\n\r\n\tIF (obj IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'There is no object with such id';\r\n\tEND IF;\r\n\r\n\tvalues_to_drop := data->'value';\r\n\tIF (values_to_drop IS NULL OR values_to_drop = 'null'::jsonb) THEN\r\n\t\tRAISE EXCEPTION 'The value should not be null';\r\n\tEND IF;\r\n\r\n\tIF (jsonb_typeof(values_to_drop) != 'array') THEN\r\n\t\tvalues_to_drop := format('[%s]', values_to_drop)::jsonb;\r\n\tEND IF;\r\n\r\n\tfield := data->>'field';\r\n\tIF (field IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'There is no field';\r\n\tEND IF;\r\n\tjson_path := format('{attributes, %s}', field);\r\n\tfield_value := obj#>json_path;\r\n\tIF (field_value IS NULL OR field_value = 'null'::jsonb) THEN\r\n\t\tRAISE EXCEPTION 'The object does not have this field';\r\n\tEND IF;\r\n\r\n\tSELECT jsonb_agg(elems)\r\n\tFROM\r\n\t\tjsonb_array_elements(field_value) elems\r\n\tWHERE\r\n\t\telems NOT IN (\r\n\t\t\tSELECT jsonb_array_elements(values_to_drop))\r\n\tINTO new_value;\r\n\r\n\tSELECT jsonb_set(obj, json_path, coalesce(new_value, '[]'::jsonb))\r\n\tINTO new_obj;\r\n\r\n\tSELECT reclada_object.update(new_obj) INTO res;\r\n\tRETURN res;\r\n\r\nEND;\r\n$function$\n;	2021-10-18 08:58:38.02402+00
40	39	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 39 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/api.reclada_object_list.sql'\ni 'function/reclada_object.parse_filter.sql'\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/reclada_object.list.sql'\ni 'view/reclada.v_filter_mapping.sql'\n\nALTER TABLE reclada.object ADD COLUMN IF NOT EXISTS parent_guid uuid;\nCREATE INDEX IF NOT EXISTS parent_guid_index ON reclada.object USING btree (parent_guid);\n\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.datasource_insert.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.create_subclass.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_class.sql'\ni 'function/reclada_object.get_condition_array.sql'\n\nCREATE INDEX IF NOT EXISTS class_lite_obj_idx ON reclada.v_class_lite USING btree (obj_id);\nCREATE INDEX IF NOT EXISTS class_lite_class_idx ON reclada.v_class_lite USING btree (for_class);\n\nDO $$\nDECLARE\n\tdsrc_uuid\tTEXT;\n\tdset_uuid\tTEXT;\n\ttrn_id\t\tINT;\n\tdset_data\tjsonb;\n\nBEGIN\n\tSELECT v.obj_id, v.data\n    FROM reclada.v_active_object v\n    WHERE v.attrs->>'name' = 'defaultDataSet'\n\t    INTO dset_uuid, dset_data;\n\tFOR dsrc_uuid IN (\tSELECT DISTINCT jsonb_array_elements_text(attrs->'dataSources') \n\t\t\t\t\t\tFROM v_active_object vao \n\t\t\t\t\t\tWHERE obj_id = dset_uuid::uuid) LOOP\n\t\tPERFORM reclada_object.create(\n            format('{\n                "class": "Relationship",\n                "attributes": {\n                    "type": "defaultDataSet to DataSource",\n                    "object": "%s",\n                    "subject": "%s"\n                    }\n                }', dsrc_uuid, dset_uuid)::jsonb);\n\tEND LOOP;\n\tIF (jsonb_array_length(dset_data->'attributes'->'dataSources') > 0 )  THEN\n\t\tdset_data := jsonb_set(dset_data, '{attributes, dataSources}', '[]'::jsonb);\n\t\tPERFORM reclada_object.update(dset_data);\n\tEND IF;\nEND\n$$;\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_pk_for_class;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\n\n\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition_filter(data jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE \r\n\t_count \tINT;\r\n    _res \tTEXT;\r\nBEGIN \r\n    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE\r\n    CREATE TEMP TABLE mytable AS\r\n    WITH RECURSIVE f AS \r\n    (\r\n        SELECT data AS v\r\n    ),\r\n    pr AS \r\n    (\r\n        SELECT \tformat(' %s ',f.v->>'operator') AS op, \r\n                val.v AS val,\r\n                1 AS lvl,\r\n                row_number() OVER(ORDER BY idx) AS rn,\r\n                val.idx idx,\r\n                0::BIGINT prev\r\n            FROM f, jsonb_array_elements(f.v->'value') WITH ordinality AS val(v, idx)\r\n    ),\r\n    res AS\r\n    (\t\r\n        SELECT \tpr.lvl\t,\r\n                pr.rn\t,\r\n                pr.idx  ,\r\n                pr.op\t,\r\n                pr.prev ,\r\n                pr.val\t,\r\n                CASE jsonb_typeof(pr.val) \r\n                    WHEN 'object'\t\r\n                        THEN NULL\r\n                    ELSE pr.val\r\n                END AS parsed\r\n            FROM pr\r\n            WHERE prev = 0 \r\n                AND lvl = 1\r\n        UNION ALL\r\n        SELECT \tttt.lvl\t,\r\n                ROW_NUMBER() OVER(ORDER BY ttt.idx) AS rn,\r\n                ttt.idx,\r\n                ttt.op\t,\r\n                ttt.prev,\r\n                ttt.val ,\r\n                CASE jsonb_typeof(ttt.val) \r\n                    WHEN 'object'\t\r\n                        THEN NULL\r\n                    ELSE ttt.val\r\n                end AS parsed\r\n            FROM\r\n            (\r\n                SELECT \tres.lvl + 1 AS lvl,\r\n                        format(' %s ',res.val->>'operator') AS op,\r\n                        res.rn AS prev\t,\r\n                        val.v  AS val,\r\n                        val.idx\r\n                    FROM res, \r\n                         jsonb_array_elements(res.val->'value') WITH ordinality AS val(v, idx)\r\n            ) ttt\r\n    )\r\n    SELECT \tr.lvl\t,\r\n            r.rn\t,\r\n            r.idx   ,\r\n            r.op\t,\r\n            r.prev  ,\r\n            r.val\t,\r\n            r.parsed\r\n        FROM res r;\r\n\r\n    UPDATE mytable u\r\n        SET parsed = to_jsonb(p.v)\r\n            FROM mytable t\r\n            JOIN LATERAL \r\n            (\r\n                SELECT t.parsed #>> '{}' v\r\n            ) as pt\r\n                ON TRUE\r\n            JOIN LATERAL \r\n            (\r\n\t\t\t\tSELECT CASE \r\n\t\t\t\t\t\tWHEN pt.v LIKE '{class}'\r\n                            THEN 'class_name'\r\n\t\t\t\t\t\tWHEN pt.v LIKE '%{%}%'\r\n                            THEN REPLACE(\r\n\t\t\t\t\t\t\t\t\tREPLACE(pt.v,'{','data #>> ''{'),\r\n\t\t\t\t\t\t\t\t'}','}''')\r\n\t\t\t\t\t\tWHEN pt.v LIKE '(%)'\r\n                            THEN REPLACE(\r\n\t\t\t\t\t\t\t\t\tREPLACE(\r\n\t\t\t\t\t\t\t\t\t\tREPLACE(pt.v,'(','(''')\r\n\t\t\t\t\t\t\t\t\t,')',''')')\r\n\t\t\t\t\t\t\t\t,',',''',''')\r\n\t\t\t\t\t\tELSE\r\n                            ''''||pt.v||''''\r\n\t\t\t\t\tEND AS v\r\n\t\t\t\t/*\r\n                SELECT CASE \r\n                        WHEN pt.v LIKE '{attributes,%}'\r\n                            THEN format('attrs #>> ''''%s''''', REPLACE(pt.v,'{attributes,','{'))\r\n                        WHEN pt.v LIKE '{class}'\r\n                            THEN 'class_name'\r\n                        WHEN pt.v LIKE '{GUID}'\r\n                            THEN 'obj_id'\r\n                        WHEN pt.v LIKE '{status}'\r\n                            THEN 'status_caption'\r\n\t\t\t\t\t\tWHEN pt.v LIKE '(%)'\r\n                            THEN replace(\r\n\t\t\t\t\t\t\t\t\treplace(\r\n\t\t\t\t\t\t\t\t\t\treplace(pt.v,'(','(''')\r\n\t\t\t\t\t\t\t\t\t,')',''')')\r\n\t\t\t\t\t\t\t\t,',',''',''')\r\n                        WHEN pt.v LIKE '{transactionID}'\r\n                            THEN 'transaction_id'\r\n\t\t\t\t\t\tWHEN pt.v LIKE '{%}'\r\n                            THEN 'transaction_id'\r\n                        ELSE\r\n                            ''''||pt.v||''''\r\n                    END AS v\r\n\t\t\t\t*/\r\n            ) as p\r\n                ON TRUE\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND t.parsed IS NOT NULL;\r\n                \r\n\r\n\tINSERT INTO mytable (lvl,rn)\r\n\t\tVALUES (0,0);\r\n\t\r\n\t_count := 1;\r\n\t\r\n\tWHILE (_count>0) LOOP\r\n\t\tWITH r AS \r\n\t\t(\r\n\t\t\tUPDATE mytable\r\n\t\t\t\tSET parsed = to_json(t.converted)::JSONB \r\n\t\t\t\tFROM \r\n\t\t\t\t(\r\n\t\t\t\t\tSELECT \t\r\n\t\t\t\t\t\t\tres.lvl-1 lvl,\r\n\t\t\t\t\t\t\tres.prev rn,\r\n\t\t\t\t\t\t\tres.op,\r\n\t\t\t\t\t\t\t1 q,\r\n\t\t\t\t\t\t\tCASE COUNT(1) \r\n\t\t\t\t\t\t\t\tWHEN 1\r\n\t\t\t\t\t\t\t\t\tTHEN format('(%s %s)', res.op, min(res.parsed #>> '{}') )\r\n\t\t\t\t\t\t\t\tELSE\r\n\t\t\t\t\t\t\t\t\t'('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op)||')'\r\n\t\t\t\t\t\t\tend AS converted\r\n\t\t\t\t\t\tFROM mytable res \r\n\t\t\t\t\t\t\tWHERE res.parsed IS NOT NULL\r\n\t\t\t\t\t\t\t\tAND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)\r\n\t\t\t\t\t\t\tGROUP BY  res.prev, res.op, res.lvl\r\n\t\t\t\t) t\r\n\t\t\t\tWHERE\r\n\t\t\t\t\tt.lvl = mytable.lvl\r\n\t\t\t\t\t\tAND t.rn = mytable.rn\r\n\t\t\t\tRETURNING 1\r\n\t\t)\r\n\t\t\tSELECT COUNT(*) \r\n\t\t\t\tFROM r\r\n\t\t\t\tINTO _count;\r\n\tEND LOOP;\r\n\t\r\n\tSELECT parsed #>> '{}' \r\n\t\tFROM mytable\r\n\t\t\tWHERE lvl = 0 AND rn = 0\r\n\t\tINTO _res;\r\n\t\r\n\tDROP TABLE mytable;\r\n    RETURN _res;\r\nEND \r\n$function$\n;\nDROP function IF EXISTS reclada_object.parse_filter ;\n\nDROP function IF EXISTS api.reclada_object_list ;\nCREATE OR REPLACE FUNCTION api.reclada_object_list(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    user_info           jsonb;\r\n    result              jsonb;\r\n\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF(class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'list', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.list(data, true) INTO result;\r\n\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\nBEGIN\r\n\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    class := data->>'class';\r\n    _filter = data->'filter';\r\n    IF (class IS NULL and tran_id IS NULL and _filter IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class, transactionID and filter are not specified';\r\n    END IF;\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    IF (jsonb_typeof(order_by_jsonb) != 'array') THEN\r\n    \t\torder_by_jsonb := format('[%s]', order_by_jsonb);\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n    FROM jsonb_array_elements(order_by_jsonb) T\r\n    INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n    IF ((limit_ ~ '(\\D+)') AND (limit_ != 'ALL')) THEN\r\n    \t\tRAISE EXCEPTION 'The limit must be an integer number or "ALL"';\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    IF (offset_ ~ '(\\D+)') THEN\r\n    \t\tRAISE EXCEPTION 'The offset must be an integer number';\r\n    END IF;\r\n\r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSE\r\n        class_uuid := reclada.try_cast_uuid(class);\r\n\r\n        if class_uuid is not null then\r\n            select v.for_class \r\n                from reclada.v_class_lite v\r\n                    where class_uuid = v.obj_id\r\n            into class;\r\n\r\n            IF (class IS NULL) THEN\r\n                RAISE EXCEPTION 'Class not found by GUID: %', class_uuid::text;\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', class) AS condition\r\n                        where class is not null\r\n                            and class_uuid is null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             '\r\n    --             || query\r\n    --             ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    IF gui THEN\r\n\r\n        EXECUTE E'SELECT count(1)\r\n        '|| query\r\n        INTO number_of_objects;\r\n\r\n        EXECUTE E'SELECT TO_CHAR(\r\n\tMAX(\r\n\t\tGREATEST(obj.created_time, (\r\n\t\t\tSELECT TO_TIMESTAMP(MAX(date_time),\\'YYYY-MM-DD hh24:mi:ss.US TZH\\')\r\n\t\t\tFROM reclada.v_revision vr\r\n\t\t\tWHERE vr.obj_id = UUID(obj.attrs ->>\\'revision\\'))\r\n\t\t)\r\n\t),\\'YYYY-MM-DD hh24:mi:ss.MS TZH\\')\r\n        '|| query\r\n        INTO last_change;\r\n\r\n        res := jsonb_build_object(\r\n        'last_change', last_change,    \r\n        'number', number_of_objects,\r\n        'objects', objects);\r\n    ELSE\r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_filter_mapping ;\n\n\nDROP function IF EXISTS reclada_object.datasource_insert ;\nCREATE OR REPLACE FUNCTION reclada_object.datasource_insert(_class_name text, obj_id uuid, attributes jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    dataset       jsonb;\r\n    uri           text;\r\n    environment   varchar;\r\nBEGIN\r\n    IF _class_name in \r\n            ('DataSource','File') THEN\r\n\r\n        SELECT v.data\r\n        FROM reclada.v_active_object v\r\n\t    WHERE v.attrs->>'name' = 'defaultDataSet'\r\n\t    INTO dataset;\r\n\r\n        dataset := jsonb_set(dataset, '{attributes, dataSources}', dataset->'attributes'->'dataSources' || format('["%s"]', obj_id)::jsonb);\r\n\r\n        PERFORM reclada_object.update(dataset);\r\n\r\n        uri := attributes->>'uri';\r\n\r\n        SELECT attrs->>'Environment'\r\n        FROM reclada.v_active_object\r\n        WHERE class_name = 'Context'\r\n        ORDER BY created_time DESC\r\n        LIMIT 1\r\n        INTO environment;\r\n\r\n        PERFORM reclada_object.create(\r\n            format('{\r\n                "class": "Job",\r\n                "attributes": {\r\n                    "task": "c94bff30-15fa-427f-9954-d5c3c151e652",\r\n                    "status": "new",\r\n                    "type": "%s",\r\n                    "command": "./run_pipeline.sh",\r\n                    "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\r\n                    }\r\n                }', environment, uri, obj_id)::jsonb);\r\n\r\n    END IF;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    data          jsonb;\r\n    class_name    text;\r\n    class_uuid    uuid;\r\n    tran_id       bigint;\r\n    _attrs         jsonb;\r\n    schema        jsonb;\r\n    obj_GUID      uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision and others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    FOR data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n\r\n        class_name := data->>'class';\r\n\r\n        IF (class_name IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n        class_uuid := reclada.try_cast_uuid(class_name);\r\n\r\n        _attrs := data->'attributes';\r\n        IF (_attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        tran_id := (data->>'transactionID')::bigint;\r\n        if tran_id is null then\r\n            tran_id := reclada.get_transaction_id();\r\n        end if;\r\n\r\n        IF class_uuid IS NULL THEN\r\n            SELECT reclada_object.get_schema(class_name) \r\n            INTO schema;\r\n            class_uuid := (schema->>'GUID')::uuid;\r\n        ELSE\r\n            SELECT v.data \r\n            FROM reclada.v_class v\r\n            WHERE class_uuid = v.obj_id\r\n            INTO schema;\r\n        END IF;\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', class_name;\r\n        END IF;\r\n\r\n        IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', _attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n        END IF;\r\n        \r\n        IF data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        IF class_uuid IN (SELECT guid FROM reclada.v_PK_for_class)\r\n        THEN\r\n            SELECT o.obj_id\r\n                FROM reclada.v_object o\r\n                JOIN reclada.v_PK_for_class pk\r\n                    on pk.guid = o.class\r\n                        and class_uuid = o.class\r\n                where o.attrs->>pk.pk = _attrs ->> pk.pk\r\n                LIMIT 1\r\n            INTO obj_GUID;\r\n            IF obj_GUID IS NOT NULL THEN\r\n                SELECT reclada_object.update(data || format('{"GUID": "%s"}', obj_GUID)::jsonb)\r\n                    INTO res;\r\n                    RETURN '[]'::jsonb || res;\r\n            END IF;\r\n        END IF;\r\n\r\n        obj_GUID := (data->>'GUID')::uuid;\r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.object \r\n            WHERE GUID = obj_GUID\r\n        ) THEN\r\n            RAISE EXCEPTION 'GUID: % is duplicate', obj_GUID;\r\n        END IF;\r\n        --raise notice 'schema: %',schema;\r\n\r\n        INSERT INTO reclada.object(GUID,class,attributes,transaction_id)\r\n            SELECT  CASE\r\n                        WHEN obj_GUID IS NULL\r\n                            THEN public.uuid_generate_v4()\r\n                        ELSE obj_GUID\r\n                    END AS GUID,\r\n                    class_uuid, \r\n                    _attrs,\r\n                    tran_id\r\n        RETURNING GUID INTO obj_GUID;\r\n        affected := array_append( affected, obj_GUID);\r\n\r\n        PERFORM reclada_object.datasource_insert\r\n            (\r\n                class_name,\r\n                obj_GUID,\r\n                _attrs\r\n            );\r\n\r\n        PERFORM reclada_object.refresh_mv(class_name);\r\n    END LOOP;\r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb; \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            res\r\n        );\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    new_class       text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n    version_         integer;\r\n\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    attrs := data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    new_class = attrs->>'newClass';\r\n\r\n    SELECT reclada_object.get_schema(class) INTO class_schema;\r\n\r\n    IF (class_schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', class;\r\n    END IF;\r\n\r\n    SELECT max(version) + 1\r\n    FROM reclada.v_class_lite v\r\n    WHERE v.for_class = new_class\r\n    INTO version_;\r\n\r\n    version_ := coalesce(version_,1);\r\n    class_schema := class_schema->'attributes'->'schema';\r\n\r\n    PERFORM reclada_object.create(format('{\r\n        "class": "jsonschema",\r\n        "attributes": {\r\n            "forClass": "%s",\r\n            "version": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n            }\r\n        }\r\n    }',\r\n    new_class,\r\n    version_,\r\n    (class_schema->'properties') || (attrs->'properties'),\r\n    (SELECT jsonb_agg(el) FROM (\r\n        SELECT DISTINCT pg_catalog.jsonb_array_elements(\r\n            (class_schema -> 'required') || (attrs -> 'required')\r\n        ) el) arr)\r\n    )::jsonb);\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_condition_array ;\nCREATE OR REPLACE FUNCTION reclada_object.get_condition_array(data jsonb, key_path text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\n    SELECT\r\n    CONCAT(\r\n        key_path,\r\n        ' ', COALESCE(data->>'operator', '='), ' ',\r\n        format(E'\\'%s\\'::jsonb', data->'object'#>>'{}'))\r\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class_name     text;\r\n    class_uuid     uuid;\r\n    v_obj_id       uuid;\r\n    v_attrs        jsonb;\r\n    schema        jsonb;\r\n    old_obj       jsonb;\r\n    branch        uuid;\r\n    revid         uuid;\r\n\r\nBEGIN\r\n\r\n    class_name := data->>'class';\r\n    IF (class_name IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n    class_uuid := reclada.try_cast_uuid(class_name);\r\n    v_obj_id := data->>'GUID';\r\n    IF (v_obj_id IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no GUID';\r\n    END IF;\r\n\r\n    v_attrs := data->'attributes';\r\n    IF (v_attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    SELECT reclada_object.get_schema(class_name) \r\n        INTO schema;\r\n\r\n    if class_uuid is null then\r\n        SELECT reclada_object.get_schema(class_name) \r\n            INTO schema;\r\n    else\r\n        select v.data \r\n            from reclada.v_class v\r\n                where class_uuid = v.obj_id\r\n            INTO schema;\r\n    end if;\r\n    -- TODO: don't allow update jsonschema\r\n    IF (schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', class_name;\r\n    END IF;\r\n\r\n    IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', v_attrs))) THEN\r\n        RAISE EXCEPTION 'JSON invalid: %', v_attrs;\r\n    END IF;\r\n\r\n    SELECT \tv.data\r\n        FROM reclada.v_active_object v\r\n\t        WHERE v.obj_id = v_obj_id\r\n\t    INTO old_obj;\r\n\r\n    IF (old_obj IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object, no such id';\r\n    END IF;\r\n\r\n    branch := data->'branch';\r\n    SELECT reclada_revision.create(user_info->>'sub', branch, v_obj_id) \r\n        INTO revid;\r\n    \r\n    with t as \r\n    (\r\n        update reclada.object o\r\n            set status = reclada_object.get_archive_status_obj_id()\r\n                where o.GUID = v_obj_id\r\n                    and status != reclada_object.get_archive_status_obj_id()\r\n                        RETURNING id\r\n    )\r\n    INSERT INTO reclada.object( GUID,\r\n                                class,\r\n                                status,\r\n                                attributes,\r\n                                transaction_id\r\n                              )\r\n        select  v.obj_id,\r\n                (schema->>'GUID')::uuid,\r\n                reclada_object.get_active_status_obj_id(),--status \r\n                v_attrs || format('{"revision":"%s"}',revid)::jsonb,\r\n                transaction_id\r\n            FROM reclada.v_object v\r\n            JOIN t \r\n                on t.id = v.id\r\n\t            WHERE v.obj_id = v_obj_id;\r\n    PERFORM reclada_object.datasource_insert\r\n            (\r\n                class_name,\r\n                (schema->>'GUID')::uuid,\r\n                v_attrs\r\n            );\r\n    PERFORM reclada_object.refresh_mv(class_name);  \r\n                  \r\n    select v.data \r\n        FROM reclada.v_active_object v\r\n            WHERE v.obj_id = v_obj_id\r\n        into data;\r\n    PERFORM reclada_notification.send_object_notification('update', data);\r\n    RETURN data;\r\nEND;\r\n$function$\n;\n\nDROP INDEX IF EXISTS reclada.parent_guid_index;\nALTER TABLE reclada.object DROP COLUMN IF EXISTS parent_guid;\n\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n WITH t AS (\n         SELECT obj.id,\n            obj.guid,\n            obj.class,\n            r.num,\n            NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n            obj.attributes,\n            obj.status,\n            obj.created_time,\n            obj.created_by,\n            obj.transaction_id\n           FROM object obj\n             LEFT JOIN ( SELECT (r_1.attributes ->> 'num'::text)::bigint AS num,\n                    r_1.guid\n                   FROM object r_1\n                  WHERE (r_1.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class))) r ON r.guid = NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid\n        )\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    t.num AS revision_num,\n    os.caption AS status_caption,\n    t.revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID") tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id\n   FROM t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    (obj.attrs ->> 'version'::text)::bigint AS version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_pk_for_class ;\nCREATE OR REPLACE VIEW reclada.v_pk_for_class\nAS\n SELECT obj.obj_id AS guid,\n    obj.for_class,\n    pk.pk\n   FROM v_class obj\n     JOIN ( SELECT 'File'::text AS class_name,\n            'uri'::text AS pk) pk ON pk.class_name = obj.for_class;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\n\nDROP INDEX IF EXISTS reclada.class_lite_obj_idx;\nDROP INDEX IF EXISTS reclada.class_lite_class_idx;\n\n\nDO $$\nDECLARE\n\trltshp_uuid TEXT;\n\tdds_uuid\tuuid;\n\tdds_rev\t\tuuid;\n\tdds_revn\tint;\n\trlt_cnt\t\tint;\nBEGIN\n\tSELECT obj_id,attrs->>'revision', revision_num\n\tFROM reclada.v_active_object vao \n\tWHERE attrs->>'name' = 'defaultDataSet'\n\t\tINTO dds_uuid, dds_rev, dds_revn;\n\n\tSELECT count(*)\n\tFROM reclada.v_active_object vao\n\tWHERE class_name ='Relationship' AND attrs ->>'type'= 'defaultDataSet to DataSource' and (attrs->>'subject')::uuid=dds_uuid\n\t\tINTO rlt_cnt;\n\t\n\tIF rlt_cnt>0 THEN\n\t\tDELETE FROM reclada.object\n\t\tWHERE guid = dds_uuid AND status = reclada_object.get_active_status_obj_id();\n\n\t\tDELETE FROM reclada.object\n\t\tWHERE guid = dds_rev;\n\n\t\tUPDATE reclada.object\n\t\tSET status = reclada_object.get_active_status_obj_id()\n\t\tWHERE status = reclada_object.get_archive_status_obj_id()\n\t\t\tAND id = (\n\t\t\t\tSELECT id\n\t\t\t\tFROM reclada.v_object\n\t\t\t\tWHERE obj_id = dds_uuid\n\t\t\t\t\tAND revision_num = dds_revn - 1\n\t\t\t);\n\n\t\tDELETE FROM reclada.OBJECT \n\t\tWHERE class=(\n\t\t\tSELECT obj_id \n\t\t\tFROM v_class  \n\t\t\tWHERE for_class ='Relationship'\n\t\t)\n\t\t\tAND ATTRIBUTES->>'type' = 'defaultDataSet to DataSource';\n\tEND IF;\nEND\n$$;	2021-10-25 09:26:50.97148+00
41	40	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 40 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'view/reclada.v_filter_avaliable_operator.sql'\ni 'view/reclada.v_object.sql'\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada.xor.sql'\n\nCREATE OPERATOR # \n(\n    PROCEDURE = reclada.xor, \n    LEFTARG = boolean, \n    RIGHTARG = boolean\n);\n\nupdate reclada.object\n    set attributes = '\n{\n    "schema": {\n        "type": "object",\n        "required": [\n            "command",\n            "status",\n            "type",\n            "task",\n            "environment"\n        ],\n        "properties": {\n            "tags": {\n                "type": "array",\n                "items": {\n                    "type": "string"\n                }\n            },\n            "platformRunnerID": {\n                "type": "string"\n            },\n            "task": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "type": {\n                "type": "string"\n            },\n            "runner": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "status": {\n                "type": "string",\n                "enum ": [\n                    "up",\n                    "down",\n                    "idle"\n                ]\n            },\n            "command": {\n                "type": "string"\n            },\n            "environment": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "inputParameters": {\n                "type": "array",\n                "items": {\n                    "type": "object"\n                }\n            },\n            "outputParameters": {\n                "type": "array",\n                "items": {\n                    "type": "object"\n                }\n            }\n        }\n    },\n    "version": "1",\n    "forClass": "Runner"\n}'::jsonb\n    where class = reclada_object.get_jsonschema_GUID() \n        and attributes->>'forClass' = 'Runner';\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\ndrop OPERATOR IF EXISTS #(boolean, boolean);\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_pk_for_class;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\n\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition_filter(data jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE \r\n    _count   INT;\r\n    _res     TEXT;\r\nBEGIN \r\n    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE\r\n    CREATE TEMP TABLE mytable AS\r\n        SELECT  lvl             ,  rn   , idx  ,\r\n                upper(op) as op ,  prev , val  ,  \r\n                parsed\r\n            FROM reclada_object.parse_filter(data);\r\n\r\n    UPDATE mytable u\r\n        SET parsed = to_jsonb(p.v)\r\n            FROM mytable t\r\n            JOIN LATERAL \r\n            (\r\n                SELECT  t.parsed #>> '{}' v\r\n            ) as pt\r\n                ON TRUE\r\n            LEFT JOIN reclada.v_filter_mapping fm\r\n                ON pt.v = fm.pattern\r\n            JOIN LATERAL \r\n            (\r\n                SELECT CASE \r\n                        WHEN fm.repl is not NULL \r\n                            then '(''"''||' ||fm.repl ||'||''"'')::jsonb' -- don't use FORMAT (concat null)\r\n                        -- WHEN pt.v LIKE '{attributes,%}'\r\n                        --     THEN format('attrs #> ''%s''', REPLACE(pt.v,'{attributes,','{'))\r\n                        WHEN jsonb_typeof(t.parsed) in ('number', 'boolean')\r\n                            then \r\n                                case \r\n                                    when t.op IN (' + ')\r\n                                        then pt.v\r\n                                    else '''' || pt.v || '''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'string' \r\n                            then    \r\n                                case\r\n                                    WHEN pt.v LIKE '{%}' \r\n                                        THEN\r\n                                            case\r\n                                                when t.op IN (' LIKE ', ' NOT LIKE ', ' || ', ' ~ ', ' !~ ', ' ~* ', ' !~* ', ' SIMILAR TO ')\r\n                                                    then format('(data #>> ''%s'')', pt.v)\r\n                                                when t.op IN (' + ')\r\n                                                    then format('(data #> ''%s'')::decimal', pt.v)\r\n                                                else\r\n                                                    format('data #> ''%s''', pt.v)\r\n                                            end\r\n                                    when t.op IN (' LIKE ', ' NOT LIKE ', ' || ', ' ~ ', ' !~ ', ' ~* ', ' !~* ', ' SIMILAR TO ')\r\n                                        then ''''||REPLACE(pt.v,'''','''''')||''''\r\n                                    else\r\n                                        '''"'||REPLACE(pt.v,'''','''''')||'"''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'null'\r\n                            then 'null'\r\n                        WHEN jsonb_typeof(t.parsed) = 'array'\r\n                            then ''''||REPLACE(pt.v,'''','''''')||'''::jsonb'\r\n                        ELSE\r\n                            pt.v\r\n                    END AS v\r\n            ) as p\r\n                ON TRUE\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND t.parsed IS NOT NULL;\r\n                \r\n\r\n    INSERT INTO mytable (lvl,rn)\r\n        VALUES (0,0);\r\n    \r\n    _count := 1;\r\n    \r\n    WHILE (_count>0) LOOP\r\n        WITH r AS \r\n        (\r\n            UPDATE mytable\r\n                SET parsed = to_json(t.converted)::JSONB \r\n                FROM \r\n                (\r\n                    SELECT     \r\n                            res.lvl-1 lvl,\r\n                            res.prev rn,\r\n                            res.op,\r\n                            1 q,\r\n                            CASE COUNT(1) \r\n                                WHEN 1\r\n                                    THEN format('(%s %s)', res.op, min(res.parsed #>> '{}') )\r\n                                ELSE\r\n                                    CASE \r\n                                        when res.op in (' || ')\r\n                                            then '(''"''||'||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op)||'||''"'')::jsonb'\r\n                                        when res.op in (' + ')\r\n                                            then '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op)||')::text::jsonb'\r\n                                        else\r\n                                            '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op)||')'\r\n                                    end\r\n                            end AS converted\r\n                        FROM mytable res \r\n                            WHERE res.parsed IS NOT NULL\r\n                                AND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)\r\n                            GROUP BY  res.prev, res.op, res.lvl\r\n                ) t\r\n                WHERE\r\n                    t.lvl = mytable.lvl\r\n                        AND t.rn = mytable.rn\r\n                RETURNING 1\r\n        )\r\n            SELECT COUNT(1) \r\n                FROM r\r\n                INTO _count;\r\n    END LOOP;\r\n    \r\n    SELECT parsed #>> '{}' \r\n        FROM mytable\r\n            WHERE lvl = 0 AND rn = 0\r\n        INTO _res;\r\n    perform reclada.raise_notice( _res);\r\n    DROP TABLE mytable;\r\n    RETURN _res;\r\nEND \r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\nBEGIN\r\n\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    class := data->>'class';\r\n    _filter = data->'filter';\r\n    IF (class IS NULL and tran_id IS NULL and _filter IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class, transactionID and filter are not specified';\r\n    END IF;\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    IF (jsonb_typeof(order_by_jsonb) != 'array') THEN\r\n    \t\torder_by_jsonb := format('[%s]', order_by_jsonb);\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n    FROM jsonb_array_elements(order_by_jsonb) T\r\n    INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n    IF ((limit_ ~ '(\\D+)') AND (limit_ != 'ALL')) THEN\r\n    \t\tRAISE EXCEPTION 'The limit must be an integer number or "ALL"';\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    IF (offset_ ~ '(\\D+)') THEN\r\n    \t\tRAISE EXCEPTION 'The offset must be an integer number';\r\n    END IF;\r\n\r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSE\r\n        class_uuid := reclada.try_cast_uuid(class);\r\n\r\n        if class_uuid is not null then\r\n            select v.for_class \r\n                from reclada.v_class_lite v\r\n                    where class_uuid = v.obj_id\r\n            into class;\r\n\r\n            IF (class IS NULL) THEN\r\n                RAISE EXCEPTION 'Class not found by GUID: %', class_uuid::text;\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', class) AS condition\r\n                        where class is not null\r\n                            and class_uuid is null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             '\r\n    --             || query\r\n    --             ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    IF gui THEN\r\n\r\n        EXECUTE E'SELECT count(1)\r\n        '|| query\r\n        INTO number_of_objects;\r\n\r\n        EXECUTE E'SELECT TO_CHAR(\r\n\tMAX(\r\n\t\tGREATEST(obj.created_time, (\r\n\t\t\tSELECT TO_TIMESTAMP(MAX(date_time),\\'YYYY-MM-DD hh24:mi:ss.US TZH\\')\r\n\t\t\tFROM reclada.v_revision vr\r\n\t\t\tWHERE vr.obj_id = UUID(obj.attrs ->>\\'revision\\'))\r\n\t\t)\r\n\t),\\'YYYY-MM-DD hh24:mi:ss.MS TZH\\')\r\n        '|| query\r\n        INTO last_change;\r\n\r\n        res := jsonb_build_object(\r\n        'last_change', last_change,    \r\n        'number', number_of_objects,\r\n        'objects', objects);\r\n    ELSE\r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_filter_avaliable_operator ;\n\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n WITH t AS (\n         SELECT obj.id,\n            obj.guid,\n            obj.class,\n            r.num,\n            NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n            obj.attributes,\n            obj.status,\n            obj.created_time,\n            obj.created_by,\n            obj.transaction_id,\n            obj.parent_guid\n           FROM object obj\n             LEFT JOIN ( SELECT (r_1.attributes ->> 'num'::text)::bigint AS num,\n                    r_1.guid\n                   FROM object r_1\n                  WHERE (r_1.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class))) r ON r.guid = NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid\n        )\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    t.num AS revision_num,\n    os.caption AS status_caption,\n    t.revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID",\n                    t.parent_guid) tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id,\n    t.parent_guid\n   FROM t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id,\n    t.parent_guid\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    (obj.attrs ->> 'version'::text)::bigint AS version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_pk_for_class ;\nCREATE OR REPLACE VIEW reclada.v_pk_for_class\nAS\n SELECT obj.obj_id AS guid,\n    obj.for_class,\n    pk.pk\n   FROM v_class obj\n     JOIN ( SELECT 'File'::text AS class_name,\n            'uri'::text AS pk) pk ON pk.class_name = obj.for_class;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\nDROP function IF EXISTS reclada.xor ;\n\n\nupdate reclada.object\n    set attributes = '\n{\n    "schema": {\n        "type": "object",\n        "required": [\n            "command",\n            "status",\n            "type",\n            "task",\n            "environment"\n        ],\n        "properties": {\n            "tags": {\n                "type": "array",\n                "items": {\n                    "type": "string"\n                }\n            },\n            "task": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "type": {\n                "type": "string"\n            },\n            "runner": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "status": {\n                "type": "string",\n                "enum ": [\n                    "up",\n                    "down",\n                    "idle"\n                ]\n            },\n            "command": {\n                "type": "string"\n            },\n            "environment": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "inputParameters": {\n                "type": "array",\n                "items": {\n                    "type": "object"\n                }\n            },\n            "outputParameters": {\n                "type": "array",\n                "items": {\n                    "type": "object"\n                }\n            }\n        }\n    },\n    "version": "1",\n    "forClass": "Runner"\n}'::jsonb\n    where class = reclada_object.get_jsonschema_GUID() \n        and attributes->>'forClass' = 'Runner';	2021-10-28 10:54:15.658385+00
42	41	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 41 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\n\ni 'view/reclada.v_PK_for_class.sql'\ni 'view/reclada.v_DTO_json_schema.sql'\ni 'view/reclada.v_filter_between.sql'\n\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DTOJsonSchema",\n        "properties": {\n            "function": {"type": "string"},\n            "schema":{"type": "object"}\n        },\n        "required": ["function","schema"]\n    }\n}'::jsonb);\n\nSELECT reclada_object.create(\n    '{\n        "class": "DTOJsonSchema",\n        "attributes": {\n            "function":"reclada_object.get_query_condition_filter",\n            "schema":{\n                "type": "object",\n                "id": "expr",\n                "properties": {\n                    "value": {\n                        "type": "array",\n                        "items": {\n                            "anyOf": [\n                                {\n                                    "type": "string"\n                                },\n                                {\n                                    "type": "null"\n                                },\n                                {\n                                    "type": "number"\n                                },\n                                {\n                                    "$ref": "expr"\n                                },\n                                {\n                                    "type": "array",\n                                    "items":{\n                                        "anyOf": [\n                                            {\n                                                "type": "string"\n                                            },\n                                            {\n                                                "type": "number"\n                                            }\n                                        ]\n                                    }\n                                }\n                            ]\n                        },\n                        "minItems": 1\n                    },\n                    "operator": {\n                        "type": "string"\n                    }\n                },\n                "required": ["value","operator"]\n            }\n        }\n    }'\n);\n\ni 'function/reclada.validate_json.sql'\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/api.reclada_object_list.sql'\n\nSELECT reclada_object.create(\n    '{\n        "class": "DTOJsonSchema",\n        "attributes": {\n            "function":"reclada_object.list",\n            "schema":{\n                "type": "object",\n                "properties": {\n                    "transactionID": {\n                        "type": "integer"\n                    },\n                    "class": {\n                        "type": "string"\n                    },\n                    "filter": {\n                        "type": "object"\n                    },\n                    "orderBy":{\n                        "type": "array",\n                        "items":{\n                            "type":"object",\n                            "properties": {\n                                "field":{\n                                    "type":"string"\n                                },\n                                "order":{\n                                    "type":"string",\n                                    "enum": ["ASC", "DESC"]\n                                }\n                            },\n                            "required": ["field"]\n                        }\n                    },\n                    "limit":{\n                        "anyOf": [\n                            {\n                                "type": "string",\n                                "enum": ["ALL"]\n                            },\n                            {\n                                "type": "integer"\n                            }\n                        ]\n                    },\n                    "offset":{\n                        "type": "integer"\n                    }\n                },\n                "anyOf": [\n                    {\n                        "required": [\n                            "transactionID"\n                        ]\n                    },\n                    {\n                        "required": [\n                            "class"\n                        ]\n                    },\n                    {\n                        "required": [\n                            "filter"\n                        ]\n                    }\n                ]\n            }\n        }\n    }'\n);\n\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.parse_filter.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_filter_avaliable_operator.sql'\ni 'view/reclada.v_filter_inner_operator.sql'\n\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\nDROP view IF EXISTS reclada.v_pk_for_class ;\nCREATE OR REPLACE VIEW reclada.v_pk_for_class\nAS\n SELECT obj.obj_id AS guid,\n    obj.for_class,\n    pk.pk\n   FROM v_class obj\n     JOIN ( SELECT 'File'::text AS class_name,\n            'uri'::text AS pk) pk ON pk.class_name = obj.for_class;\nDROP view IF EXISTS reclada.v_DTO_json_schema ;\n\n\ndelete from reclada.object \n    where class in (select reclada_object.get_GUID_for_class('DTOJsonSchema'));\n\ndelete from reclada.object \n    where guid in (select reclada_object.get_GUID_for_class('DTOJsonSchema'));\n\nDROP function IF EXISTS reclada.validate_json ;\n\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition_filter(data jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE \r\n    _count   INT;\r\n    _res     TEXT;\r\nBEGIN \r\n    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE\r\n    CREATE TEMP TABLE mytable AS\r\n        SELECT  lvl             ,  rn   , idx  ,\r\n                upper(op) as op ,  prev , val  ,  \r\n                parsed\r\n            FROM reclada_object.parse_filter(data);\r\n\r\n    PERFORM reclada.raise_exception('operator does not allowed ' || t.op,'reclada_object.get_query_condition_filter')\r\n        FROM mytable t\r\n        LEFT JOIN reclada.v_filter_avaliable_operator op\r\n            ON t.op = op.operator\r\n            WHERE op.operator IS NULL;\r\n\r\n    UPDATE mytable u\r\n        SET parsed = to_jsonb(p.v)\r\n            FROM mytable t\r\n            left join reclada.v_filter_avaliable_operator o\r\n                on o.operator = t.op\r\n            JOIN LATERAL \r\n            (\r\n                SELECT  t.parsed #>> '{}' v\r\n            ) as pt\r\n                ON TRUE\r\n            LEFT JOIN reclada.v_filter_mapping fm\r\n                ON pt.v = fm.pattern\r\n            JOIN LATERAL \r\n            (\r\n                SELECT CASE \r\n                        WHEN fm.repl is not NULL \r\n                            then '(''"''||' ||fm.repl ||'||''"'')::jsonb' -- don't use FORMAT (concat null)\r\n                        -- WHEN pt.v LIKE '{attributes,%}'\r\n                        --     THEN format('attrs #> ''%s''', REPLACE(pt.v,'{attributes,','{'))\r\n                        WHEN jsonb_typeof(t.parsed) in ('number', 'boolean')\r\n                            then \r\n                                case \r\n                                    when o.input_type in ('NUMERIC','INT')\r\n                                        then pt.v\r\n                                    else '''' || pt.v || '''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'string' \r\n                            then    \r\n                                case\r\n                                    WHEN pt.v LIKE '{%}'\r\n                                        THEN\r\n                                            case\r\n                                                when o.input_type = 'TEXT'\r\n                                                    then format('(data #>> ''%s'')', pt.v)\r\n                                                when o.input_type = 'NUMERIC'\r\n                                                    then format('(data #>> ''%s'')::NUMERIC', pt.v)\r\n                                                when o.input_type = 'INT'\r\n                                                    then format('(data #>> ''%s'')::INT', pt.v)\r\n                                                else\r\n                                                    format('data #> ''%s''', pt.v)\r\n                                            end\r\n                                    when o.input_type = 'TEXT'\r\n                                        then ''''||REPLACE(pt.v,'''','''''')||''''\r\n                                    else\r\n                                        '''"'||REPLACE(pt.v,'''','''''')||'"''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'null'\r\n                            then 'null'\r\n                        WHEN jsonb_typeof(t.parsed) = 'array'\r\n                            then ''''||REPLACE(pt.v,'''','''''')||'''::jsonb'\r\n                        ELSE\r\n                            pt.v\r\n                    END AS v\r\n            ) as p\r\n                ON TRUE\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND t.parsed IS NOT NULL;\r\n                \r\n\r\n    INSERT INTO mytable (lvl,rn)\r\n        VALUES (0,0);\r\n    \r\n    _count := 1;\r\n    \r\n    WHILE (_count>0) LOOP\r\n        WITH r AS \r\n        (\r\n            UPDATE mytable\r\n                SET parsed = to_json(t.converted)::JSONB \r\n                FROM \r\n                (\r\n                    SELECT     \r\n                            res.lvl-1 lvl,\r\n                            res.prev rn,\r\n                            res.op,\r\n                            1 q,\r\n                            CASE COUNT(1) \r\n                                WHEN 1\r\n                                    THEN \r\n                                        CASE o.output_type\r\n                                            when 'NUMERIC'\r\n                                                then format('(%s %s)::TEXT::JSONB', res.op, min(res.parsed #>> '{}') )\r\n                                            else \r\n                                                format('(%s %s)', res.op, min(res.parsed #>> '{}') )\r\n                                        end\r\n                                ELSE\r\n                                    CASE \r\n                                        when o.output_type = 'TEXT'\r\n                                            then '(''"''||'||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op)||'||''"'')::JSONB'\r\n                                        when o.output_type in ('NUMERIC','INT')\r\n                                            then '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op)||')::TEXT::JSONB'\r\n                                        else\r\n                                            '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op)||')'\r\n                                    end\r\n                            end AS converted\r\n                        FROM mytable res \r\n                        LEFT JOIN reclada.v_filter_avaliable_operator o\r\n                            ON o.operator = res.op\r\n                            WHERE res.parsed IS NOT NULL\r\n                                AND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)\r\n                            GROUP BY  res.prev, res.op, res.lvl, o.input_type, o.output_type\r\n                ) t\r\n                WHERE\r\n                    t.lvl = mytable.lvl\r\n                        AND t.rn = mytable.rn\r\n                RETURNING 1\r\n        )\r\n            SELECT COUNT(1) \r\n                FROM r\r\n                INTO _count;\r\n    END LOOP;\r\n    \r\n    SELECT parsed #>> '{}' \r\n        FROM mytable\r\n            WHERE lvl = 0 AND rn = 0\r\n        INTO _res;\r\n    perform reclada.raise_notice( _res);\r\n    DROP TABLE mytable;\r\n    RETURN _res;\r\nEND \r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_list ;\nCREATE OR REPLACE FUNCTION api.reclada_object_list(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    user_info           jsonb;\r\n    result              jsonb;\r\n    _filter             jsonb;\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF(class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    _filter = data->'filter';\r\n\r\n    select format(  '{\r\n                        "filter":\r\n                        {\r\n                            "operator":"AND",\r\n                            "value":[\r\n                                {\r\n                                    "operator":"=",\r\n                                    "value":["{class}","%s"]\r\n                                },\r\n                                %s\r\n                            ]\r\n                        }\r\n                    }',\r\n            class,\r\n            _filter\r\n        )::jsonb \r\n        into _filter;\r\n    data := data || _filter;\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'list', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.list(data, true) INTO result;\r\n\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\nBEGIN\r\n\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    class := data->>'class';\r\n    _filter = data->'filter';\r\n    IF (class IS NULL and tran_id IS NULL and _filter IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class, transactionID and filter are not specified';\r\n    END IF;\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    IF (jsonb_typeof(order_by_jsonb) != 'array') THEN\r\n    \t\torder_by_jsonb := format('[%s]', order_by_jsonb);\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(ord.v, 'ASC')),\r\n        ' , ')\r\n    FROM jsonb_array_elements(order_by_jsonb) T\r\n    LEFT JOIN LATERAL\r\n    (\r\n        select upper(T.value->>'order') v\r\n    ) ord on true\r\n    LEFT JOIN LATERAL\r\n    (\r\n        SELECT reclada.raise_exception('order does not allowed '|| ord.v,'reclada_object.list')\r\n            where ord.v not in ('ASC', 'DESC')\r\n    ) V on true\r\n    INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n    IF ((limit_ ~ '(\\D+)') AND (limit_ != 'ALL')) THEN\r\n    \t\tRAISE EXCEPTION 'The limit must be an integer number or "ALL"';\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    IF (offset_ ~ '(\\D+)') THEN\r\n    \t\tRAISE EXCEPTION 'The offset must be an integer number';\r\n    END IF;\r\n\r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSE\r\n        class_uuid := reclada.try_cast_uuid(class);\r\n\r\n        if class_uuid is not null then\r\n            select v.for_class \r\n                from reclada.v_class_lite v\r\n                    where class_uuid = v.obj_id\r\n            into class;\r\n\r\n            IF (class IS NULL) THEN\r\n                RAISE EXCEPTION 'Class not found by GUID: %', class_uuid::text;\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', class) AS condition\r\n                        where class is not null\r\n                            and class_uuid is null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             '\r\n    --             || query\r\n    --             ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    IF gui THEN\r\n\r\n        EXECUTE E'SELECT count(1)\r\n        '|| query\r\n        INTO number_of_objects;\r\n\r\n        EXECUTE E'SELECT TO_CHAR(\r\n\tMAX(\r\n\t\tGREATEST(obj.created_time, (\r\n\t\t\tSELECT TO_TIMESTAMP(MAX(date_time),\\'YYYY-MM-DD hh24:mi:ss.US TZH\\')\r\n\t\t\tFROM reclada.v_revision vr\r\n\t\t\tWHERE vr.obj_id = UUID(obj.attrs ->>\\'revision\\'))\r\n\t\t)\r\n\t),\\'YYYY-MM-DD hh24:mi:ss.MS TZH\\')\r\n        '|| query\r\n        INTO last_change;\r\n\r\n        res := jsonb_build_object(\r\n        'last_change', last_change,    \r\n        'number', number_of_objects,\r\n        'objects', objects);\r\n    ELSE\r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.parse_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.parse_filter(data jsonb)\n RETURNS TABLE(lvl integer, rn bigint, idx bigint, op text, prev bigint, val jsonb, parsed jsonb)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\n    WITH RECURSIVE f AS \r\n    (\r\n        SELECT data AS v\r\n    ),\r\n    pr AS \r\n    (\r\n        SELECT \tformat(' %s ',f.v->>'operator') AS op, \r\n                val.v AS val,\r\n                1 AS lvl,\r\n                row_number() OVER(ORDER BY idx) AS rn,\r\n                val.idx idx,\r\n                0::BIGINT prev\r\n            FROM f, jsonb_array_elements(f.v->'value') WITH ordinality AS val(v, idx)\r\n    ),\r\n    res AS\r\n    (\t\r\n        SELECT \tpr.lvl\t,\r\n                pr.rn\t,\r\n                pr.idx  ,\r\n                pr.op\t,\r\n                pr.prev ,\r\n                pr.val\t,\r\n                CASE jsonb_typeof(pr.val) \r\n                    WHEN 'object'\t\r\n                        THEN NULL\r\n                    ELSE pr.val\r\n                END AS parsed\r\n            FROM pr\r\n            WHERE prev = 0 \r\n                AND lvl = 1\r\n        UNION ALL\r\n        SELECT \tttt.lvl\t,\r\n                ROW_NUMBER() OVER(ORDER BY ttt.idx) AS rn,\r\n                ttt.idx,\r\n                ttt.op\t,\r\n                ttt.prev,\r\n                ttt.val ,\r\n                CASE jsonb_typeof(ttt.val) \r\n                    WHEN 'object'\t\r\n                        THEN NULL\r\n                    ELSE ttt.val\r\n                end AS parsed\r\n            FROM\r\n            (\r\n                SELECT \tres.lvl + 1 AS lvl,\r\n                        format(' %s ',res.val->>'operator') AS op,\r\n                        res.rn AS prev\t,\r\n                        val.v  AS val,\r\n                        val.idx\r\n                    FROM res, \r\n                         jsonb_array_elements(res.val->'value') WITH ordinality AS val(v, idx)\r\n            ) ttt\r\n    )\r\n    SELECT \tr.lvl\t,\r\n            r.rn\t,\r\n            r.idx   ,\r\n            r.op\t,\r\n            r.prev  ,\r\n            r.val\t,\r\n            r.parsed\r\n        FROM res r\r\n$function$\n;\n\n\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_pk_for_class;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\n\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n WITH t AS (\n         SELECT obj.id,\n            obj.guid,\n            obj.class,\n            r.num,\n            NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n            obj.attributes,\n            obj.status,\n            obj.created_time,\n            obj.created_by,\n            obj.transaction_id,\n            obj.parent_guid\n           FROM object obj\n             LEFT JOIN ( SELECT (r_1.attributes ->> 'num'::text)::bigint AS num,\n                    r_1.guid\n                   FROM object r_1\n                  WHERE (r_1.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class))) r ON r.guid = NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid\n        )\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    t.num AS revision_num,\n    os.caption AS status_caption,\n    t.revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID",\n                    t.parent_guid AS "parentGUID") tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id,\n    t.parent_guid\n   FROM t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id,\n    t.parent_guid\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    (obj.attrs ->> 'version'::text)::bigint AS version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_pk_for_class ;\nCREATE OR REPLACE VIEW reclada.v_pk_for_class\nAS\n SELECT obj.obj_id AS guid,\n    obj.for_class,\n    pk.pk\n   FROM v_class obj\n     JOIN ( SELECT 'File'::text AS class_name,\n            'uri'::text AS pk) pk ON pk.class_name = obj.for_class;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\nDROP view IF EXISTS reclada.v_filter_between ;\n\n\nDROP view IF EXISTS reclada.v_filter_avaliable_operator ;\nCREATE OR REPLACE VIEW reclada.v_filter_avaliable_operator\nAS\n SELECT ' = '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' LIKE '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' NOT LIKE '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' || '::text AS operator,\n    'TEXT'::text AS input_type,\n    'TEXT'::text AS output_type\nUNION\n SELECT ' ~ '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' !~ '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' ~* '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' !~* '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' SIMILAR TO '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' > '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' < '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' <= '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' != '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' >= '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' AND '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' OR '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' NOT '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' # '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' IS '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' IS NOT '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' IN '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' , '::text AS operator,\n    'TEXT'::text AS input_type,\n    NULL::text AS output_type\nUNION\n SELECT ' @> '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' <@ '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type\nUNION\n SELECT ' + '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' - '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' * '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' / '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' % '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' ^ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' |/ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' ||/ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' !! '::text AS operator,\n    'INT'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' @ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type\nUNION\n SELECT ' & '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type\nUNION\n SELECT ' | '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type\nUNION\n SELECT ' << '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type\nUNION\n SELECT ' >> '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type;\nDROP view IF EXISTS reclada.v_filter_inner_operator ;\n	2021-11-08 11:01:49.274513+00
43	42	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 42 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.datasource_insert.sql'\ni 'view/reclada.v_task.sql'\ni 'view/reclada.v_pk_for_class.sql'\ni 'view/reclada.v_object.sql'\n\n\nSELECT reclada_object.create_subclass('{\n    "class": "Task",\n    "attributes": {\n        "newClass": "PipelineLite",\n        "properties": {\n            "tasks": {\n                "items": {\n                    "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}",\n                    "type": "string"\n                },\n                "type": "array",\n                "minItems": 1\n            }\n        },\n        "required": ["tasks"]\n    }\n}'::jsonb);\n\nselect reclada_object.create(('{\n    "GUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "class":"PipelineLite",\n    "attributes":{\n        "command":"",\n        "type":"pipelineLite",\n        "tasks":[\n                    "cc7b41e6-4d57-4e6f-9d10-6da0d5a4c39e",\n                    "618b967b-f2ff-4f3b-8889-b63eb6b73b6e",\n                    "678bbbcc-a6db-425b-b9cd-bdb302c8d290",\n                    "638c7f45-ad21-4b59-a89d-5853aa9ad859",\n                    "2d6b0afc-fdf0-4b54-8a67-704da585196e",\n                    "ff3d88e2-1dd9-43b3-873f-75e4dc3c0629",\n                    "83fbb176-adb7-4da0-bd1f-4ce4aba1b87a",\n                    "27de6e85-1749-4946-8a53-4316321fc1e8",\n                    "4478768c-0d01-4ad9-9a10-2bef4d4b8007"'/*,\n                    "35e5bce3-6578-41ae-a7e2-d20b9a19ba00",\n                    "b68040ff-2f37-42da-b865-8edf589acdaa"*/||'\n        ]\n    }\n}')::jsonb);\n/*\n{\n    "pipeline": [\n        {"stage": "0", "command": "./pipeline/create_pipeline.sh"},\n        {"stage": "1", "command": "./pipeline/copy_file_from_s3.sh"},\n        {"stage": "2", "command": "./pipeline/badgerdoc_run.sh"},\n        {"stage": "3", "command": "./pipeline/bd2reclada_run.sh"},\n        {"stage": "4", "command": "./pipeline/loading_data_to_db.sh"},\n        {"stage": "5", "command": "./pipeline/scinlp_run.sh"},\n        {"stage": "6", "command": "./pipeline/loading_results_to_db.sh"},\n        {"stage": "7", "command": "./pipeline/custom_task.sh"},\n        {"stage": "8", "command": "./pipeline/coping_results.sh"}\n    ]\n}\n*/\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"cc7b41e6-4d57-4e6f-9d10-6da0d5a4c39e",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/create_pipeline.sh",\n        "type":"PipelineLite stage 0"\n    }\n}'::jsonb);\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"618b967b-f2ff-4f3b-8889-b63eb6b73b6e",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/copy_file_from_s3.sh",\n        "type":"PipelineLite stage 1"\n    }\n}'::jsonb);\n\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"678bbbcc-a6db-425b-b9cd-bdb302c8d290",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/badgerdoc_run.sh",\n        "type":"PipelineLite stage 2"\n    }\n}'::jsonb);\n\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"638c7f45-ad21-4b59-a89d-5853aa9ad859",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/bd2reclada_run.sh",\n        "type":"PipelineLite stage 3"\n    }\n}'::jsonb);\n\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"2d6b0afc-fdf0-4b54-8a67-704da585196e",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/loading_data_to_db.sh",\n        "type":"PipelineLite stage 4"\n    }\n}'::jsonb);\n\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"ff3d88e2-1dd9-43b3-873f-75e4dc3c0629",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/scinlp_run.sh",\n        "type":"PipelineLite stage 5"\n    }\n}'::jsonb);\n\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"83fbb176-adb7-4da0-bd1f-4ce4aba1b87a",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/loading_results_to_db.sh",\n        "type":"PipelineLite stage 6"\n    }\n}'::jsonb);\n\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"27de6e85-1749-4946-8a53-4316321fc1e8",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/custom_task.sh",\n        "type":"PipelineLite stage 7"\n    }\n}'::jsonb);\n\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"4478768c-0d01-4ad9-9a10-2bef4d4b8007",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"./pipeline/coping_results.sh",\n        "type":"PipelineLite stage 8"\n    }\n}'::jsonb);\n/*\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"35e5bce3-6578-41ae-a7e2-d20b9a19ba00",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"",\n        "type":"PipelineLite step 10"\n    }\n}'::jsonb);\n\nselect reclada_object.create('{\n    "class":"Task",\n    "GUID":"b68040ff-2f37-42da-b865-8edf589acdaa",\n    "parentGUID":"57ca1d46-146b-4bbb-8f4d-b620c4e62d93",\n    "attributes":{\n        "command":"",\n        "type":"PipelineLite step 11"\n    }\n}'::jsonb);\n\n*/\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\nDROP function IF EXISTS reclada_object.datasource_insert ;\nCREATE OR REPLACE FUNCTION reclada_object.datasource_insert(_class_name text, _obj_id uuid, attributes jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    dataset_guid  uuid;\r\n    uri           text;\r\n    environment   varchar;\r\n    rel_cnt       int;\r\n    dataset2ds_type text;\r\nBEGIN\r\n    IF _class_name in \r\n            ('DataSource','File') THEN\r\n\r\n        dataset2ds_type := 'defaultDataSet to DataSource';\r\n\r\n        SELECT v.obj_id\r\n        FROM reclada.v_active_object v\r\n\t    WHERE v.attrs->>'name' = 'defaultDataSet'\r\n\t    INTO dataset_guid;\r\n\r\n        SELECT count(*)\r\n        FROM reclada.v_active_object\r\n        WHERE class_name = 'Relationship'\r\n            AND (attrs->>'object')::uuid = _obj_id\r\n            AND (attrs->>'subject')::uuid = dataset_guid\r\n            AND attrs->>'type' = dataset2ds_type\r\n                INTO rel_cnt;\r\n\r\n        IF rel_cnt=0 THEN\r\n            PERFORM reclada_object.create(\r\n                format('{\r\n                    "class": "Relationship",\r\n                    "attributes": {\r\n                        "type": "%s",\r\n                        "object": "%s",\r\n                        "subject": "%s"\r\n                        }\r\n                    }', dataset2ds_type, _obj_id, dataset_guid)::jsonb);\r\n\r\n        END IF;\r\n\r\n        uri := attributes->>'uri';\r\n\r\n        SELECT attrs->>'Environment'\r\n        FROM reclada.v_active_object\r\n        WHERE class_name = 'Context'\r\n        ORDER BY created_time DESC\r\n        LIMIT 1\r\n        INTO environment;\r\n\r\n        PERFORM reclada_object.create(\r\n            format('{\r\n                "class": "Job",\r\n                "attributes": {\r\n                    "task": "c94bff30-15fa-427f-9954-d5c3c151e652",\r\n                    "status": "new",\r\n                    "type": "%s",\r\n                    "command": "./run_pipeline.sh",\r\n                    "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\r\n                    }\r\n                }', environment, uri, _obj_id)::jsonb);\r\n\r\n    END IF;\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_task ;\n\nDROP view IF EXISTS reclada.v_pk_for_class ;\nCREATE OR REPLACE VIEW reclada.v_pk_for_class\nAS\n SELECT obj.obj_id AS guid,\n    obj.for_class,\n    pk.pk\n   FROM v_class obj\n     JOIN ( SELECT 'File'::text AS class_name,\n            'uri'::text AS pk\n        UNION\n         SELECT 'DTOJsonSchema'::text AS text,\n            'function'::text AS text) pk ON pk.class_name = obj.for_class;\n\ndelete from reclada.object \n    where class in (select reclada_object.get_GUID_for_class('PipelineLite'));\n\ndelete from reclada.object \n    where class in (select reclada_object.get_GUID_for_class('Task'))\n        and attributes ->> 'type'    like 'PipelineLite stage %'\n        and attributes ->> 'command' like './pipeline/%';\n\ndelete from reclada.object\n    where class = reclada_object.get_jsonschema_GUID()\n        and attributes ->> 'forClass' = 'PipelineLite';\n\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_dto_json_schema;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_pk_for_class;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\n\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n WITH t AS (\n         SELECT obj.id,\n            obj.guid,\n            obj.class,\n            r.num,\n            NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n            obj.attributes,\n            obj.status,\n            obj.created_time,\n            obj.created_by,\n            obj.transaction_id,\n            obj.parent_guid\n           FROM object obj\n             LEFT JOIN ( SELECT (r_1.attributes ->> 'num'::text)::bigint AS num,\n                    r_1.guid\n                   FROM object r_1\n                  WHERE (r_1.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class))) r ON r.guid = NULLIF(obj.attributes ->> 'revision'::text, ''::text)::uuid\n        )\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    t.num AS revision_num,\n    os.caption AS status_caption,\n    t.revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID",\n                    t.parent_guid AS "parentGUID",\n                    t.created_time AS "createdTime") tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id,\n    t.parent_guid\n   FROM t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id,\n    t.parent_guid\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    (obj.attrs ->> 'version'::text)::bigint AS version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_pk_for_class ;\nCREATE OR REPLACE VIEW reclada.v_pk_for_class\nAS\n SELECT obj.obj_id AS guid,\n    obj.for_class,\n    pk.pk\n   FROM v_class obj\n     JOIN ( SELECT 'File'::text AS class_name,\n            'uri'::text AS pk\n        UNION\n         SELECT 'DTOJsonSchema'::text AS text,\n            'function'::text AS text) pk ON pk.class_name = obj.for_class;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\nDROP view IF EXISTS reclada.v_dto_json_schema ;\nCREATE OR REPLACE VIEW reclada.v_dto_json_schema\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'function'::text AS function,\n    obj.attrs -> 'schema'::text AS schema,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'DTOJsonSchema'::text;	2021-12-21 13:28:11.224553+00
44	43	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 43 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nSELECT reclada_object.create('{\n    "class": "jsonschema",\n    "attributes":{\n        "forClass":"ObjectDisplay",\n        "version": "1",\n        "schema":{\n            "$defs": {\n                "displayType":{\n                    "type": "object",\n                    "properties": {\n                        "orderColumn":{\n                            "type": "array",\n                            "items":{\n                                "type": "string"\n                            }\n                        },\n                        "orderRow":{\n                            "type": "array",\n                            "items":{\n                                "type": "object",\n                                "patternProperties": {\n                                    "^{.*}$": {\n                                        "type": "string",\n                                        "enum": ["ASC", "DESC"]\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    "required":["orderColumn","orderRow"]\n                }\n            },\n            "properties": {\n                "classGUID": {"type": "string"},\n                "caption": {"type": "string"},\n                "flat": {"type": "bool"},\n                "table":{"$ref": "#/$defs/displayType"},\n                "card":{"$ref": "#/$defs/displayType"},\n                "preview":{"$ref": "#/$defs/displayType"},\n                "list":{"$ref": "#/$defs/displayType" }\n            },\n            "required": ["classGUID","caption"]\n        }\n    }\n}'::jsonb);\n\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('ObjectDisplay') ||'",\n        "caption": "Object display"\n    }\n}')::jsonb);\n\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('DataRow') ||'",\n        "caption": "Data row"\n    }\n}')::jsonb);\n\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('TextBlock') ||'",\n        "caption": "Text block"\n    }\n}')::jsonb);\n\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('Message') ||'",\n        "caption": "Message"\n    }\n}')::jsonb);\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('Page') ||'",\n        "caption": "Page"\n    }\n}')::jsonb);\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('Document') ||'",\n        "caption": "Document"\n    }\n}')::jsonb);\n\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('jsonschema') ||'",\n        "caption": "Json schema"\n    }\n}')::jsonb);\n\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('Job') ||'",\n        "caption": "Job"\n    }\n}')::jsonb);\n\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('File') ||'",\n        "caption": "Files",\n        "table": {\n            "{attributes,name}": {\n                "caption": "File name",\n                "displayCSS": "name",\n                "width": 250,\n                "behavior":"preview"\n            },\n            "{attributes,tags}": {\n                "caption": "Tags",\n                "displayCSS": "arrayLink",\n                "width": 250,\n                "items": {\n                    "displayCSS": "link",\n                    "behavior": "preview",\n                    "class":"'|| reclada_object.get_GUID_for_class('tag') ||'"\n                }\n            },\n            "{attributes,mimeType}": {\n                "caption": "Mime type",\n                "width": 250,\n                "displayCSS": "mimeType"\n            },\n            "{attributes,checksum}": {\n                "caption": "Checksum",\n                "width": 250,\n                "displayCSS": "checksum"\n            },\n            "{status}":{\n                "caption": "Status",\n                "width": 250,\n                "displayCSS": "status"\n            },\n            "{createdTime}":{\n                "caption": "Created time",\n                "width": 250,\n                "displayCSS": "createdTime"\n            },\n            "{transactionID}":{\n                "caption": "Transaction",\n                "width": 250,\n                "displayCSS": "transactionID"\n            },\n            "orderRow": [\n                {"{attributes,name}":"ASC"},\n                {"{attributes,mimeType}":"DESC"}\n            ],\n            "orderColumn": [\n                "{attributes,name}",\n                "{attributes,mimeType}",\n                "{attributes,tags}",\n                "{status}",\n                "{createdTime}",\n                "{transactionID}"\n            ]\n        },\n        "card":{\n            "orderRow": [\n                {"{attributes,name}":"ASC"},\n                {"{attributes,mimeType}":"DESC"}\n            ],\n            "orderColumn": [\n                "{attributes,name}",\n                "{attributes,mimeType}",\n                "{attributes,tags}",\n                "{status}",\n                "{createdTime}",\n                "{transactionID}"\n            ]\n        },\n        "preview":{\n            "orderRow": [\n                {"{attributes,name}":"ASC"},\n                {"{attributes,mimeType}":"DESC"}\n            ],\n            "orderColumn": [\n                "{attributes,name}",\n                "{attributes,mimeType}",\n                "{attributes,tags}",\n                "{status}",\n                "{createdTime}",\n                "{transactionID}"\n            ]\n        },\n        "list":{\n            "orderRow": [\n                {"{attributes,name}":"ASC"},\n                {"{attributes,mimeType}":"DESC"}\n            ],\n            "orderColumn": [\n                "{attributes,name}",\n                "{attributes,mimeType}",\n                "{attributes,tags}",\n                "{status}",\n                "{createdTime}",\n                "{transactionID}"\n            ]\n        }\n    }\n}')::jsonb);\n\ni 'view/reclada.v_object_display.sql' \ni 'view/reclada.v_ui_active_object.sql' \ni 'function/reclada_object.need_flat.sql' \ni 'function/reclada_object.list.sql' \ni 'function/api.reclada_object_update.sql' \ni 'function/reclada_object.update.sql' \ni 'function/api.reclada_object_list.sql' \ni 'function/api.reclada_object_create.sql' \ni 'function/api.reclada_object_delete.sql' \n\ni 'function/api.storage_generate_presigned_get.sql'\ni 'function/api.storage_generate_presigned_post.sql'\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\nDROP view IF EXISTS reclada.v_ui_active_object ;\n\nDROP view IF EXISTS reclada.v_object_display ;\n\ndelete from reclada.object \n    where class in (select reclada_object.get_GUID_for_class('ObjectDisplay'));\n\ndelete from reclada.object \n    where guid in (select reclada_object.get_GUID_for_class('ObjectDisplay'));\n\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    class               text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    class := data->>'class';\r\n    _filter = data->'filter';\r\n    -- IF (class IS NULL and tran_id IS NULL and _filter IS NULL) THEN\r\n    --     RAISE EXCEPTION 'The reclada object class, transactionID and filter are not specified';\r\n    -- END IF;\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    -- IF (jsonb_typeof(order_by_jsonb) != 'array') THEN\r\n    -- \t\torder_by_jsonb := format('[%s]', order_by_jsonb);\r\n    -- END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n    --IF ((limit_ ~ '(\\D+)') AND (limit_ != 'ALL')) THEN\r\n    --\t\tRAISE EXCEPTION 'The limit must be an integer number or "ALL"';\r\n    --END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    -- IF (offset_ ~ '(\\D+)') THEN\r\n    -- \t\tRAISE EXCEPTION 'The offset must be an integer number';\r\n    -- END IF;\r\n\r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSE\r\n        class_uuid := reclada.try_cast_uuid(class);\r\n\r\n        if class_uuid is not null then\r\n            select v.for_class \r\n                from reclada.v_class_lite v\r\n                    where class_uuid = v.obj_id\r\n            into class;\r\n\r\n            IF (class IS NULL) THEN\r\n                RAISE EXCEPTION 'Class not found by GUID: %', class_uuid::text;\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', class) AS condition\r\n                        where class is not null\r\n                            and class_uuid is null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             '\r\n    --             || query\r\n    --             ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    IF gui THEN\r\n\r\n        EXECUTE E'SELECT count(1)\r\n        '|| query\r\n        INTO number_of_objects;\r\n\r\n        EXECUTE E'SELECT TO_CHAR(\r\n\tMAX(\r\n\t\tGREATEST(obj.created_time, (\r\n\t\t\tSELECT TO_TIMESTAMP(MAX(date_time),\\'YYYY-MM-DD hh24:mi:ss.US TZH\\')\r\n\t\t\tFROM reclada.v_revision vr\r\n\t\t\tWHERE vr.obj_id = UUID(obj.attrs ->>\\'revision\\'))\r\n\t\t)\r\n\t),\\'YYYY-MM-DD hh24:mi:ss.MS TZH\\')\r\n        '|| query\r\n        INTO last_change;\r\n\r\n        res := jsonb_build_object(\r\n        'last_change', last_change,    \r\n        'number', number_of_objects,\r\n        'objects', objects);\r\n    ELSE\r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class_name     text;\r\n    class_uuid     uuid;\r\n    v_obj_id       uuid;\r\n    v_attrs        jsonb;\r\n    schema        jsonb;\r\n    old_obj       jsonb;\r\n    branch        uuid;\r\n    revid         uuid;\r\n\r\nBEGIN\r\n\r\n    class_name := data->>'class';\r\n    IF (class_name IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n    class_uuid := reclada.try_cast_uuid(class_name);\r\n    v_obj_id := data->>'GUID';\r\n    IF (v_obj_id IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no GUID';\r\n    END IF;\r\n\r\n    v_attrs := data->'attributes';\r\n    IF (v_attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    SELECT reclada_object.get_schema(class_name) \r\n        INTO schema;\r\n\r\n    if class_uuid is null then\r\n        SELECT reclada_object.get_schema(class_name) \r\n            INTO schema;\r\n    else\r\n        select v.data \r\n            from reclada.v_class v\r\n                where class_uuid = v.obj_id\r\n            INTO schema;\r\n    end if;\r\n    -- TODO: don't allow update jsonschema\r\n    IF (schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', class_name;\r\n    END IF;\r\n\r\n    IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', v_attrs))) THEN\r\n        RAISE EXCEPTION 'JSON invalid: %', v_attrs;\r\n    END IF;\r\n\r\n    SELECT \tv.data\r\n        FROM reclada.v_active_object v\r\n\t        WHERE v.obj_id = v_obj_id\r\n\t    INTO old_obj;\r\n\r\n    IF (old_obj IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object, no such id';\r\n    END IF;\r\n\r\n    branch := data->'branch';\r\n    SELECT reclada_revision.create(user_info->>'sub', branch, v_obj_id) \r\n        INTO revid;\r\n    \r\n    with t as \r\n    (\r\n        update reclada.object o\r\n            set status = reclada_object.get_archive_status_obj_id()\r\n                where o.GUID = v_obj_id\r\n                    and status != reclada_object.get_archive_status_obj_id()\r\n                        RETURNING id\r\n    )\r\n    INSERT INTO reclada.object( GUID,\r\n                                class,\r\n                                status,\r\n                                attributes,\r\n                                transaction_id\r\n                              )\r\n        select  v.obj_id,\r\n                (schema->>'GUID')::uuid,\r\n                reclada_object.get_active_status_obj_id(),--status \r\n                v_attrs || format('{"revision":"%s"}',revid)::jsonb,\r\n                transaction_id\r\n            FROM reclada.v_object v\r\n            JOIN t \r\n                on t.id = v.id\r\n\t            WHERE v.obj_id = v_obj_id;\r\n    PERFORM reclada_object.datasource_insert\r\n            (\r\n                class_name,\r\n                v_obj_id,\r\n                v_attrs\r\n            );\r\n    PERFORM reclada_object.refresh_mv(class_name);  \r\n                  \r\n    select v.data \r\n        FROM reclada.v_active_object v\r\n            WHERE v.obj_id = v_obj_id\r\n        into data;\r\n    PERFORM reclada_notification.send_object_notification('update', data);\r\n    RETURN data;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_update ;\nCREATE OR REPLACE FUNCTION api.reclada_object_update(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class         text;\r\n    objid         uuid;\r\n    attrs         jsonb;\r\n    user_info     jsonb;\r\n    result        jsonb;\r\n\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    objid := data->>'GUID';\r\n    IF (objid IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no GUID';\r\n    END IF;\r\n\r\n    attrs := data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object must have attributes';\r\n    END IF;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'update', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'update', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.update(data, user_info) INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_list ;\nCREATE OR REPLACE FUNCTION api.reclada_object_list(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    user_info           jsonb;\r\n    result              jsonb;\r\n    _filter             jsonb;\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF(class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    _filter = data->'filter';\r\n    if _filter is not null then\r\n        select format(  '{\r\n                            "filter":\r\n                            {\r\n                                "operator":"AND",\r\n                                "value":[\r\n                                    {\r\n                                        "operator":"=",\r\n                                        "value":["{class}","%s"]\r\n                                    },\r\n                                    %s\r\n                                ]\r\n                            }\r\n                        }',\r\n                class,\r\n                _filter\r\n            )::jsonb \r\n            into _filter;\r\n        data := data || _filter;\r\n    end if;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'list', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.list(data, true) INTO result;\r\n\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_create ;\nCREATE OR REPLACE FUNCTION api.reclada_object_create(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    data_jsonb       jsonb;\r\n    class            text;\r\n    user_info        jsonb;\r\n    attrs            jsonb;\r\n    data_to_create   jsonb = '[]'::jsonb;\r\n    result           jsonb;\r\n\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data) != 'array') THEN\r\n        data := '[]'::jsonb || data;\r\n    END IF;\r\n\r\n    FOR data_jsonb IN SELECT jsonb_array_elements(data) LOOP\r\n\r\n        class := data_jsonb->>'class';\r\n        IF (class IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n\r\n        SELECT reclada_user.auth_by_token(data_jsonb->>'accessToken') INTO user_info;\r\n        data_jsonb := data_jsonb - 'accessToken';\r\n\r\n        IF (NOT(reclada_user.is_allowed(user_info, 'create', class))) THEN\r\n            RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'create', class;\r\n        END IF;\r\n\r\n        attrs := data_jsonb->'attributes';\r\n        IF (attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        data_to_create := data_to_create || data_jsonb;\r\n    END LOOP;\r\n\r\n    SELECT reclada_object.create(data_to_create, user_info) INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_delete ;\nCREATE OR REPLACE FUNCTION api.reclada_object_delete(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class         text;\r\n    obj_id        uuid;\r\n    user_info     jsonb;\r\n    result        jsonb;\r\n\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    obj_id := data->>'GUID';\r\n    IF (obj_id IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not delete object with no id';\r\n    END IF;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'delete', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'delete', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.delete(data, user_info) INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.need_flat ;\n\n\nDROP function IF EXISTS api.storage_generate_presigned_get ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_get(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    object_data  jsonb;\r\n    object_id    uuid;\r\n    result       jsonb;\r\n    user_info    jsonb;\r\n    lambda_name  varchar;\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'generate presigned get', ''))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned get';\r\n    END IF;\r\n\r\n    -- TODO: check user's permissions for reclada object access?\r\n    object_id := data->>'objectId';\r\n    SELECT reclada_object.list(format(\r\n        '{"class": "File", "attributes": {}, "GUID": "%s"}',\r\n        object_id\r\n    )::jsonb) -> 0 INTO object_data;\r\n\r\n    IF (object_data IS NULL) THEN\r\n\t\tRAISE EXCEPTION 'There is no object with such id';\r\n\tEND IF;\r\n\r\n    SELECT attrs->>'Lambda'\r\n    FROM reclada.v_active_object\r\n    WHERE class_name = 'Context'\r\n    ORDER BY created_time DESC\r\n    LIMIT 1\r\n    INTO lambda_name;\r\n\r\n    SELECT payload\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n            format('%s', lambda_name),\r\n            'eu-west-1'\r\n            ),\r\n        format('{\r\n            "type": "get",\r\n            "uri": "%s",\r\n            "expiration": 3600}',\r\n            object_data->'attributes'->>'uri'\r\n            )::jsonb)\r\n    INTO result;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.storage_generate_presigned_post ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_post(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    user_info    jsonb;\r\n    object_name  varchar;\r\n    file_type    varchar;\r\n    file_size    varchar;\r\n    lambda_name  varchar;\r\n    bucket_name  varchar;\r\n    url          varchar;\r\n    result       jsonb;\r\n\r\n\r\n    object       jsonb;\r\n    object_id    uuid;\r\n    object_path  varchar;\r\n    uri          varchar;\r\n\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'generate presigned post', ''))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    object_name := data->>'objectName';\r\n    file_type := data->>'fileType';\r\n    file_size := data->>'fileSize';\r\n\r\n    IF (object_name IS NULL) OR (file_type IS NULL) OR (file_size IS NULL) THEN\r\n        RAISE EXCEPTION 'Parameters objectName, fileType and fileSize must be present';\r\n    END IF;\r\n\r\n    SELECT attrs->>'Lambda'\r\n    FROM reclada.v_active_object\r\n    WHERE class_name = 'Context'\r\n    ORDER BY created_time DESC\r\n    LIMIT 1\r\n    INTO lambda_name;\r\n\r\n    bucket_name := data->>'bucketName';\r\n\r\n    SELECT payload::jsonb\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n                format('%s', lambda_name),\r\n                'eu-west-1'\r\n        ),\r\n        format('{\r\n            "type": "post",\r\n            "fileName": "%s",\r\n            "fileType": "%s",\r\n            "fileSize": "%s",\r\n            "bucketName": "%s",\r\n            "expiration": 3600}',\r\n            object_name,\r\n            file_type,\r\n            file_size,\r\n            bucket_name\r\n            )::jsonb)\r\n    INTO url;\r\n\r\n    result = format(\r\n        '{"uploadUrl": %s}',\r\n        url\r\n    )::jsonb;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\n	2021-12-23 09:40:36.185045+00
45	44	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 44 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ncreate table reclada.draft(\n    id bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1),\n    guid uuid,\n    user_guid uuid DEFAULT reclada_object.get_default_user_obj_id(),\n    data jsonb not null\n);\n\n\ni 'function/api.reclada_object_create.sql'\ni 'function/api.reclada_object_list.sql'\ni 'function/api.reclada_object_delete.sql'\ni 'function/api.reclada_object_update.sql'\n\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.datasource_insert.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/reclada_object.parse_filter.sql'\n\ni 'function/reclada.raise_exception.sql'\ni 'view/reclada.v_filter_avaliable_operator.sql'\ni 'view/reclada.v_default_display.sql'\ni 'function/reclada_object.create_subclass.sql'\ni 'view/reclada.v_ui_active_object.sql'\n\n\n\nSELECT reclada_object.create_subclass('{\n    "class": "DataSource",\n    "attributes": {\n        "newClass": "Asset"\n    }\n}'::jsonb);\n\nSELECT reclada_object.create_subclass('{\n    "class": "Asset",\n    "attributes": {\n        "newClass": "DBAsset"\n    }\n}'::jsonb);\n\n\nUPDATE reclada.OBJECT\nSET ATTRIBUTES = jsonb_set(ATTRIBUTES,'{schema,properties,object,pattern}','"[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"'::jsonb)\nWHERE guid IN(SELECT reclada_object.get_GUID_for_class('Relationship'));\n\nUPDATE reclada.OBJECT\nSET ATTRIBUTES = jsonb_set(ATTRIBUTES,'{schema,properties,subject,pattern}','"[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"'::jsonb)\nWHERE guid IN(SELECT reclada_object.get_GUID_for_class('Relationship'));\n\n\nDROP OPERATOR IF EXISTS reclada.#(boolean, boolean);\nCREATE OPERATOR reclada.## (\n    FUNCTION = reclada.xor,\n    LEFTARG = boolean,\n    RIGHTARG = boolean\n);\n\ndelete from reclada.v_object_display;\n\nSELECT reclada_object.create(('{\n    "class":"ObjectDisplay",\n    "attributes":{\n        "classGUID": "'|| reclada_object.get_GUID_for_class('File') ||'",\n        "caption": "Files",\n        "table": {\n            "{attributes,name}:string": {\n                "caption": "File name",\n                "displayCSS": "name",\n                "width": 250,\n                "behavior":"preview"\n            },\n            "{attributes,tags}:array": {\n                "caption": "Tags",\n                "displayCSS": "arrayLink",\n                "width": 250,\n                "items": {\n                    "displayCSS": "link",\n                    "behavior": "preview",\n                    "class":"'|| reclada_object.get_GUID_for_class('tag') ||'"\n                }\n            },\n            "{attributes,mimeType}:string": {\n                "caption": "Mime type",\n                "width": 250,\n                "displayCSS": "mimeType"\n            },\n            "{attributes,checksum}:string": {\n                "caption": "Checksum",\n                "width": 250,\n                "displayCSS": "checksum"\n            },\n            "{status}:string":{\n                "caption": "Status",\n                "width": 250,\n                "displayCSS": "status"\n            },\n            "{createdTime}:string":{\n                "caption": "Created time",\n                "width": 250,\n                "displayCSS": "createdTime"\n            },\n            "{transactionID}:number":{\n                "caption": "Transaction",\n                "width": 250,\n                "displayCSS": "transactionID"\n            },\n            "{GUID}:string":{\n                "caption": "GUID",\n                "width": 250,\n                "displayCSS": "GUID"\n            },\n            "orderRow": [\n                {"{attributes,name}:string":"ASC"},\n                {"{attributes,mimeType}:string":"DESC"}\n            ],\n            "orderColumn": [\n                "{attributes,name}:string",\n                "{attributes,mimeType}:string",\n                "{attributes,tags}:array",\n                "{status}:string",\n                "{createdTime}:string",\n                "{transactionID}:number"\n            ]\n        },\n        "card":{\n            "orderRow": [\n                {"{attributes,name}:string":"ASC"},\n                {"{attributes,mimeType}:string":"DESC"}\n            ],\n            "orderColumn": [\n                "{attributes,name}:string",\n                "{attributes,mimeType}:string",\n                "{attributes,tags}:array",\n                "{status}:string",\n                "{createdTime}:string",\n                "{transactionID}:number"\n            ]\n        },\n        "preview":{\n            "orderRow": [\n                {"{attributes,name}:string":"ASC"},\n                {"{attributes,mimeType}:string":"DESC"}\n            ],\n            "orderColumn": [\n                "{attributes,name}:string",\n                "{attributes,mimeType}:string",\n                "{attributes,tags}:array",\n                "{status}:string",\n                "{createdTime}:string",\n                "{transactionID}:number"\n            ]\n        },\n        "list":{\n             "orderRow": [\n                {"{attributes,name}:string":"ASC"},\n                {"{attributes,mimeType}:string":"DESC"}\n            ],\n            "orderColumn": [\n                "{attributes,name}:string",\n                "{attributes,mimeType}:string",\n                "{attributes,tags}:array",\n                "{status}:string",\n                "{createdTime}:string",\n                "{transactionID}:number"\n            ]\n        }\n    }\n}')::jsonb);\n\nDO\n$do12$\nDECLARE\n\t_guid uuid;\n    _json jsonb;\nBEGIN\n\tselect obj_id\n        from reclada.v_DTO_json_schema \n            where function = 'reclada_object.list'\n            into _guid;\n    _json := '{\n        "status": "active",\n        "attributes": {\n            "schema": {\n                "type": "object",\n                "anyOf": [\n                    {\n                        "required": [\n                            "transactionID","class"\n                        ]\n                    },\n                    {\n                        "required": [\n                            "class"\n                        ]\n                    },\n                    {\n                        "required": [\n                            "filter","class"\n                        ]\n                    }\n                ],\n                "properties": {\n                    "class": {\n                        "type": "string"\n                    },\n                    "limit": {\n                        "anyOf": [\n                            {\n                                "enum": [\n                                    "ALL"\n                                ],\n                                "type": "string"\n                            },\n                            {\n                                "type": "integer"\n                            }\n                        ]\n                    },\n                    "filter": {\n                        "type": "object"\n                    },\n                    "offset": {\n                        "type": "integer"\n                    },\n                    "orderBy": {\n                        "type": "array",\n                        "items": {\n                            "type": "object",\n                            "required": [\n                                "field"\n                            ],\n                            "properties": {\n                                "field": {\n                                    "type": "string"\n                                },\n                                "order": {\n                                    "enum": [\n                                        "ASC",\n                                        "DESC"\n                                    ],\n                                    "type": "string"\n                                }\n                            }\n                        }\n                    },\n                    "transactionID": {\n                        "type": "integer"\n                    }\n                }\n            },\n            "function": "reclada_object.list"\n        },\n        "parentGUID": null,\n        "createdTime": "2021-11-08T11:01:49.274513+00:00",\n        "transactionID": 61\n    }';\n    \n    _json := _json || ('{"GUID": "'||_guid::text||'"}')::jsonb;\n    select reclada_object.get_guid_for_class('DTOJsonSchema')\n        into _guid;\n    _json := _json || ('{"class": "' ||_guid::text|| '"}')::jsonb;\n    perform reclada_object.update(_json);\n    \nEND\n$do12$;\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, curren version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\ndrop table reclada.draft;\n\nDROP function IF EXISTS api.reclada_object_create ;\nCREATE OR REPLACE FUNCTION api.reclada_object_create(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    data_jsonb       jsonb;\r\n    class            text;\r\n    user_info        jsonb;\r\n    attrs            jsonb;\r\n    data_to_create   jsonb = '[]'::jsonb;\r\n    result           jsonb;\r\n    _need_flat       bool := false;\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data) != 'array') THEN\r\n        data := '[]'::jsonb || data;\r\n    END IF;\r\n\r\n    FOR data_jsonb IN SELECT jsonb_array_elements(data) LOOP\r\n\r\n        class := coalesce(data_jsonb->>'{class}', data_jsonb->>'class');\r\n        IF (class IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified (api)';\r\n        END IF;\r\n\r\n        SELECT reclada_user.auth_by_token(data_jsonb->>'accessToken') INTO user_info;\r\n        data_jsonb := data_jsonb - 'accessToken';\r\n\r\n        -- raise notice '%',data_jsonb #> '{}';\r\n\r\n        IF (NOT(reclada_user.is_allowed(user_info, 'create', class))) THEN\r\n            RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'create', class;\r\n        END IF;\r\n        \r\n        if reclada_object.need_flat(class) then\r\n            _need_flat := true;\r\n            with recursive j as \r\n            (\r\n                select  row_number() over() as id,\r\n                        key,\r\n                        value \r\n                    from jsonb_each(data_jsonb)\r\n                        where key like '{%}'\r\n            ),\r\n            inn as \r\n            (\r\n                SELECT  row_number() over(order by s.id,j.id) rn,\r\n                        j.id,\r\n                        s.id sid,\r\n                        s.d,\r\n                        ARRAY (\r\n                            SELECT UNNEST(arr.v) \r\n                            LIMIT array_position(arr.v, s.d)\r\n                        ) as k\r\n                    FROM j\r\n                    left join lateral\r\n                    (\r\n                        select id, d ,max(id) over() mid\r\n                        from\r\n                        (\r\n                            SELECT  row_number() over() as id, \r\n                                    d\r\n                                from regexp_split_to_table(substring(j.key,2,char_length(j.key)-2),',') d \r\n                        ) t\r\n                    ) s on s.mid != s.id\r\n                    join lateral\r\n                    (\r\n                        select regexp_split_to_array(substring(j.key,2,char_length(j.key)-2),',') v\r\n                    ) arr on true\r\n                        where d is not null\r\n            ),\r\n            src as\r\n            (\r\n                select  jsonb_set('{}'::jsonb,('{'|| i.d ||'}')::text[],'{}'::jsonb) r,\r\n                        i.* \r\n                    from inn i\r\n                        where i.rn = 1\r\n                union\r\n                select  jsonb_set(\r\n                            s.r,\r\n                            i.k,\r\n                            '{}'::jsonb\r\n                        ) r,\r\n                        i.* \r\n                    from src s\r\n                    join inn i\r\n                        on s.rn + 1 = i.rn\r\n            ),\r\n            tmpl as (\r\n                select r v\r\n                    from src\r\n                    ORDER BY rn DESC\r\n                    limit 1\r\n            ),\r\n            res as\r\n            (\r\n                SELECT jsonb_set(\r\n                        (select v from tmpl),\r\n                        j.key::text[],\r\n                        j.value\r\n                    ) v,\r\n                    j.*\r\n                    FROM j\r\n                        where j.id = 1\r\n                union \r\n                select jsonb_set(\r\n                        res.v,\r\n                        j.key::text[],\r\n                        j.value\r\n                    ) v,\r\n                    j.*\r\n                    FROM res\r\n                    join j\r\n                        on res.id + 1 =j.id\r\n            )\r\n            SELECT v \r\n                FROM res\r\n                ORDER BY ID DESC\r\n                limit 1\r\n                into data_jsonb;\r\n        end if;\r\n        data_to_create := data_to_create || data_jsonb;\r\n    END LOOP;\r\n\r\n    if data_to_create is null then\r\n        RAISE EXCEPTION 'JSON invalid';\r\n    end if;\r\n\r\n    SELECT reclada_object.create(data_to_create, user_info) INTO result;\r\n    if _need_flat then\r\n        RETURN '{"status":"OK"}'::jsonb;\r\n    end if;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_list ;\nCREATE OR REPLACE FUNCTION api.reclada_object_list(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class               text;\r\n    user_info           jsonb;\r\n    result              jsonb;\r\n    _filter             jsonb;\r\nBEGIN\r\n\r\n    class := coalesce(data->>'{class}', data->>'class');\r\n    IF(class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    _filter = data->'filter';\r\n    IF _filter IS NOT NULL THEN\r\n        SELECT format(  '{\r\n                            "filter":\r\n                            {\r\n                                "operator":"AND",\r\n                                "value":[\r\n                                    {\r\n                                        "operator":"=",\r\n                                        "value":["{class}","%s"]\r\n                                    },\r\n                                    %s\r\n                                ]\r\n                            }\r\n                        }',\r\n                class,\r\n                _filter\r\n            )::jsonb \r\n            INTO _filter;\r\n        data := data || _filter;\r\n    ELSE\r\n        data := data || ('{"class":"'|| class ||'"}')::jsonb;\r\n    --     select format(  '{\r\n    --                         "filter":{\r\n    --                             "operator":"=",\r\n    --                             "value":["{class}","%s"]\r\n    --                         }\r\n    --                     }',\r\n    --             class,\r\n    --             _filter\r\n    --         )::jsonb \r\n    --         INTO _filter;\r\n    END IF;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'list', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.list(data, true) \r\n        INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_delete ;\nCREATE OR REPLACE FUNCTION api.reclada_object_delete(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class         text;\r\n    obj_id        uuid;\r\n    user_info     jsonb;\r\n    result        jsonb;\r\n\r\nBEGIN\r\n\r\n    class := coalesce(data ->> '{class}', data ->> 'class');\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    obj_id := coalesce(data ->> '{GUID}', data ->> 'GUID');\r\n    IF (obj_id IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not delete object with no id';\r\n    END IF;\r\n\r\n    data := data || ('{"GUID":"'|| obj_id ||'","class":"'|| class ||'"}')::jsonb;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'delete', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'delete', class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.delete(data, user_info) INTO result;\r\n\r\n    if reclada_object.need_flat(class) then \r\n        RETURN '{"status":"OK"}'::jsonb;\r\n    end if;\r\n\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_update ;\nCREATE OR REPLACE FUNCTION api.reclada_object_update(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class         text;\r\n    objid         uuid;\r\n    attrs         jsonb;\r\n    user_info     jsonb;\r\n    result        jsonb;\r\n    _need_flat    bool := false;\r\n\r\nBEGIN\r\n\r\n    class := coalesce(data ->> '{class}', data ->> 'class');\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    objid := coalesce(data ->> '{GUID}', data ->> 'GUID');\r\n    IF (objid IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no GUID';\r\n    END IF;\r\n    \r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'update', class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'update', class;\r\n    END IF;\r\n\r\n    if reclada_object.need_flat(class) then\r\n        _need_flat := true;\r\n        with recursive j as \r\n        (\r\n            select  row_number() over() as id,\r\n                    key,\r\n                    value \r\n                from jsonb_each(data)\r\n                    where key like '{%}'\r\n        ),\r\n        t as\r\n        (\r\n            select  j.id    , \r\n                    j.key   , \r\n                    j.value , \r\n                    o.data\r\n                from reclada.v_object o\r\n                join j\r\n                    on true\r\n                    where o.obj_id = \r\n                        (\r\n                            select (j.value#>>'{}')::uuid \r\n                                from j where j.key = '{GUID}'\r\n                        )\r\n        ),\r\n        r as \r\n        (\r\n            select id,key,value,jsonb_set(t.data,t.key::text[],t.value) as u, t.data\r\n                from t\r\n                    where id = 1\r\n            union\r\n            select t.id,t.key,t.value,jsonb_set(r.u   ,t.key::text[],t.value) as u, t.data\r\n                from r\r\n                JOIN t\r\n                    on t.id-1 = r.id\r\n        )\r\n        select r.u\r\n            from r\r\n                where id = (select max(j.id) from j)\r\n            INTO data;\r\n    end if;\r\n    raise notice '%', data#>>'{}';\r\n    SELECT reclada_object.update(data, user_info) INTO result;\r\n\r\n    if _need_flat then\r\n        RETURN '{"status":"OK"}'::jsonb;\r\n    end if;\r\n    return result;\r\nEND;\r\n$function$\n;\n\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    data          jsonb;\r\n    class_name    text;\r\n    class_uuid    uuid;\r\n    tran_id       bigint;\r\n    _attrs         jsonb;\r\n    schema        jsonb;\r\n    obj_GUID      uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    _parent_guid  uuid;\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision and others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    FOR data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n\r\n        class_name := data->>'class';\r\n\r\n        IF (class_name IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n        class_uuid := reclada.try_cast_uuid(class_name);\r\n\r\n        _attrs := data->'attributes';\r\n        IF (_attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        tran_id := (data->>'transactionID')::bigint;\r\n        if tran_id is null then\r\n            tran_id := reclada.get_transaction_id();\r\n        end if;\r\n\r\n        IF class_uuid IS NULL THEN\r\n            SELECT reclada_object.get_schema(class_name) \r\n            INTO schema;\r\n            class_uuid := (schema->>'GUID')::uuid;\r\n        ELSE\r\n            SELECT v.data \r\n            FROM reclada.v_class v\r\n            WHERE class_uuid = v.obj_id\r\n            INTO schema;\r\n        END IF;\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', class_name;\r\n        END IF;\r\n\r\n        IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', _attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n        END IF;\r\n        \r\n        IF data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        IF class_uuid IN (SELECT guid FROM reclada.v_PK_for_class)\r\n        THEN\r\n            SELECT o.obj_id\r\n                FROM reclada.v_object o\r\n                JOIN reclada.v_PK_for_class pk\r\n                    on pk.guid = o.class\r\n                        and class_uuid = o.class\r\n                where o.attrs->>pk.pk = _attrs ->> pk.pk\r\n                LIMIT 1\r\n            INTO obj_GUID;\r\n            IF obj_GUID IS NOT NULL THEN\r\n                SELECT reclada_object.update(data || format('{"GUID": "%s"}', obj_GUID)::jsonb)\r\n                    INTO res;\r\n                    RETURN '[]'::jsonb || res;\r\n            END IF;\r\n        END IF;\r\n\r\n        obj_GUID := (data->>'GUID')::uuid;\r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.object \r\n            WHERE GUID = obj_GUID\r\n        ) THEN\r\n            RAISE EXCEPTION 'GUID: % is duplicate', obj_GUID;\r\n        END IF;\r\n        --raise notice 'schema: %',schema;\r\n\r\n        _parent_guid = (data->>'parent_guid')::uuid;\r\n\r\n        INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n            SELECT  CASE\r\n                        WHEN obj_GUID IS NULL\r\n                            THEN public.uuid_generate_v4()\r\n                        ELSE obj_GUID\r\n                    END AS GUID,\r\n                    class_uuid, \r\n                    _attrs,\r\n                    tran_id,\r\n                    _parent_guid\r\n        RETURNING GUID INTO obj_GUID;\r\n        affected := array_append( affected, obj_GUID);\r\n\r\n        PERFORM reclada_object.datasource_insert\r\n            (\r\n                class_name,\r\n                obj_GUID,\r\n                _attrs\r\n            );\r\n\r\n        PERFORM reclada_object.refresh_mv(class_name);\r\n    END LOOP;\r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb; \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            res\r\n        );\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.datasource_insert ;\nCREATE OR REPLACE FUNCTION reclada_object.datasource_insert(_class_name text, _obj_id uuid, attributes jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _pipeline_lite jsonb;\r\n    _task  jsonb;\r\n    _dataset_guid  uuid;\r\n    _new_guid  uuid;\r\n    _pipeline_job_guid  uuid;\r\n    _stage         text;\r\n    _uri           text;\r\n    _environment   varchar;\r\n    _rel_cnt       int;\r\n    _dataset2ds_type text = 'defaultDataSet to DataSource';\r\n    _f_name text = 'reclada_object.datasource_insert';\r\nBEGIN\r\n    IF _class_name in ('DataSource','File') THEN\r\n\r\n        _uri := attributes->>'uri';\r\n\r\n\r\n        SELECT v.obj_id\r\n        FROM reclada.v_active_object v\r\n        WHERE v.class_name = 'DataSet'\r\n            and v.attrs->>'name' = 'defaultDataSet'\r\n        INTO _dataset_guid;\r\n\r\n        SELECT count(*)\r\n        FROM reclada.v_active_object\r\n        WHERE class_name = 'Relationship'\r\n            AND (attrs->>'object')::uuid = _obj_id\r\n            AND (attrs->>'subject')::uuid = _dataset_guid\r\n            AND attrs->>'type' = _dataset2ds_type\r\n                INTO _rel_cnt;\r\n\r\n        SELECT attrs->>'Environment'\r\n            FROM reclada.v_active_object\r\n                WHERE class_name = 'Context'\r\n                ORDER BY created_time DESC\r\n                LIMIT 1\r\n            INTO _environment;\r\n        IF _rel_cnt=0 THEN\r\n            PERFORM reclada_object.create(\r\n                    format('{\r\n                        "class": "Relationship",\r\n                        "attributes": {\r\n                            "type": "%s",\r\n                            "object": "%s",\r\n                            "subject": "%s"\r\n                            }\r\n                        }', _dataset2ds_type, _obj_id, _dataset_guid\r\n                    )::jsonb\r\n                );\r\n\r\n        END IF;\r\n        if _uri like '%inbox/jobs/%' then\r\n        \r\n            PERFORM reclada_object.create(\r\n                    format('{\r\n                        "class": "Job",\r\n                        "attributes": {\r\n                            "task": "c94bff30-15fa-427f-9954-d5c3c151e652",\r\n                            "status": "new",\r\n                            "type": "%s",\r\n                            "command": "./run_pipeline.sh",\r\n                            "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\r\n                            }\r\n                        }', _environment, _uri, _obj_id\r\n                    )::jsonb\r\n                );\r\n        \r\n        ELSE\r\n            \r\n            SELECT data \r\n                FROM reclada.v_active_object\r\n                    WHERE class_name = 'PipelineLite'\r\n                        LIMIT 1\r\n                INTO _pipeline_lite;\r\n            _new_guid := public.uuid_generate_v4();\r\n            IF _uri like '%inbox/pipelines/%/%' then\r\n                \r\n                _stage := SPLIT_PART(\r\n                                SPLIT_PART(_uri,'inbox/pipelines/',2),\r\n                                '/',\r\n                                2\r\n                            );\r\n                _stage = replace(_stage,'.json','');\r\n                SELECT data \r\n                    FROM reclada.v_active_object o\r\n                        where o.class_name = 'Task'\r\n                            and o.obj_id = (_pipeline_lite #>> ('{attributes,tasks,'||_stage||'}')::text[])::uuid\r\n                    into _task;\r\n                \r\n                _pipeline_job_guid = reclada.try_cast_uuid(\r\n                                        SPLIT_PART(\r\n                                            SPLIT_PART(_uri,'inbox/pipelines/',2),\r\n                                            '/',\r\n                                            1\r\n                                        )\r\n                                    );\r\n                if _pipeline_job_guid is null then \r\n                    perform reclada.raise_exception('PIPELINE_JOB_GUID not found',_f_name);\r\n                end if;\r\n                \r\n                SELECT  data #>> '{attributes,inputParameters,0,uri}',\r\n                        (data #>> '{attributes,inputParameters,1,dataSourceId}')::uuid\r\n                    from reclada.v_active_object o\r\n                        where o.obj_id = _pipeline_job_guid\r\n                    into _uri, _obj_id;\r\n\r\n            ELSE\r\n                SELECT data \r\n                    FROM reclada.v_active_object o\r\n                        where o.class_name = 'Task'\r\n                            and o.obj_id = (_pipeline_lite #>> '{attributes,tasks,0}')::uuid\r\n                    into _task;\r\n                _pipeline_job_guid := _new_guid;\r\n            END IF;\r\n            \r\n            PERFORM reclada_object.create(\r\n                format('{\r\n                    "GUID":"%s",\r\n                    "class": "Job",\r\n                    "attributes": {\r\n                        "task": "%s",\r\n                        "status": "new",\r\n                        "type": "%s",\r\n                        "command": "%s",\r\n                        "inputParameters": [\r\n                                { "uri"                 :"%s"   }, \r\n                                { "dataSourceId"        :"%s"   },\r\n                                { "PipelineLiteJobGUID" :"%s"   }\r\n                            ]\r\n                        }\r\n                    }',\r\n                        _new_guid::text,\r\n                        _task->>'GUID',\r\n                        _environment, \r\n                        _task-> 'attributes' ->>'command',\r\n                        _uri,\r\n                        _obj_id,\r\n                        _pipeline_job_guid::text\r\n                )::jsonb\r\n            );\r\n\r\n        END IF;\r\n    END IF;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    class               text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    class := data->>'class';\r\n    _filter = data->'filter';\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n \r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n        IF gui THEN\r\n            query_conditions := REPLACE(query_conditions,'#>','->');\r\n        end if;\r\n    ELSE\r\n        class_uuid := reclada.try_cast_uuid(class);\r\n\r\n        IF class_uuid IS NOT NULL THEN\r\n            SELECT v.for_class\r\n                FROM reclada.v_class_lite v\r\n                    WHERE class_uuid = v.obj_id\r\n            INTO class;\r\n\r\n            IF (class IS NULL) THEN\r\n                RAISE EXCEPTION 'Class not found by GUID: %', class_uuid::text;\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', class) AS condition\r\n                        where class is not null\r\n                            and class_uuid is null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    IF gui AND reclada_object.need_flat(class) THEN\r\n        query := 'FROM reclada.v_ui_active_object obj WHERE ' || query_conditions;\r\n    ELSE\r\n        query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n    END IF;\r\n    RAISE NOTICE 'conds: %', '\r\n                SELECT obj.data\r\n                '\r\n                || query\r\n                ||\r\n                ' ORDER BY ' || order_by ||\r\n                ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    IF gui THEN\r\n\r\n        EXECUTE E'SELECT count(1)\r\n        '|| query\r\n        INTO number_of_objects;\r\n\r\n        EXECUTE E'SELECT TO_CHAR(\r\n\tMAX(\r\n\t\tGREATEST(obj.created_time, (\r\n\t\t\tSELECT TO_TIMESTAMP(MAX(date_time),\\'YYYY-MM-DD hh24:mi:ss.US TZH\\')\r\n\t\t\tFROM reclada.v_revision vr\r\n\t\t\tWHERE vr.obj_id = UUID(obj.attrs ->>\\'revision\\'))\r\n\t\t)\r\n\t),\\'YYYY-MM-DD hh24:mi:ss.MS TZH\\')\r\n        '|| query\r\n        INTO last_change;\r\n\r\n        res := jsonb_build_object(\r\n        'last_change', last_change,    \r\n        'number', number_of_objects,\r\n        'objects', objects);\r\n    ELSE\r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition_filter(data jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE \r\n    _count   INT;\r\n    _res     TEXT;\r\n    _f_name TEXT = 'reclada_object.get_query_condition_filter';\r\nBEGIN \r\n    \r\n    perform reclada.validate_json(data, _f_name);\r\n    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE\r\n    CREATE TEMP TABLE mytable AS\r\n        SELECT  res.lvl              AS lvl         , \r\n                res.rn               AS rn          , \r\n                res.idx              AS idx         ,\r\n                res.prev             AS prev        , \r\n                res.val              AS val         ,  \r\n                res.parsed           AS parsed      , \r\n                coalesce(\r\n                    po.inner_operator, \r\n                    op.operator\r\n                )                   AS op           , \r\n                coalesce\r\n                (\r\n                    iop.input_type,\r\n                    op.input_type\r\n                )                   AS input_type   ,\r\n                case \r\n                    when iop.input_type is not NULL \r\n                        then NULL \r\n                    else \r\n                        op.output_type\r\n                end                 AS output_type  ,\r\n                po.operator         AS po           ,\r\n                po.input_type       AS po_input_type,\r\n                iop.brackets        AS po_inner_brackets\r\n            FROM reclada_object.parse_filter(data) res\r\n            LEFT JOIN reclada.v_filter_avaliable_operator op\r\n                ON res.op = op.operator\r\n            LEFT JOIN reclada_object.parse_filter(data) p\r\n                on  p.lvl = res.lvl-1\r\n                    and res.prev = p.rn\r\n            LEFT JOIN reclada.v_filter_avaliable_operator po\r\n                on po.operator = p.op\r\n            LEFT JOIN reclada.v_filter_inner_operator iop\r\n                on iop.operator = po.inner_operator;\r\n\r\n    PERFORM reclada.raise_exception('Operator does not allowed ' || t.op,'reclada_object.get_query_condition_filter')\r\n        FROM mytable t\r\n            WHERE t.op IS NULL;\r\n\r\n\r\n    UPDATE mytable u\r\n        SET parsed = to_jsonb(p.v)\r\n            FROM mytable t\r\n            JOIN LATERAL \r\n            (\r\n                SELECT  t.parsed #>> '{}' v\r\n            ) as pt\r\n                ON TRUE\r\n            LEFT JOIN reclada.v_filter_mapping fm\r\n                ON pt.v = fm.pattern\r\n            JOIN LATERAL \r\n            (\r\n                SELECT CASE \r\n                        WHEN fm.repl is not NULL \r\n                            then '(''"''||' ||fm.repl ||'||''"'')::jsonb' -- don't use FORMAT (concat null)\r\n                        -- WHEN pt.v LIKE '{attributes,%}'\r\n                        --     THEN format('attrs #> ''%s''', REPLACE(pt.v,'{attributes,','{'))\r\n                        WHEN jsonb_typeof(t.parsed) in ('number', 'boolean')\r\n                            then \r\n                                case \r\n                                    when t.input_type in ('NUMERIC','INT')\r\n                                        then pt.v\r\n                                    else '''' || pt.v || '''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'string' \r\n                            then    \r\n                                case\r\n                                    WHEN pt.v LIKE '{%}'\r\n                                        THEN\r\n                                            case\r\n                                                when t.input_type = 'TEXT'\r\n                                                    then format('(data #>> ''%s'')', pt.v)\r\n                                                when t.input_type = 'JSONB' or t.input_type is null\r\n                                                    then format('data #> ''%s''', pt.v)\r\n                                                else\r\n                                                    format('(data #>> ''%s'')::', pt.v) || t.input_type\r\n                                            end\r\n                                    when t.input_type = 'TEXT'\r\n                                        then ''''||REPLACE(pt.v,'''','''''')||''''\r\n                                    when t.input_type = 'JSONB' or t.input_type is null\r\n                                        then '''"'||REPLACE(pt.v,'''','''''')||'"''::jsonb'\r\n                                    else ''''||REPLACE(pt.v,'''','''''')||'''::'||t.input_type\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'null'\r\n                            then 'null'\r\n                        WHEN jsonb_typeof(t.parsed) = 'array'\r\n                            then ''''||REPLACE(pt.v,'''','''''')||'''::jsonb'\r\n                        ELSE\r\n                            pt.v\r\n                    END AS v\r\n            ) as p\r\n                ON TRUE\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND t.parsed IS NOT NULL;\r\n\r\n    update mytable u\r\n        set op = CASE \r\n                    when f.btwn\r\n                        then ' BETWEEN '\r\n                    else u.op -- f.inop\r\n                end,\r\n            parsed = format(vb.operand_format,u.parsed)::jsonb\r\n        FROM mytable t\r\n        join lateral\r\n        (\r\n            select  t.op like ' %/BETWEEN ' btwn, \r\n                    t.po_inner_brackets is not null inop\r\n        ) f \r\n            on true\r\n        join reclada.v_filter_between vb\r\n            on t.op = vb.operator\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND (f.btwn or f.inop);\r\n\r\n    INSERT INTO mytable (lvl,rn)\r\n        VALUES (0,0);\r\n\r\n    _count := 1;\r\n\r\n    WHILE (_count>0) LOOP\r\n        WITH r AS \r\n        (\r\n            UPDATE mytable\r\n                SET parsed = to_json(t.converted)::JSONB \r\n                FROM \r\n                (\r\n                    SELECT     \r\n                            res.lvl-1 lvl,\r\n                            res.prev rn,\r\n                            res.op,\r\n                            1 q,\r\n                            case \r\n                                when not res.po_inner_brackets \r\n                                    then array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) \r\n                                else\r\n                                    CASE COUNT(1) \r\n                                        WHEN 1\r\n                                            THEN \r\n                                                CASE res.output_type\r\n                                                    when 'NUMERIC'\r\n                                                        then format('(%s %s)::TEXT::JSONB', res.op, min(res.parsed #>> '{}') )\r\n                                                    else \r\n                                                        format('(%s %s)', res.op, min(res.parsed #>> '{}') )\r\n                                                end\r\n                                        ELSE\r\n                                            CASE \r\n                                                when res.output_type = 'TEXT'\r\n                                                    then '(''"''||'||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||'||''"'')::JSONB'\r\n                                                when res.output_type in ('NUMERIC','INT')\r\n                                                    then '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')::TEXT::JSONB'\r\n                                                else\r\n                                                    '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')'\r\n                                            end\r\n                                    end\r\n                            end AS converted\r\n                        FROM mytable res \r\n                            WHERE res.parsed IS NOT NULL\r\n                                AND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)\r\n                            GROUP BY  res.prev, res.op, res.lvl, res.input_type, res.output_type, res.po_inner_brackets\r\n                ) t\r\n                WHERE\r\n                    t.lvl = mytable.lvl\r\n                        AND t.rn = mytable.rn\r\n                RETURNING 1\r\n        )\r\n            SELECT COUNT(1) \r\n                FROM r\r\n                INTO _count;\r\n    END LOOP;\r\n    \r\n    SELECT parsed #>> '{}' \r\n        FROM mytable\r\n            WHERE lvl = 0 AND rn = 0\r\n        INTO _res;\r\n    perform reclada.raise_notice( _res);\r\n    DROP TABLE mytable;\r\n    RETURN _res;\r\nEND \r\n$function$\n;\nDROP function IF EXISTS reclada_object.parse_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.parse_filter(data jsonb)\n RETURNS TABLE(lvl integer, rn bigint, idx bigint, op text, prev bigint, val jsonb, parsed jsonb)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\n    WITH RECURSIVE f AS \r\n    (\r\n        SELECT data AS v\r\n    ),\r\n    pr AS \r\n    (\r\n        SELECT \tformat(' %s ',f.v->>'operator') AS op, \r\n                val.v AS val,\r\n                1 AS lvl,\r\n                row_number() OVER(ORDER BY idx) AS rn,\r\n                val.idx idx,\r\n                0::BIGINT prev\r\n            FROM f, jsonb_array_elements(f.v->'value') WITH ordinality AS val(v, idx)\r\n    ),\r\n    res AS\r\n    (\t\r\n        SELECT \tpr.lvl\t,\r\n                pr.rn\t,\r\n                pr.idx  ,\r\n                pr.op\t,\r\n                pr.prev ,\r\n                pr.val\t,\r\n                CASE jsonb_typeof(pr.val) \r\n                    WHEN 'object'\t\r\n                        THEN NULL\r\n                    ELSE pr.val\r\n                END AS parsed\r\n            FROM pr\r\n            WHERE prev = 0 \r\n                AND lvl = 1\r\n        UNION ALL\r\n        SELECT \tttt.lvl\t,\r\n                ROW_NUMBER() OVER(ORDER BY ttt.idx) AS rn,\r\n                ttt.idx,\r\n                ttt.op\t,\r\n                ttt.prev,\r\n                ttt.val ,\r\n                CASE jsonb_typeof(ttt.val) \r\n                    WHEN 'object'\t\r\n                        THEN NULL\r\n                    ELSE ttt.val\r\n                end AS parsed\r\n            FROM\r\n            (\r\n                SELECT \tres.lvl + 1 AS lvl,\r\n                        format(' %s ',res.val->>'operator') AS op,\r\n                        res.rn AS prev\t,\r\n                        val.v  AS val,\r\n                        val.idx\r\n                    FROM res, \r\n                         jsonb_array_elements(res.val->'value') WITH ordinality AS val(v, idx)\r\n            ) ttt\r\n    )\r\n    SELECT \tr.lvl\t,\r\n            r.rn\t,\r\n            r.idx   ,\r\n            upper(r.op) ,\r\n            r.prev  ,\r\n            r.val\t,\r\n            r.parsed\r\n        FROM res r\r\n$function$\n;\n\nDROP function IF EXISTS reclada.raise_exception ;\nCREATE OR REPLACE FUNCTION reclada.raise_exception(msg text, func_name text DEFAULT '<unknown>'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- \r\n    RAISE EXCEPTION '% \r\n    from: %', msg, func_name;\r\nEND\r\n$function$\n;\nDROP view IF EXISTS reclada.v_filter_avaliable_operator ;\nCREATE OR REPLACE VIEW reclada.v_filter_avaliable_operator\nAS\n SELECT ' = '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' LIKE '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' NOT LIKE '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' || '::text AS operator,\n    'TEXT'::text AS input_type,\n    'TEXT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ~ '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !~ '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ~* '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !~* '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' SIMILAR TO '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' > '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' < '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' <= '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' != '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' >= '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' AND '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' OR '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' NOT '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' # '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IS '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IS NOT '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IN '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    ' , '::text AS inner_operator\nUNION\n SELECT ' @> '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' <@ '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' + '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' - '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' * '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' / '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' % '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ^ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' |/ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ||/ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !! '::text AS operator,\n    'INT'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' @ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' & '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' | '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' << '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' >> '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' BETWEEN '::text AS operator,\n    'TIMESTAMP WITH TIME ZONE'::text AS input_type,\n    'BOOL'::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' Y/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' MON/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' D/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' H/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' MIN/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' S/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' DOW/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' DOY/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' Q/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' W/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator;\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    new_class       text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n    version_         integer;\r\n    class_guid    uuid;\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    attrs := data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    new_class = attrs->>'newClass';\r\n\r\n    SELECT reclada_object.get_schema(class) INTO class_schema;\r\n\r\n    IF (class_schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', class;\r\n    END IF;\r\n\r\n    SELECT max(version) + 1\r\n    FROM reclada.v_class_lite v\r\n    WHERE v.for_class = new_class\r\n    INTO version_;\r\n\r\n    version_ := coalesce(version_,1);\r\n    class_schema := class_schema->'attributes'->'schema';\r\n\r\n    SELECT obj_id\r\n    FROM reclada.v_class\r\n    WHERE for_class = class\r\n    ORDER BY version DESC\r\n    LIMIT 1\r\n    INTO class_guid;\r\n\r\n    PERFORM reclada_object.create(format('{\r\n        "class": "jsonschema",\r\n        "attributes": {\r\n            "forClass": "%s",\r\n            "version": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n            }\r\n        },\r\n        "parent_guid" : "%s"\r\n    }',\r\n    new_class,\r\n    version_,\r\n    (class_schema->'properties') || (attrs->'properties'),\r\n    (SELECT jsonb_agg(el) FROM (\r\n        SELECT DISTINCT pg_catalog.jsonb_array_elements(\r\n            (class_schema -> 'required') || (attrs -> 'required')\r\n        ) el) arr),\r\n    class_guid\r\n    )::jsonb);\r\n\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_ui_active_object ;\nCREATE OR REPLACE VIEW reclada.v_ui_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    j.data,\n    t.transaction_id,\n    t.parent_guid\n   FROM v_active_object t\n     JOIN ( SELECT t_1.id,\n            jsonb_object_agg(t_1.key, t_1.val) AS data\n           FROM ( SELECT t_2.id,\n                    j_1.key,\n                    t_2.data #>> j_1.key::text[] AS val\n                   FROM v_active_object t_2\n                     JOIN v_object_display od ON od.class_guid = t_2.class\n                     JOIN LATERAL ( SELECT jsonb_each.key\n                           FROM jsonb_each(od."table") jsonb_each(key, value)\n                        UNION\n                         SELECT '{GUID}'::text AS text) j_1 ON j_1.key ~~ '{%}'::text) t_1\n          GROUP BY t_1.id) j ON t.id = j.id;\nDROP view IF EXISTS reclada.v_default_display ;\n\n\ndelete from reclada.object \n    where guid in (select reclada_object.get_GUID_for_class('Asset'));\n\ndelete from reclada.object \n    where guid in (select reclada_object.get_GUID_for_class('DBAsset'));\n\nUPDATE reclada.OBJECT\nSET ATTRIBUTES = ATTRIBUTES #- '{schema,properties,object,minLength}'\nWHERE guid IN(SELECT reclada_object.get_GUID_for_class('Relationship'));\n\nUPDATE reclada.OBJECT\nSET ATTRIBUTES = ATTRIBUTES #- '{schema,properties,subject,minLength}'\nWHERE guid IN(SELECT reclada_object.get_GUID_for_class('Relationship'));\n\nDROP OPERATOR IF EXISTS reclada.##(boolean, boolean);\nCREATE OPERATOR reclada.# (\n    FUNCTION = reclada.xor,\n    LEFTARG = boolean,\n    RIGHTARG = boolean\n);\n\n    \nwith g as \n(\n    select g.obj_id\n    from\n    (\n        select s.obj_id, count(*) cnt\n            from reclada.v_DTO_json_schema s\n            join reclada.v_object o\n                on o.obj_id = s.obj_id\n                where s.function = 'reclada_object.list'\n                    group by s.obj_id\n    ) as g\n    left join lateral \n    (\n        select reclada.raise_exception('reclada_object.list has more 2 DTO schema')\n            where g.cnt > 2\n    ) ex  on true\n)\nupdate reclada.object o\n    set status = reclada_object.get_active_status_obj_id()\n    from g\n        where g.obj_id = o.guid;\n\ndelete from reclada.object \n    where id =\n    (\n        SELECT max(id)\n            FROM reclada.v_object \n                where class_name = 'DTOJsonSchema' \n                    and attrs->>'function' = 'reclada_object.list' \n    );	2021-12-28 14:18:07.480088+00
46	45	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 45 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nCREATE TYPE reclada.dp_bhvr AS ENUM ('Replace','Update','Reject','Copy','Insert','Merge');\n\nALTER TABLE reclada.draft ADD COLUMN IF NOT EXISTS parent_guid uuid;\nDELETE FROM reclada.draft WHERE guid IS NULL;\nALTER TABLE reclada.draft ALTER COLUMN guid SET NOT NULL;\nALTER VIEW reclada.v_filter_avaliable_operator RENAME TO v_filter_available_operator;\n\nDROP VIEW reclada.v_pk_for_class;\n\ni 'view/reclada.v_object_unifields.sql'\ni 'view/reclada.v_parent_field.sql'\ni 'function/reclada.get_unifield_index_name.sql'\ni 'view/reclada.v_unifields_pivoted.sql'\n\ni 'function/reclada_object.get_parent_guid.sql'\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/reclada_object.merge.sql'\ni 'function/reclada_object.update_json.sql'\ni 'function/reclada_object.update_json_by_guid.sql'\ni 'function/reclada_object.remove_parent_guid.sql'\ni 'function/reclada_object.create_relationship.sql'\ni 'function/reclada_object.create_job.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.create_subclass.sql'\ni 'function/reclada_object.delete.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.refresh_mv.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada.get_children.sql'\ni 'function/reclada_object.datasource_insert.sql'\ni 'function/reclada.get_duplicates.sql'\ni 'function/reclada_object.parse_filter.sql'\n\ni 'function/reclada_object.list.sql'\ni 'function/api.reclada_object_list.sql'\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/api.reclada_object_create.sql'\ni 'function/reclada_object.delete.sql'\n\ni 'view/reclada.v_filter_available_operator.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_ui_active_object.sql'\ni 'view/reclada.v_default_display.sql'\n\nUPDATE reclada.object\nSET attributes = jsonb_set(attributes,'{parentField}','"table"'::jsonb)\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('Cell')) and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = jsonb_set(attributes,'{parentField}','"page"'::jsonb)\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('Table')) and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = jsonb_set(attributes,'{parentField}','"document"'::jsonb)\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('Page')) and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = jsonb_set(attributes,'{parentField}','"fileGUID"'::jsonb)\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('Document')) and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = jsonb_set(attributes,'{parentField}','"table"'::jsonb)\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('DataRow')) and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = jsonb_set(attributes,'{dupBehavior}','"Replace"'::jsonb)\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('File')) and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = jsonb_set(attributes,'{isCascade}','true'::jsonb)\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('File')) and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = jsonb_set(attributes,'{dupChecking}','[{"uniFields" : ["uri"], "isMandatory" : true}, {"uniFields" : ["checksum"], "isMandatory" : true}]'::jsonb)\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('File')) and status = reclada_object.get_active_status_obj_id();\n\nSELECT reclada_object.refresh_mv('uniFields');\n\n\nCREATE INDEX uri_index_ ON reclada.object USING HASH (((attributes->>'uri')));\nCREATE INDEX checksum_index_ ON reclada.object USING HASH (((attributes->>'checksum')));\n\n\nDROP INDEX reclada.status_index;\n\nselect reclada.raise_exception('can''t find 2 DTOJsonSchema for reclada_object.list', 'up_script.sql')\n    where \n        (\n            select count(*)\n                from reclada.object\n                    where attributes->>'function' = 'reclada_object.list'\n                        and class in (select reclada_object.get_guid_for_class('DTOJsonSchema'))\n        ) != 2;\n\n--{ display\nwith t as\n( \n    update reclada.object\n        set status = reclada_object.get_active_status_obj_id()\n        where attributes->>'function' = 'reclada_object.list'\n            and class in (select reclada_object.get_guid_for_class('DTOJsonSchema'))\n            and status = reclada_object.get_archive_status_obj_id()\n        returning id\n)\n    update reclada.object\n        set status = reclada_object.get_archive_status_obj_id()\n        where attributes->>'function' = 'reclada_object.list'\n            and class in (select reclada_object.get_guid_for_class('DTOJsonSchema'))\n            and id not in (select id from t);\n\ni 'function/reclada.jsonb_deep_set.sql'\n--} display\n\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, current version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\nUPDATE reclada.object\nSET attributes = attributes - 'parentField'\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('Cell'))\n    and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = attributes - 'parentField'\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('Table'))\n    and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = attributes - 'parentField'\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('Page'))\n    and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = attributes - 'parentField'\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('Document'))\n    and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = attributes - 'parentField'\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('DataRow'))\n    and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = attributes - 'dupBehavior'\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('File'))\n    and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = attributes - 'isCascade'\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('File'))\n    and status = reclada_object.get_active_status_obj_id();\n\nUPDATE reclada.object\nSET attributes = attributes - 'dupChecking'\nWHERE guid IN (SELECT reclada_object.get_guid_for_class('File'))\n    and status = reclada_object.get_active_status_obj_id();\n\nDROP view IF EXISTS reclada.v_parent_field ;\n\nDROP view IF EXISTS reclada.v_unifields_pivoted ;\n\nDROP MATERIALIZED VIEW       reclada.v_object_unifields;\n\nDROP function IF EXISTS reclada.get_unifield_index_name ;\n\nDROP function IF EXISTS reclada_object.merge ;\n\nDROP function IF EXISTS reclada.get_children ;\n\nDROP function IF EXISTS reclada.get_duplicates ;\n\nDROP function IF EXISTS reclada_object.update_json_by_guid ;\n\nDROP function IF EXISTS reclada_object.update_json ;\n\nDROP function IF EXISTS reclada_object.remove_parent_guid ;\n\nDROP function IF EXISTS reclada_object.get_parent_guid ;\n\n\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition_filter(data jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE \r\n    _count   INT;\r\n    _res     TEXT;\r\n    _f_name TEXT = 'reclada_object.get_query_condition_filter';\r\nBEGIN \r\n    \r\n    perform reclada.validate_json(data, _f_name);\r\n    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE\r\n    CREATE TEMP TABLE mytable AS\r\n        SELECT  res.lvl              AS lvl         , \r\n                res.rn               AS rn          , \r\n                res.idx              AS idx         ,\r\n                res.prev             AS prev        , \r\n                res.val              AS val         ,  \r\n                res.parsed           AS parsed      , \r\n                coalesce(\r\n                    po.inner_operator, \r\n                    op.operator\r\n                )                   AS op           , \r\n                coalesce\r\n                (\r\n                    iop.input_type,\r\n                    op.input_type\r\n                )                   AS input_type   ,\r\n                case \r\n                    when iop.input_type is not NULL \r\n                        then NULL \r\n                    else \r\n                        op.output_type\r\n                end                 AS output_type  ,\r\n                po.operator         AS po           ,\r\n                po.input_type       AS po_input_type,\r\n                iop.brackets        AS po_inner_brackets\r\n            FROM reclada_object.parse_filter(data) res\r\n            LEFT JOIN reclada.v_filter_avaliable_operator op\r\n                ON res.op = op.operator\r\n            LEFT JOIN reclada_object.parse_filter(data) p\r\n                on  p.lvl = res.lvl-1\r\n                    and res.prev = p.rn\r\n            LEFT JOIN reclada.v_filter_avaliable_operator po\r\n                on po.operator = p.op\r\n            LEFT JOIN reclada.v_filter_inner_operator iop\r\n                on iop.operator = po.inner_operator;\r\n\r\n    PERFORM reclada.raise_exception('Operator does not allowed ' || t.op, _f_name)\r\n        FROM mytable t\r\n            WHERE t.op IS NULL;\r\n\r\n\r\n    UPDATE mytable u\r\n        SET parsed = to_jsonb(p.v)\r\n            FROM mytable t\r\n            JOIN LATERAL \r\n            (\r\n                SELECT  t.parsed #>> '{}' v\r\n            ) as pt\r\n                ON TRUE\r\n            LEFT JOIN reclada.v_filter_mapping fm\r\n                ON pt.v = fm.pattern\r\n            JOIN LATERAL \r\n            (\r\n                SELECT CASE \r\n                        WHEN fm.repl is not NULL \r\n                            then \r\n                                case \r\n                                    when t.input_type in ('TEXT')\r\n                                        then fm.repl || '::TEXT'\r\n                                    else '(''"''||' ||fm.repl ||'||''"'')::jsonb' -- don't use FORMAT (concat null)\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) in ('number', 'boolean')\r\n                            then \r\n                                case \r\n                                    when t.input_type in ('NUMERIC','INT')\r\n                                        then pt.v\r\n                                    else '''' || pt.v || '''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'string' \r\n                            then    \r\n                                case\r\n                                    WHEN pt.v LIKE '{%}'\r\n                                        THEN\r\n                                            case\r\n                                                when t.input_type = 'TEXT'\r\n                                                    then format('(data #>> ''%s'')', pt.v)\r\n                                                when t.input_type = 'JSONB' or t.input_type is null\r\n                                                    then format('data #> ''%s''', pt.v)\r\n                                                else\r\n                                                    format('(data #>> ''%s'')::', pt.v) || t.input_type\r\n                                            end\r\n                                    when t.input_type = 'TEXT'\r\n                                        then ''''||REPLACE(pt.v,'''','''''')||''''\r\n                                    when t.input_type = 'JSONB' or t.input_type is null\r\n                                        then '''"'||REPLACE(pt.v,'''','''''')||'"''::jsonb'\r\n                                    else ''''||REPLACE(pt.v,'''','''''')||'''::'||t.input_type\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'null'\r\n                            then 'null'\r\n                        WHEN jsonb_typeof(t.parsed) = 'array'\r\n                            then ''''||REPLACE(pt.v,'''','''''')||'''::jsonb'\r\n                        ELSE\r\n                            pt.v\r\n                    END AS v\r\n            ) as p\r\n                ON TRUE\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND t.parsed IS NOT NULL;\r\n\r\n    update mytable u\r\n        set op = CASE \r\n                    when f.btwn\r\n                        then ' BETWEEN '\r\n                    else u.op -- f.inop\r\n                end,\r\n            parsed = format(vb.operand_format,u.parsed)::jsonb\r\n        FROM mytable t\r\n        join lateral\r\n        (\r\n            select  t.op like ' %/BETWEEN ' btwn, \r\n                    t.po_inner_brackets is not null inop\r\n        ) f \r\n            on true\r\n        join reclada.v_filter_between vb\r\n            on t.op = vb.operator\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND (f.btwn or f.inop);\r\n\r\n    INSERT INTO mytable (lvl,rn)\r\n        VALUES (0,0);\r\n\r\n    _count := 1;\r\n\r\n    WHILE (_count>0) LOOP\r\n        WITH r AS \r\n        (\r\n            UPDATE mytable\r\n                SET parsed = to_json(t.converted)::JSONB \r\n                FROM \r\n                (\r\n                    SELECT     \r\n                            res.lvl-1 lvl,\r\n                            res.prev rn,\r\n                            res.op,\r\n                            1 q,\r\n                            case \r\n                                when not res.po_inner_brackets \r\n                                    then array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) \r\n                                else\r\n                                    CASE COUNT(1) \r\n                                        WHEN 1\r\n                                            THEN \r\n                                                CASE res.output_type\r\n                                                    when 'NUMERIC'\r\n                                                        then format('(%s %s)::TEXT::JSONB', res.op, min(res.parsed #>> '{}') )\r\n                                                    else \r\n                                                        format('(%s %s)', res.op, min(res.parsed #>> '{}') )\r\n                                                end\r\n                                        ELSE\r\n                                            CASE \r\n                                                when res.output_type = 'TEXT'\r\n                                                    then '(''"''||'||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||'||''"'')::JSONB'\r\n                                                when res.output_type in ('NUMERIC','INT')\r\n                                                    then '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')::TEXT::JSONB'\r\n                                                else\r\n                                                    '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')'\r\n                                            end\r\n                                    end\r\n                            end AS converted\r\n                        FROM mytable res \r\n                            WHERE res.parsed IS NOT NULL\r\n                                AND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)\r\n                            GROUP BY  res.prev, res.op, res.lvl, res.input_type, res.output_type, res.po_inner_brackets\r\n                ) t\r\n                WHERE\r\n                    t.lvl = mytable.lvl\r\n                        AND t.rn = mytable.rn\r\n                RETURNING 1\r\n        )\r\n            SELECT COUNT(1) \r\n                FROM r\r\n                INTO _count;\r\n    END LOOP;\r\n    \r\n    SELECT parsed #>> '{}' \r\n        FROM mytable\r\n            WHERE lvl = 0 AND rn = 0\r\n        INTO _res;\r\n    -- perform reclada.raise_notice( _res);\r\n    DROP TABLE mytable;\r\n    RETURN _res;\r\nEND \r\n$function$\n;\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    data          jsonb;\r\n    class_name    text;\r\n    class_uuid    uuid;\r\n    tran_id       bigint;\r\n    _attrs         jsonb;\r\n    schema        jsonb;\r\n    obj_GUID      uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    _parent_guid  uuid;\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision and others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    FOR data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n\r\n        class_name := data->>'class';\r\n\r\n        IF (class_name IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n        class_uuid := reclada.try_cast_uuid(class_name);\r\n\r\n        _attrs := data->'attributes';\r\n        IF (_attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        tran_id := (data->>'transactionID')::bigint;\r\n        if tran_id is null then\r\n            tran_id := reclada.get_transaction_id();\r\n        end if;\r\n\r\n        IF class_uuid IS NULL THEN\r\n            SELECT reclada_object.get_schema(class_name) \r\n            INTO schema;\r\n            class_uuid := (schema->>'GUID')::uuid;\r\n        ELSE\r\n            SELECT v.data \r\n            FROM reclada.v_class v\r\n            WHERE class_uuid = v.obj_id\r\n            INTO schema;\r\n        END IF;\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', class_name;\r\n        END IF;\r\n\r\n        IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', _attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n        END IF;\r\n        \r\n        IF data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        IF class_uuid IN (SELECT guid FROM reclada.v_PK_for_class)\r\n        THEN\r\n            SELECT o.obj_id\r\n                FROM reclada.v_object o\r\n                JOIN reclada.v_PK_for_class pk\r\n                    on pk.guid = o.class\r\n                        and class_uuid = o.class\r\n                where o.attrs->>pk.pk = _attrs ->> pk.pk\r\n                LIMIT 1\r\n            INTO obj_GUID;\r\n            IF obj_GUID IS NOT NULL THEN\r\n                SELECT reclada_object.update(data || format('{"GUID": "%s"}', obj_GUID)::jsonb)\r\n                    INTO res;\r\n                    RETURN '[]'::jsonb || res;\r\n            END IF;\r\n        END IF;\r\n\r\n        obj_GUID := (data->>'GUID')::uuid;\r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.object \r\n            WHERE GUID = obj_GUID\r\n        ) THEN\r\n            RAISE EXCEPTION 'GUID: % is duplicate', obj_GUID;\r\n        END IF;\r\n        --raise notice 'schema: %',schema;\r\n\r\n        _parent_guid = (data->>'parent_guid')::uuid;\r\n\r\n        INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n            SELECT  CASE\r\n                        WHEN obj_GUID IS NULL\r\n                            THEN public.uuid_generate_v4()\r\n                        ELSE obj_GUID\r\n                    END AS GUID,\r\n                    class_uuid, \r\n                    _attrs,\r\n                    tran_id,\r\n                    _parent_guid\r\n        RETURNING GUID INTO obj_GUID;\r\n        affected := array_append( affected, obj_GUID);\r\n\r\n        PERFORM reclada_object.datasource_insert\r\n            (\r\n                class_name,\r\n                obj_GUID,\r\n                _attrs\r\n            );\r\n\r\n        PERFORM reclada_object.refresh_mv(class_name);\r\n    END LOOP;\r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb; \r\n    \r\n    delete from reclada.draft \r\n        where guid = ANY (affected);\r\n\r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            res\r\n        );\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    new_class       text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n    version_         integer;\r\n    class_guid    uuid;\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    attrs := data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    new_class = attrs->>'newClass';\r\n\r\n    SELECT reclada_object.get_schema(class) INTO class_schema;\r\n\r\n    IF (class_schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', class;\r\n    END IF;\r\n\r\n    SELECT max(version) + 1\r\n    FROM reclada.v_class_lite v\r\n    WHERE v.for_class = new_class\r\n    INTO version_;\r\n\r\n    version_ := coalesce(version_,1);\r\n    class_schema := class_schema->'attributes'->'schema';\r\n\r\n    SELECT obj_id\r\n    FROM reclada.v_class\r\n    WHERE for_class = class\r\n    ORDER BY version DESC\r\n    LIMIT 1\r\n    INTO class_guid;\r\n\r\n    PERFORM reclada_object.create(format('{\r\n        "class": "jsonschema",\r\n        "attributes": {\r\n            "forClass": "%s",\r\n            "version": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n            }\r\n        },\r\n        "parent_guid" : "%s"\r\n    }',\r\n    new_class,\r\n    version_,\r\n    (class_schema->'properties') || coalesce((attrs->'properties'),'{}'::jsonb),\r\n    (SELECT jsonb_agg(el) FROM (\r\n        SELECT DISTINCT pg_catalog.jsonb_array_elements(\r\n            (class_schema -> 'required') || coalesce((attrs -> 'required'),'{}'::jsonb)\r\n        ) el) arr),\r\n    class_guid\r\n    )::jsonb);\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.refresh_mv ;\nCREATE OR REPLACE FUNCTION reclada_object.refresh_mv(class_name text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    CASE class_name\r\n        WHEN 'ObjectStatus' THEN\r\n            REFRESH MATERIALIZED VIEW reclada.v_object_status;\r\n        WHEN 'User' THEN\r\n            REFRESH MATERIALIZED VIEW reclada.v_user;\r\n        WHEN 'jsonschema' THEN\r\n            REFRESH MATERIALIZED VIEW reclada.v_class_lite;\r\n        ELSE\r\n            NULL;\r\n    END CASE;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _class_name     text;\r\n    class_uuid     uuid;\r\n    v_obj_id       uuid;\r\n    v_attrs        jsonb;\r\n    schema        jsonb;\r\n    old_obj       jsonb;\r\n    branch        uuid;\r\n    revid         uuid;\r\n\r\nBEGIN\r\n\r\n    _class_name := data->>'class';\r\n    IF (_class_name IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n    class_uuid := reclada.try_cast_uuid(_class_name);\r\n    v_obj_id := data->>'GUID';\r\n    IF (v_obj_id IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no GUID';\r\n    END IF;\r\n\r\n    v_attrs := data->'attributes';\r\n    IF (v_attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    SELECT reclada_object.get_schema(_class_name) \r\n        INTO schema;\r\n\r\n    if class_uuid is null then\r\n        SELECT reclada_object.get_schema(_class_name) \r\n            INTO schema;\r\n    else\r\n        select v.data, v.for_class \r\n            from reclada.v_class v\r\n                where class_uuid = v.obj_id\r\n            INTO schema, _class_name;\r\n    end if;\r\n    -- TODO: don't allow update jsonschema\r\n    IF (schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', _class_name;\r\n    END IF;\r\n\r\n    IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', v_attrs))) THEN\r\n        RAISE EXCEPTION 'JSON invalid: %', v_attrs;\r\n    END IF;\r\n\r\n    SELECT \tv.data\r\n        FROM reclada.v_object v\r\n\t        WHERE v.obj_id = v_obj_id\r\n                AND v.class_name = _class_name \r\n\t    INTO old_obj;\r\n\r\n    IF (old_obj IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object, no such id';\r\n    END IF;\r\n\r\n    branch := data->'branch';\r\n    SELECT reclada_revision.create(user_info->>'sub', branch, v_obj_id) \r\n        INTO revid;\r\n    \r\n    with t as \r\n    (\r\n        update reclada.object o\r\n            set status = reclada_object.get_archive_status_obj_id()\r\n                where o.GUID = v_obj_id\r\n                    and status != reclada_object.get_archive_status_obj_id()\r\n                        RETURNING id\r\n    )\r\n    INSERT INTO reclada.object( GUID,\r\n                                class,\r\n                                status,\r\n                                attributes,\r\n                                transaction_id\r\n                              )\r\n        select  v.obj_id,\r\n                (schema->>'GUID')::uuid,\r\n                reclada_object.get_active_status_obj_id(),--status \r\n                v_attrs || format('{"revision":"%s"}',revid)::jsonb,\r\n                transaction_id\r\n            FROM reclada.v_object v\r\n            JOIN \r\n            (   \r\n                select id \r\n                    FROM \r\n                    (\r\n                        select id, 1 as q\r\n                            from t\r\n                        union \r\n                        select id, 2 as q\r\n                            from reclada.object ro\r\n                                where ro.guid = v_obj_id\r\n                                    ORDER BY ID DESC \r\n                                        LIMIT 1\r\n                    ) ta\r\n                    ORDER BY q ASC \r\n                        LIMIT 1\r\n            ) as tt\r\n                on tt.id = v.id\r\n\t            WHERE v.obj_id = v_obj_id;\r\n    PERFORM reclada_object.datasource_insert\r\n            (\r\n                _class_name,\r\n                v_obj_id,\r\n                v_attrs\r\n            );\r\n    PERFORM reclada_object.refresh_mv(_class_name);  \r\n                  \r\n    select v.data \r\n        FROM reclada.v_active_object v\r\n            WHERE v.obj_id = v_obj_id\r\n        into data;\r\n    PERFORM reclada_notification.send_object_notification('update', data);\r\n    RETURN data;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.datasource_insert ;\nCREATE OR REPLACE FUNCTION reclada_object.datasource_insert(_class_name text, _obj_id uuid, attributes jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _pipeline_lite jsonb;\r\n    _task  jsonb;\r\n    _dataset_guid  uuid;\r\n    _new_guid  uuid;\r\n    _pipeline_job_guid  uuid;\r\n    _stage         text;\r\n    _uri           text;\r\n    _environment   varchar;\r\n    _rel_cnt       int;\r\n    _dataset2ds_type text = 'defaultDataSet to DataSource';\r\n    _f_name text = 'reclada_object.datasource_insert';\r\nBEGIN\r\n    IF _class_name in ('DataSource','File') THEN\r\n\r\n        _uri := attributes->>'uri';\r\n\r\n\r\n        SELECT v.obj_id\r\n        FROM reclada.v_active_object v\r\n        WHERE v.class_name = 'DataSet'\r\n            and v.attrs->>'name' = 'defaultDataSet'\r\n        INTO _dataset_guid;\r\n\r\n        SELECT count(*)\r\n        FROM reclada.v_active_object\r\n        WHERE class_name = 'Relationship'\r\n            AND (attrs->>'object')::uuid = _obj_id\r\n            AND (attrs->>'subject')::uuid = _dataset_guid\r\n            AND attrs->>'type' = _dataset2ds_type\r\n                INTO _rel_cnt;\r\n\r\n        SELECT attrs->>'Environment'\r\n            FROM reclada.v_active_object\r\n                WHERE class_name = 'Context'\r\n                ORDER BY created_time DESC\r\n                LIMIT 1\r\n            INTO _environment;\r\n        IF _rel_cnt=0 THEN\r\n            PERFORM reclada_object.create(\r\n                    format('{\r\n                        "class": "Relationship",\r\n                        "attributes": {\r\n                            "type": "%s",\r\n                            "object": "%s",\r\n                            "subject": "%s"\r\n                            }\r\n                        }', _dataset2ds_type, _obj_id, _dataset_guid\r\n                    )::jsonb\r\n                );\r\n\r\n        END IF;\r\n        if _uri like '%inbox/jobs/%' then\r\n        \r\n            PERFORM reclada_object.create(\r\n                    format('{\r\n                        "class": "Job",\r\n                        "attributes": {\r\n                            "task": "c94bff30-15fa-427f-9954-d5c3c151e652",\r\n                            "status": "new",\r\n                            "type": "%s",\r\n                            "command": "./run_pipeline.sh",\r\n                            "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\r\n                            }\r\n                        }', _environment, _uri, _obj_id\r\n                    )::jsonb\r\n                );\r\n        \r\n        ELSE\r\n            \r\n            SELECT data \r\n                FROM reclada.v_active_object\r\n                    WHERE class_name = 'PipelineLite'\r\n                        LIMIT 1\r\n                INTO _pipeline_lite;\r\n            _new_guid := public.uuid_generate_v4();\r\n            IF _uri like '%inbox/pipelines/%/%' then\r\n                \r\n                _stage := SPLIT_PART(\r\n                                SPLIT_PART(_uri,'inbox/pipelines/',2),\r\n                                '/',\r\n                                2\r\n                            );\r\n                _stage = replace(_stage,'.json','');\r\n                SELECT data \r\n                    FROM reclada.v_active_object o\r\n                        where o.class_name = 'Task'\r\n                            and o.obj_id = (_pipeline_lite #>> ('{attributes,tasks,'||_stage||'}')::text[])::uuid\r\n                    into _task;\r\n                \r\n                _pipeline_job_guid = reclada.try_cast_uuid(\r\n                                        SPLIT_PART(\r\n                                            SPLIT_PART(_uri,'inbox/pipelines/',2),\r\n                                            '/',\r\n                                            1\r\n                                        )\r\n                                    );\r\n                if _pipeline_job_guid is null then \r\n                    perform reclada.raise_exception('PIPELINE_JOB_GUID not found',_f_name);\r\n                end if;\r\n                \r\n                SELECT  data #>> '{attributes,inputParameters,0,uri}',\r\n                        (data #>> '{attributes,inputParameters,1,dataSourceId}')::uuid\r\n                    from reclada.v_active_object o\r\n                        where o.obj_id = _pipeline_job_guid\r\n                    into _uri, _obj_id;\r\n\r\n            ELSE\r\n                SELECT data \r\n                    FROM reclada.v_active_object o\r\n                        where o.class_name = 'Task'\r\n                            and o.obj_id = (_pipeline_lite #>> '{attributes,tasks,0}')::uuid\r\n                    into _task;\r\n                _pipeline_job_guid := _new_guid;\r\n            END IF;\r\n            \r\n            PERFORM reclada_object.create(\r\n                format('{\r\n                    "GUID":"%s",\r\n                    "class": "Job",\r\n                    "attributes": {\r\n                        "task": "%s",\r\n                        "status": "new",\r\n                        "type": "%s",\r\n                        "command": "%s",\r\n                        "inputParameters": [\r\n                                { "uri"                 :"%s"   }, \r\n                                { "dataSourceId"        :"%s"   },\r\n                                { "PipelineLiteJobGUID" :"%s"   }\r\n                            ]\r\n                        }\r\n                    }',\r\n                        _new_guid::text,\r\n                        _task->>'GUID',\r\n                        _environment, \r\n                        _task-> 'attributes' ->>'command',\r\n                        _uri,\r\n                        _obj_id,\r\n                        _pipeline_job_guid::text\r\n                )::jsonb\r\n            );\r\n\r\n        END IF;\r\n    END IF;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.parse_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.parse_filter(data jsonb)\n RETURNS TABLE(lvl integer, rn bigint, idx bigint, op text, prev bigint, val jsonb, parsed jsonb)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\n    WITH RECURSIVE f AS \r\n    (\r\n        SELECT data AS v\r\n    ),\r\n    pr AS \r\n    (\r\n        SELECT \tformat(' %s ',f.v->>'operator') AS op, \r\n                val.v AS val,\r\n                1 AS lvl,\r\n                row_number() OVER(ORDER BY idx) AS rn,\r\n                val.idx idx,\r\n                0::BIGINT prev\r\n            FROM f, jsonb_array_elements(f.v->'value') WITH ordinality AS val(v, idx)\r\n    ),\r\n    res AS\r\n    (\t\r\n        SELECT \tpr.lvl\t,\r\n                pr.rn\t,\r\n                pr.idx  ,\r\n                pr.op\t,\r\n                pr.prev ,\r\n                pr.val\t,\r\n                CASE jsonb_typeof(pr.val) \r\n                    WHEN 'object'\t\r\n                        THEN NULL\r\n                    ELSE pr.val\r\n                END AS parsed\r\n            FROM pr\r\n            WHERE prev = 0 \r\n                AND lvl = 1\r\n        UNION ALL\r\n        SELECT \tttt.lvl\t,\r\n                ROW_NUMBER() OVER(ORDER BY ttt.idx) AS rn,\r\n                ttt.idx,\r\n                ttt.op\t,\r\n                ttt.prev,\r\n                ttt.val ,\r\n                CASE jsonb_typeof(ttt.val) \r\n                    WHEN 'object'\t\r\n                        THEN NULL\r\n                    ELSE ttt.val\r\n                end AS parsed\r\n            FROM\r\n            (\r\n                SELECT \tres.lvl + 1 AS lvl,\r\n                        format(' %s ',res.val->>'operator') AS op,\r\n                        res.rn AS prev\t,\r\n                        val.v  AS val,\r\n                        val.idx\r\n                    FROM res, \r\n                         jsonb_array_elements(res.val->'value') WITH ordinality AS val(v, idx)\r\n            ) ttt\r\n    )\r\n    SELECT \tr.lvl\t,\r\n            r.rn\t,\r\n            r.idx   ,\r\n            case upper(r.op) \r\n                when ' XOR '\r\n                    then ' OPERATOR(reclada.##) ' \r\n                else upper(r.op) \r\n            end,\r\n            r.prev  ,\r\n            r.val\t,\r\n            r.parsed\r\n        FROM res r\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false, ver text DEFAULT '1'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    _class              text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\n    _object_display     JSONB;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    _class := data->>'class';\r\n    _filter = data->'filter';\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    \r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n        IF ver = '2' THEN\r\n            query_conditions := REPLACE(query_conditions,'#>','->');\r\n        end if;\r\n    ELSE\r\n        class_uuid := reclada.try_cast_uuid(_class);\r\n\r\n        IF (class_uuid IS NULL) THEN\r\n            SELECT v.obj_id\r\n                FROM reclada.v_class v\r\n                    WHERE _class = v.for_class\r\n                    ORDER BY v.version DESC\r\n                    limit 1 \r\n            INTO class_uuid;\r\n            IF (class_uuid IS NULL) THEN\r\n                RAISE EXCEPTION 'Class not found: %', _class;\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', _class) AS condition\r\n                        where _class is not null\r\n                            and class_uuid is null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    IF ver = '2' THEN\r\n        query := 'FROM reclada.v_ui_active_object obj WHERE ' || query_conditions;\r\n    ELSE\r\n        query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n    END IF;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             '\r\n    --             || query\r\n    --             ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    objects := coalesce(objects,'[]'::jsonb);\r\n    IF gui THEN\r\n\r\n        if ver = '2' then\r\n            -- raise notice 'od: %',_object_display;\r\n            EXECUTE '   with recursive \r\n                        d as ( \r\n                            select  obj_id, data\r\n                                '|| query ||'\r\n                        ),\r\n                        t as\r\n                        (\r\n                            select distinct je.key v\r\n                                from d\r\n                                JOIN LATERAL jsonb_each(d.data) je\r\n                                    on true \r\n                        ),\r\n                        on_data as \r\n                        (\r\n                            select  jsonb_object_agg(\r\n                                        t.v, \r\n                                        replace(dd.template,''#@#attrname#@#'',t.v)::jsonb \r\n                                    ) t\r\n                                from t\r\n                                JOIN reclada.v_default_display dd\r\n                                    on t.v like ''%'' || dd.json_type\r\n                        )\r\n                        select od.t || coalesce(d.table,''{}''::jsonb)\r\n                            from on_data od\r\n                            left join reclada.v_object_display d\r\n                                on d.class_guid = '''||class_uuid::text||''''\r\n            INTO _object_display;\r\n\r\n        end if;\r\n        EXECUTE E'SELECT COUNT(1),\r\n                         TO_CHAR(\r\n                            MAX(\r\n                                GREATEST(obj.created_time, (\r\n                                    SELECT TO_TIMESTAMP(MAX(date_time),\\'YYYY-MM-DD hh24:mi:ss.US TZH\\')\r\n                                    FROM reclada.v_revision vr\r\n                                    WHERE vr.obj_id = UUID(obj.attrs ->>\\'revision\\'))\r\n                                )\r\n                            ),\\'YYYY-MM-DD hh24:mi:ss.MS TZH\\')\r\n            '|| query\r\n            INTO number_of_objects, last_change;\r\n        \r\n        IF _object_display IS NOT NULL then\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects,\r\n                    'display', _object_display\r\n                );\r\n        ELSE\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects\r\n            );\r\n        end if;\r\n    ELSE\r\n        \r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create_relationship ;\n\nDROP function IF EXISTS reclada_object.create_job ;\n\n\n\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false, ver text DEFAULT '1'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    _class              text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    query               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\n    _object_display     JSONB;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    _class := data->>'class';\r\n    _filter = data->'filter';\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(E'obj.data#>''{%s}'' %s', T.value->>'field', COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    \r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n        IF ver = '2' THEN\r\n            query_conditions := REPLACE(query_conditions,'#>','->');\r\n        end if;\r\n    ELSE\r\n        class_uuid := reclada.try_cast_uuid(_class);\r\n\r\n        IF (class_uuid IS NULL) THEN\r\n            SELECT v.obj_id\r\n                FROM reclada.v_class v\r\n                    WHERE _class = v.for_class\r\n                    ORDER BY v.version DESC\r\n                    limit 1 \r\n            INTO class_uuid;\r\n            IF (class_uuid IS NULL) THEN\r\n                RAISE EXCEPTION 'Class not found: %', _class;\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', _class) AS condition\r\n                        where _class is not null\r\n                            and class_uuid is null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    IF ver = '2' THEN\r\n        query := 'FROM reclada.v_ui_active_object obj WHERE ' || query_conditions;\r\n    ELSE\r\n        query := 'FROM reclada.v_active_object obj WHERE ' || query_conditions;\r\n    END IF;\r\n\r\n    -- RAISE NOTICE 'conds: %', '\r\n    --             SELECT obj.data\r\n    --             '\r\n    --             || query\r\n    --             ||\r\n    --             ' ORDER BY ' || order_by ||\r\n    --             ' OFFSET ' || offset_ || ' LIMIT ' || limit_ ;\r\n\r\n    EXECUTE E'SELECT to_jsonb(array_agg(T.data))\r\n        FROM (\r\n            SELECT obj.data\r\n            '\r\n            || query\r\n            ||\r\n            ' ORDER BY ' || order_by ||\r\n            ' OFFSET ' || offset_ || ' LIMIT ' || limit_ || ') T'\r\n    INTO objects;\r\n    objects := coalesce(objects,'[]'::jsonb);\r\n    IF gui THEN\r\n\r\n        if ver = '2' then\r\n            -- raise notice 'od: %',_object_display;\r\n            EXECUTE '   with recursive \r\n                        d as ( \r\n                            select  obj_id, data\r\n                                '|| query ||'\r\n                        ),\r\n                        t as\r\n                        (\r\n                            select distinct je.key v\r\n                                from d\r\n                                JOIN LATERAL jsonb_each(d.data) je\r\n                                    on true \r\n                        ),\r\n                        on_data as \r\n                        (\r\n                            select  jsonb_object_agg(\r\n                                        t.v, \r\n                                        replace(dd.template,''#@#attrname#@#'',t.v)::jsonb \r\n                                    ) t\r\n                                from t\r\n                                JOIN reclada.v_default_display dd\r\n                                    on t.v like ''%'' || dd.json_type\r\n                        )\r\n                        select od.t || coalesce(d.table,''{}''::jsonb)\r\n                            from on_data od\r\n                            left join reclada.v_object_display d\r\n                                on d.class_guid = '''||class_uuid::text||''''\r\n            INTO _object_display;\r\n\r\n        end if;\r\n        EXECUTE E'SELECT COUNT(1),\r\n                         TO_CHAR(\r\n                            MAX(\r\n                                GREATEST(obj.created_time, (\r\n                                    SELECT TO_TIMESTAMP(MAX(date_time),\\'YYYY-MM-DD hh24:mi:ss.US TZH\\')\r\n                                    FROM reclada.v_revision vr\r\n                                    WHERE vr.obj_id = UUID(obj.attrs ->>\\'revision\\'))\r\n                                )\r\n                            ),\\'YYYY-MM-DD hh24:mi:ss.MS TZH\\')\r\n            '|| query\r\n            INTO number_of_objects, last_change;\r\n        \r\n        IF _object_display IS NOT NULL then\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects,\r\n                    'display', _object_display\r\n                );\r\n        ELSE\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects\r\n            );\r\n        end if;\r\n    ELSE\r\n        \r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_list ;\nCREATE OR REPLACE FUNCTION api.reclada_object_list(data jsonb DEFAULT NULL::jsonb, ver text DEFAULT '1'::text, draft text DEFAULT 'false'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _class              text;\r\n    user_info           jsonb;\r\n    result              jsonb;\r\n    _filter             jsonb;\r\nBEGIN\r\n\r\n    if draft != 'false' then\r\n        return array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                        FROM reclada.draft o\r\n                            where id = \r\n                                (\r\n                                    select max(id) \r\n                                        FROM reclada.draft d\r\n                                            where o.guid = d.guid\r\n                                )\r\n                            -- and o.user = user_info->>'guid'\r\n                )\r\n            )::jsonb;\r\n    end if;\r\n\r\n    _class := CASE ver\r\n                when '1'\r\n                    then data->>'class'\r\n                when '2'\r\n                    then data->>'{class}'\r\n            end;\r\n    IF(_class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    _filter = data->'filter';\r\n    IF _filter IS NOT NULL THEN\r\n        SELECT format(  '{\r\n                            "filter":\r\n                            {\r\n                                "operator":"AND",\r\n                                "value":[\r\n                                    {\r\n                                        "operator":"=",\r\n                                        "value":["{class}","%s"]\r\n                                    },\r\n                                    %s\r\n                                ]\r\n                            }\r\n                        }',\r\n                _class,\r\n                _filter\r\n            )::jsonb \r\n            INTO _filter;\r\n        data := data || _filter;\r\n    ELSE\r\n        data := data || ('{"class":"'|| _class ||'"}')::jsonb;\r\n    --     select format(  '{\r\n    --                         "filter":{\r\n    --                             "operator":"=",\r\n    --                             "value":["{class}","%s"]\r\n    --                         }\r\n    --                     }',\r\n    --             class,\r\n    --             _filter\r\n    --         )::jsonb \r\n    --         INTO _filter;\r\n    END IF;\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'list', _class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list', _class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.list(data, true, ver) \r\n        INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition_filter(data jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE \r\n    _count   INT;\r\n    _res     TEXT;\r\n    _f_name TEXT = 'reclada_object.get_query_condition_filter';\r\nBEGIN \r\n    \r\n    perform reclada.validate_json(data, _f_name);\r\n    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE\r\n    CREATE TEMP TABLE mytable AS\r\n        SELECT  res.lvl              AS lvl         , \r\n                res.rn               AS rn          , \r\n                res.idx              AS idx         ,\r\n                res.prev             AS prev        , \r\n                res.val              AS val         ,  \r\n                res.parsed           AS parsed      , \r\n                coalesce(\r\n                    po.inner_operator, \r\n                    op.operator\r\n                )                   AS op           , \r\n                coalesce\r\n                (\r\n                    iop.input_type,\r\n                    op.input_type\r\n                )                   AS input_type   ,\r\n                case \r\n                    when iop.input_type is not NULL \r\n                        then NULL \r\n                    else \r\n                        op.output_type\r\n                end                 AS output_type  ,\r\n                po.operator         AS po           ,\r\n                po.input_type       AS po_input_type,\r\n                iop.brackets        AS po_inner_brackets\r\n            FROM reclada_object.parse_filter(data) res\r\n            LEFT JOIN reclada.v_filter_avaliable_operator op\r\n                ON res.op = op.operator\r\n            LEFT JOIN reclada_object.parse_filter(data) p\r\n                on  p.lvl = res.lvl-1\r\n                    and res.prev = p.rn\r\n            LEFT JOIN reclada.v_filter_avaliable_operator po\r\n                on po.operator = p.op\r\n            LEFT JOIN reclada.v_filter_inner_operator iop\r\n                on iop.operator = po.inner_operator;\r\n\r\n    PERFORM reclada.raise_exception('Operator does not allowed ' || t.op, _f_name)\r\n        FROM mytable t\r\n            WHERE t.op IS NULL;\r\n\r\n\r\n    UPDATE mytable u\r\n        SET parsed = to_jsonb(p.v)\r\n            FROM mytable t\r\n            JOIN LATERAL \r\n            (\r\n                SELECT  t.parsed #>> '{}' v\r\n            ) as pt\r\n                ON TRUE\r\n            LEFT JOIN reclada.v_filter_mapping fm\r\n                ON pt.v = fm.pattern\r\n            JOIN LATERAL \r\n            (\r\n                SELECT CASE \r\n                        WHEN fm.repl is not NULL \r\n                            then \r\n                                case \r\n                                    when t.input_type in ('TEXT')\r\n                                        then fm.repl || '::TEXT'\r\n                                    else '(''"''||' ||fm.repl ||'||''"'')::jsonb' -- don't use FORMAT (concat null)\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) in ('number', 'boolean')\r\n                            then \r\n                                case \r\n                                    when t.input_type in ('NUMERIC','INT')\r\n                                        then pt.v\r\n                                    else '''' || pt.v || '''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'string' \r\n                            then    \r\n                                case\r\n                                    WHEN pt.v LIKE '{%}'\r\n                                        THEN\r\n                                            case\r\n                                                when t.input_type = 'TEXT'\r\n                                                    then format('(data #>> ''%s'')', pt.v)\r\n                                                when t.input_type = 'JSONB' or t.input_type is null\r\n                                                    then format('data #> ''%s''', pt.v)\r\n                                                else\r\n                                                    format('(data #>> ''%s'')::', pt.v) || t.input_type\r\n                                            end\r\n                                    when t.input_type = 'TEXT'\r\n                                        then ''''||REPLACE(pt.v,'''','''''')||''''\r\n                                    when t.input_type = 'JSONB' or t.input_type is null\r\n                                        then '''"'||REPLACE(pt.v,'''','''''')||'"''::jsonb'\r\n                                    else ''''||REPLACE(pt.v,'''','''''')||'''::'||t.input_type\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'null'\r\n                            then 'null'\r\n                        WHEN jsonb_typeof(t.parsed) = 'array'\r\n                            then ''''||REPLACE(pt.v,'''','''''')||'''::jsonb'\r\n                        ELSE\r\n                            pt.v\r\n                    END AS v\r\n            ) as p\r\n                ON TRUE\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND t.parsed IS NOT NULL;\r\n\r\n    update mytable u\r\n        set op = CASE \r\n                    when f.btwn\r\n                        then ' BETWEEN '\r\n                    else u.op -- f.inop\r\n                end,\r\n            parsed = format(vb.operand_format,u.parsed)::jsonb\r\n        FROM mytable t\r\n        join lateral\r\n        (\r\n            select  t.op like ' %/BETWEEN ' btwn, \r\n                    t.po_inner_brackets is not null inop\r\n        ) f \r\n            on true\r\n        join reclada.v_filter_between vb\r\n            on t.op = vb.operator\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND (f.btwn or f.inop);\r\n\r\n    INSERT INTO mytable (lvl,rn)\r\n        VALUES (0,0);\r\n\r\n    _count := 1;\r\n\r\n    WHILE (_count>0) LOOP\r\n        WITH r AS \r\n        (\r\n            UPDATE mytable\r\n                SET parsed = to_json(t.converted)::JSONB \r\n                FROM \r\n                (\r\n                    SELECT     \r\n                            res.lvl-1 lvl,\r\n                            res.prev rn,\r\n                            res.op,\r\n                            1 q,\r\n                            case \r\n                                when not res.po_inner_brackets \r\n                                    then array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) \r\n                                else\r\n                                    CASE COUNT(1) \r\n                                        WHEN 1\r\n                                            THEN \r\n                                                CASE res.output_type\r\n                                                    when 'NUMERIC'\r\n                                                        then format('(%s %s)::TEXT::JSONB', res.op, min(res.parsed #>> '{}') )\r\n                                                    else \r\n                                                        format('(%s %s)', res.op, min(res.parsed #>> '{}') )\r\n                                                end\r\n                                        ELSE\r\n                                            CASE \r\n                                                when res.output_type = 'TEXT'\r\n                                                    then '(''"''||'||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||'||''"'')::JSONB'\r\n                                                when res.output_type in ('NUMERIC','INT')\r\n                                                    then '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')::TEXT::JSONB'\r\n                                                else\r\n                                                    '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')'\r\n                                            end\r\n                                    end\r\n                            end AS converted\r\n                        FROM mytable res \r\n                            WHERE res.parsed IS NOT NULL\r\n                                AND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)\r\n                            GROUP BY  res.prev, res.op, res.lvl, res.input_type, res.output_type, res.po_inner_brackets\r\n                ) t\r\n                WHERE\r\n                    t.lvl = mytable.lvl\r\n                        AND t.rn = mytable.rn\r\n                RETURNING 1\r\n        )\r\n            SELECT COUNT(1) \r\n                FROM r\r\n                INTO _count;\r\n    END LOOP;\r\n    \r\n    SELECT parsed #>> '{}' \r\n        FROM mytable\r\n            WHERE lvl = 0 AND rn = 0\r\n        INTO _res;\r\n    -- perform reclada.raise_notice( _res);\r\n    DROP TABLE mytable;\r\n    RETURN _res;\r\nEND \r\n$function$\n;\nDROP function IF EXISTS api.reclada_object_create ;\nCREATE OR REPLACE FUNCTION api.reclada_object_create(data jsonb, ver text DEFAULT '1'::text, draft text DEFAULT 'false'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    data_jsonb       jsonb;\r\n    class            text;\r\n    user_info        jsonb;\r\n    attrs            jsonb;\r\n    data_to_create   jsonb = '[]'::jsonb;\r\n    result           jsonb;\r\n    _need_flat       bool := false;\r\n    _draft           bool;\r\n    _guid            uuid;\r\nBEGIN\r\n\r\n    _draft := draft != 'false';\r\n\r\n    IF (jsonb_typeof(data) != 'array') THEN\r\n        data := '[]'::jsonb || data;\r\n    END IF;\r\n\r\n    FOR data_jsonb IN SELECT jsonb_array_elements(data) LOOP\r\n\r\n        _guid := CASE ver\r\n                        when '1'\r\n                            then data_jsonb->>'GUID'\r\n                        when '2'\r\n                            then data_jsonb->>'{GUID}'\r\n                    end;\r\n        if _draft then\r\n            INSERT into reclada.draft(guid,data)\r\n                values(_guid,data_jsonb);\r\n        else\r\n\r\n             class := CASE ver\r\n                            when '1'\r\n                                then data_jsonb->>'class'\r\n                            when '2'\r\n                                then data_jsonb->>'{class}'\r\n                        end;\r\n\r\n            IF (class IS NULL) THEN\r\n                RAISE EXCEPTION 'The reclada object class is not specified (api)';\r\n            END IF;\r\n\r\n            SELECT reclada_user.auth_by_token(data_jsonb->>'accessToken') INTO user_info;\r\n            data_jsonb := data_jsonb - 'accessToken';\r\n\r\n            IF (NOT(reclada_user.is_allowed(user_info, 'create', class))) THEN\r\n                RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'create', class;\r\n            END IF;\r\n            \r\n            if ver = '2' then\r\n                _need_flat := true;\r\n                with recursive j as \r\n                (\r\n                    select  row_number() over() as id,\r\n                            key,\r\n                            value \r\n                        from jsonb_each(data_jsonb)\r\n                            where key like '{%}'\r\n                ),\r\n                inn as \r\n                (\r\n                    SELECT  row_number() over(order by s.id,j.id) rn,\r\n                            j.id,\r\n                            s.id sid,\r\n                            s.d,\r\n                            ARRAY (\r\n                                SELECT UNNEST(arr.v) \r\n                                LIMIT array_position(arr.v, s.d)\r\n                            ) as k\r\n                        FROM j\r\n                        left join lateral\r\n                        (\r\n                            select id, d ,max(id) over() mid\r\n                            from\r\n                            (\r\n                                SELECT  row_number() over() as id, \r\n                                        d\r\n                                    from regexp_split_to_table(substring(j.key,2,char_length(j.key)-2),',') d \r\n                            ) t\r\n                        ) s on s.mid != s.id\r\n                        join lateral\r\n                        (\r\n                            select regexp_split_to_array(substring(j.key,2,char_length(j.key)-2),',') v\r\n                        ) arr on true\r\n                            where d is not null\r\n                ),\r\n                src as\r\n                (\r\n                    select  jsonb_set('{}'::jsonb,('{'|| i.d ||'}')::text[],'{}'::jsonb) r,\r\n                            i.rn\r\n                        from inn i\r\n                            where i.rn = 1\r\n                    union\r\n                    select  jsonb_set(\r\n                                s.r,\r\n                                i.k,\r\n                                '{}'::jsonb\r\n                            ) r,\r\n                            i.rn\r\n                        from src s\r\n                        join inn i\r\n                            on s.rn + 1 = i.rn\r\n                ),\r\n                tmpl as \r\n                (\r\n                    select r v\r\n                        from src\r\n                        ORDER BY rn DESC\r\n                        limit 1\r\n                ),\r\n                res as\r\n                (\r\n                    SELECT jsonb_set(\r\n                            (select v from tmpl),\r\n                            j.key::text[],\r\n                            j.value\r\n                        ) v,\r\n                        j.id\r\n                        FROM j\r\n                            where j.id = 1\r\n                    union \r\n                    select jsonb_set(\r\n                            res.v,\r\n                            j.key::text[],\r\n                            j.value\r\n                        ) v,\r\n                        j.id\r\n                        FROM res\r\n                        join j\r\n                            on res.id + 1 =j.id\r\n                )\r\n                SELECT v \r\n                    FROM res\r\n                    ORDER BY ID DESC\r\n                    limit 1\r\n                    into data_jsonb;\r\n            end if;\r\n\r\n            if data_jsonb is null then\r\n                RAISE EXCEPTION 'JSON invalid';\r\n            end if;\r\n            data_to_create := data_to_create || data_jsonb;\r\n        end if;\r\n    END LOOP;\r\n\r\n    if data_to_create is not  null then\r\n        SELECT reclada_object.create(data_to_create, user_info) \r\n            INTO result;\r\n    end if;\r\n    if ver = '2' or _draft then\r\n        RETURN '{"status":"OK"}'::jsonb;\r\n    end if;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.delete ;\nCREATE OR REPLACE FUNCTION reclada_object.delete(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_obj_id            uuid;\r\n    tran_id             bigint;\r\n    class               text;\r\n    class_uuid          uuid;\r\n    list_id             bigint[];\r\n\r\nBEGIN\r\n\r\n    v_obj_id := data->>'GUID';\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    class := data->>'class';\r\n\r\n    IF (v_obj_id IS NULL AND class IS NULL AND tran_id IS NULl) THEN\r\n        RAISE EXCEPTION 'Could not delete object with no GUID, class and transactionID';\r\n    END IF;\r\n\r\n    class_uuid := reclada.try_cast_uuid(class);\r\n\r\n    WITH t AS\r\n    (    \r\n        UPDATE reclada.object u\r\n            SET status = reclada_object.get_archive_status_obj_id()\r\n            FROM reclada.object o\r\n                LEFT JOIN\r\n                (   SELECT obj_id FROM reclada_object.get_GUID_for_class(class)\r\n                    UNION SELECT class_uuid WHERE class_uuid IS NOT NULL\r\n                ) c ON o.class = c.obj_id\r\n                WHERE u.id = o.id AND\r\n                (\r\n                    (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                )\r\n                    AND o.status != reclada_object.get_archive_status_obj_id()\r\n                    RETURNING o.id\r\n    ) \r\n        SELECT\r\n            array\r\n            (\r\n                SELECT t.id FROM t\r\n            )\r\n        INTO list_id;\r\n\r\n    SELECT array_to_json\r\n    (\r\n        array\r\n        (\r\n            SELECT o.data\r\n            FROM reclada.v_object o\r\n            WHERE o.id IN (SELECT unnest(list_id))\r\n        )\r\n    )::jsonb\r\n    INTO data;\r\n\r\n    IF (jsonb_array_length(data) = 1) THEN\r\n        data := data->0;\r\n    END IF;\r\n    \r\n    IF (data IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not delete object, no such GUID';\r\n    END IF;\r\n\r\n    PERFORM reclada_object.refresh_mv(class);\r\n\r\n    PERFORM reclada_notification.send_object_notification('delete', data);\r\n\r\n    RETURN data;\r\nEND;\r\n$function$\n;\n\nDROP VIEW reclada.v_ui_active_object;\nDROP VIEW reclada.v_revision;\nDROP VIEW reclada.v_import_info;\nDROP VIEW reclada.v_dto_json_schema;\nDROP VIEW reclada.v_class;\nDROP VIEW reclada.v_default_display;\nDROP VIEW reclada.v_filter_available_operator;\nDROP VIEW reclada.v_task;\nDROP VIEW reclada.v_active_object;\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    ( SELECT (r.attributes ->> 'num'::text)::bigint AS num\n           FROM object r\n          WHERE (r.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class)) AND r.guid = NULLIF(t.attributes ->> 'revision'::text, ''::text)::uuid\n         LIMIT 1) AS revision_num,\n    os.caption AS status_caption,\n    NULLIF(t.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID",\n                    t.parent_guid AS "parentGUID",\n                    t.created_time AS "createdTime") tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id,\n    t.parent_guid\n   FROM object t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id,\n    t.parent_guid\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_task ;\nCREATE OR REPLACE VIEW reclada.v_task\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    obj.attrs ->> 'type'::text AS type,\n    obj.attrs ->> 'command'::text AS command,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'Task'::text;\nDROP view IF EXISTS reclada.v_default_display ;\nCREATE OR REPLACE VIEW reclada.v_default_display\nAS\n SELECT 'string'::text AS json_type,\n    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template\nUNION\n SELECT 'number'::text AS json_type,\n    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template\nUNION\n SELECT 'boolean'::text AS json_type,\n    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template;\nDROP view IF EXISTS reclada.v_filter_avaliable_operator ;\nCREATE OR REPLACE VIEW reclada.v_filter_avaliable_operator\nAS\n SELECT ' = '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' LIKE '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' NOT LIKE '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' || '::text AS operator,\n    'TEXT'::text AS input_type,\n    'TEXT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ~ '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !~ '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ~* '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !~* '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' SIMILAR TO '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' > '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' < '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' <= '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' != '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' >= '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' AND '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' OR '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' NOT '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' XOR '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IS '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IS NOT '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IN '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    ' , '::text AS inner_operator\nUNION\n SELECT ' @> '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' <@ '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' + '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' - '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' * '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' / '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' % '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ^ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' |/ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ||/ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !! '::text AS operator,\n    'INT'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' @ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' & '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' | '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' # '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' << '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' >> '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' BETWEEN '::text AS operator,\n    'TIMESTAMP WITH TIME ZONE'::text AS input_type,\n    'BOOL'::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' Y/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' MON/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' D/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' H/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' MIN/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' S/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' DOW/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' DOY/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' Q/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' W/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator;\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    (obj.attrs ->> 'version'::text)::bigint AS version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_pk_for_class ;\nCREATE OR REPLACE VIEW reclada.v_pk_for_class\nAS\n SELECT obj.obj_id AS guid,\n    obj.for_class,\n    pk.pk\n   FROM v_class_lite obj\n     JOIN ( SELECT 'File'::text AS class_name,\n            'uri'::text AS pk\n        UNION\n         SELECT 'DTOJsonSchema'::text AS text,\n            'function'::text AS text) pk ON pk.class_name = obj.for_class;\nDROP view IF EXISTS reclada.v_dto_json_schema ;\nCREATE OR REPLACE VIEW reclada.v_dto_json_schema\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'function'::text AS function,\n    obj.attrs -> 'schema'::text AS schema,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'DTOJsonSchema'::text;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\nDROP view IF EXISTS reclada.v_ui_active_object ;\nCREATE OR REPLACE VIEW reclada.v_ui_active_object\nAS\n WITH RECURSIVE d AS (\n         SELECT obj.data,\n            obj.obj_id\n           FROM v_active_object obj\n        ), t AS (\n         SELECT je.key,\n            jsonb_typeof(je.value) AS typ,\n            d.obj_id,\n            je.value\n           FROM d\n             JOIN LATERAL jsonb_each(d.data) je(key, value) ON true\n          WHERE jsonb_typeof(je.value) <> 'null'::text\n        UNION\n         SELECT (d.key || ','::text) || je.key AS key,\n            jsonb_typeof(je.value) AS typ,\n            d.obj_id,\n            je.value\n           FROM ( SELECT d_1.data -> t_1.key AS data,\n                    t_1.key,\n                    d_1.obj_id\n                   FROM d d_1\n                     JOIN t t_1 ON t_1.typ = 'object'::text) d\n             JOIN LATERAL jsonb_each(d.data) je(key, value) ON true\n          WHERE jsonb_typeof(je.value) <> 'null'::text\n        ), res AS (\n         SELECT t_1.obj_id,\n            jsonb_object_agg((('{'::text || t_1.key) || '}:'::text) || t_1.typ, t_1.value) AS data\n           FROM t t_1\n          WHERE t_1.typ <> 'object'::text\n          GROUP BY t_1.obj_id\n        )\n SELECT res.obj_id,\n    res.data,\n    t.id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.transaction_id,\n    t.parent_guid\n   FROM res\n     JOIN v_active_object t ON t.obj_id = res.obj_id;\n\nDROP view IF EXISTS reclada.v_ui_active_object ;\nCREATE OR REPLACE VIEW reclada.v_ui_active_object\nAS\n WITH RECURSIVE d AS (\n         SELECT obj.data,\n            obj.obj_id\n           FROM v_active_object obj\n        ), t AS (\n         SELECT je.key,\n            jsonb_typeof(je.value) AS typ,\n            d.obj_id,\n            je.value\n           FROM d\n             JOIN LATERAL jsonb_each(d.data) je(key, value) ON true\n          WHERE jsonb_typeof(je.value) <> 'null'::text\n        UNION\n         SELECT (d.key || ','::text) || je.key AS key,\n            jsonb_typeof(je.value) AS typ,\n            d.obj_id,\n            je.value\n           FROM ( SELECT d_1.data -> t_1.key AS data,\n                    t_1.key,\n                    d_1.obj_id\n                   FROM d d_1\n                     JOIN t t_1 ON t_1.typ = 'object'::text) d\n             JOIN LATERAL jsonb_each(d.data) je(key, value) ON true\n          WHERE jsonb_typeof(je.value) <> 'null'::text\n        ), res AS (\n         SELECT t_1.obj_id,\n            jsonb_object_agg((('{'::text || t_1.key) || '}:'::text) || t_1.typ, t_1.value) AS data\n           FROM t t_1\n          WHERE t_1.typ <> 'object'::text\n          GROUP BY t_1.obj_id\n        )\n SELECT res.obj_id,\n    res.data,\n    t.id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.transaction_id,\n    t.parent_guid\n   FROM res\n     JOIN v_active_object t ON t.obj_id = res.obj_id;\nDROP view IF EXISTS reclada.v_default_display ;\nCREATE OR REPLACE VIEW reclada.v_default_display\nAS\n SELECT 'string'::text AS json_type,\n    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template\nUNION\n SELECT 'number'::text AS json_type,\n    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template\nUNION\n SELECT 'boolean'::text AS json_type,\n    '{"caption": "#@#attrname#@#","width": 250,"displayCSS": "#@#attrname#@#"}'::text AS template;\n\nDROP TYPE reclada.dp_bhvr;\n\nDROP INDEX reclada.uri_index_;\nDROP INDEX reclada.checksum_index_;\n\nCREATE INDEX status_index ON reclada.object USING btree (status);\n\nDELETE FROM reclada.draft\nWHERE parent_guid IS NOT NULL;\n\nALTER TABLE reclada.draft DROP COLUMN IF EXISTS parent_guid;\nALTER TABLE reclada.draft ALTER COLUMN guid DROP NOT NULL;\n\nselect reclada.raise_exception('can''t find 2 DTOJsonSchema for reclada_object.list', 'up_script.sql')\n    where \n        (\n            select count(*)\n                from reclada.object\n                    where attributes->>'function' = 'reclada_object.list'\n                        and class in (select reclada_object.get_guid_for_class('DTOJsonSchema'))\n        ) != 2;\n--{ display\nwith t as\n( \n    update reclada.object\n        set status = reclada_object.get_active_status_obj_id()\n        where attributes->>'function' = 'reclada_object.list'\n            and class in (select reclada_object.get_guid_for_class('DTOJsonSchema'))\n            and status = reclada_object.get_archive_status_obj_id()\n        returning id\n)\n    update reclada.object\n        set status = reclada_object.get_archive_status_obj_id()\n        where attributes->>'function' = 'reclada_object.list'\n            and class in (select reclada_object.get_guid_for_class('DTOJsonSchema'))\n            and id not in (select id from t);\n\nDROP function IF EXISTS reclada.jsonb_deep_set ;\n\n--} display	2022-01-11 07:08:04.636373+00
47	46	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 46 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\ni 'function/reclada_object.create_subclass.sql'\ni 'function/reclada_object.create.sql'\n\nupdate reclada.object\n    set attributes = attributes || jsonb_build_object('parentList', case \n                                                                        when parent_guid is not null \n                                                                            then jsonb_build_array(parent_guid)\n                                                                        else jsonb_build_array()\n                                                                    end)\n    where class = reclada_object.get_jsonschema_GUID();\n\nupdate reclada.object\n    set attributes = jsonb_set(attributes,'{schema,properties}',\n            attributes#>'{schema,properties}'\n                || jsonb_build_object('parentList','{\n                    "items": {\n                        "type": "string"\n                    },\n                    "type": "array"\n                }'::jsonb)\n        )\n    where guid = reclada_object.get_jsonschema_GUID();\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, current version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    class           text;\r\n    new_class       text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n    version_        integer;\r\n    class_guid      uuid;\r\n    _uniFields      jsonb;\r\n    _idx_name       text;\r\n    _f_list         text;\r\nBEGIN\r\n\r\n    class := data->>'class';\r\n    IF (class IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object class is not specified';\r\n    END IF;\r\n\r\n    attrs := data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    new_class = attrs->>'newClass';\r\n\r\n    SELECT reclada_object.get_schema(class) INTO class_schema;\r\n\r\n    IF (class_schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', class;\r\n    END IF;\r\n\r\n    SELECT max(version) + 1\r\n    FROM reclada.v_class_lite v\r\n    WHERE v.for_class = new_class\r\n    INTO version_;\r\n\r\n    version_ := coalesce(version_,1);\r\n    class_schema := class_schema->'attributes'->'schema';\r\n\r\n    SELECT obj_id\r\n    FROM reclada.v_class\r\n    WHERE for_class = class\r\n    ORDER BY version DESC\r\n    LIMIT 1\r\n    INTO class_guid;\r\n\r\n    PERFORM reclada_object.create(format('{\r\n        "class": "jsonschema",\r\n        "attributes": {\r\n            "forClass": "%s",\r\n            "version": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n            }\r\n        },\r\n        "parent_guid" : "%s"\r\n    }',\r\n    new_class,\r\n    version_,\r\n    (class_schema->'properties') || coalesce((attrs->'properties'),'{}'::jsonb),\r\n    (SELECT jsonb_agg(el) FROM (\r\n        SELECT DISTINCT pg_catalog.jsonb_array_elements(\r\n            (class_schema -> 'required') || coalesce((attrs -> 'required'),'{}'::jsonb)\r\n        ) el) arr),\r\n    class_guid\r\n    )::jsonb);\r\n\r\n    IF ( jsonb_typeof(attrs->'dupChecking') = 'array' ) THEN\r\n        FOR _uniFields IN (\r\n            SELECT jsonb_array_elements(attrs->'dupChecking')->'uniFields'\r\n        ) LOOP\r\n            IF ( jsonb_typeof(_uniFields) = 'array' ) THEN\r\n                SELECT\r\n                    reclada.get_unifield_index_name( array_agg(f ORDER BY f)) AS idx_name, \r\n                    string_agg('(attributes ->> ''' || f || ''')','||' ORDER BY f) AS fields_list\r\n                FROM (\r\n                    SELECT jsonb_array_elements_text (_uniFields::jsonb) f\r\n                ) a\r\n                    INTO _idx_name, _f_list;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM pg_catalog.pg_indexes pi2 \r\n                    WHERE schemaname ='reclada' AND tablename ='object' AND indexname =_idx_name\r\n                ) THEN\r\n                    EXECUTE E'CREATE INDEX ' || _idx_name || ' ON reclada.object USING HASH ((' || _f_list || '))';\r\n                END IF;\r\n            END IF;\r\n        END LOOP;\r\n        PERFORM reclada_object.refresh_mv('uniFields');\r\n    END IF;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    _data         jsonb;\r\n    new_data      jsonb;\r\n    _class_name    text;\r\n    _class_uuid   uuid;\r\n    tran_id       bigint;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    _obj_guid     uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    inserted      uuid[];\r\n    inserted_from_draft uuid[];\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _is_cascade   boolean;\r\n    _uni_field    text;\r\n    _parent_guid  uuid;\r\n    _parent_field   text;\r\n    skip_insert     boolean;\r\n    notify_res      jsonb;\r\n    _cnt             int;\r\n    _new_parent_guid       uuid;\r\n    _rel_type       text := 'GUID changed for dupBehavior';\r\n    _guid_list      text;\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision AND others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    CREATE TEMPORARY TABLE IF NOT EXISTS create_duplicate_tmp (\r\n        obj_guid        uuid,\r\n        dup_behavior    reclada.dp_bhvr,\r\n        is_cascade      boolean,\r\n        dup_field       text\r\n    )\r\n    ON COMMIT DROP;\r\n\r\n    FOR _data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n        skip_insert := false;\r\n        _class_name := _data->>'class';\r\n\r\n        IF (_class_name IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n        _class_uuid := reclada.try_cast_uuid(_class_name);\r\n\r\n        _attrs := _data->'attributes';\r\n        IF (_attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        tran_id := (_data->>'transactionID')::bigint;\r\n        IF tran_id IS NULL THEN\r\n            tran_id := reclada.get_transaction_id();\r\n        END IF;\r\n\r\n        IF _class_uuid IS NULL THEN\r\n            SELECT reclada_object.get_schema(_class_name) \r\n            INTO schema;\r\n            _class_uuid := (schema->>'GUID')::uuid;\r\n        ELSE\r\n            SELECT v.data, v.for_class\r\n            FROM reclada.v_class v\r\n            WHERE _class_uuid = v.obj_id\r\n            INTO schema, _class_name;\r\n        END IF;\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', _class_name;\r\n        END IF;\r\n\r\n        IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', _attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n        END IF;\r\n        \r\n        IF _data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        SELECT prnt_guid, prnt_field\r\n        FROM reclada_object.get_parent_guid(_data,_class_name)\r\n            INTO _parent_guid,\r\n                _parent_field;\r\n        _obj_guid := _data->>'GUID';\r\n\r\n        IF (_parent_guid IS NOT NULL) THEN\r\n            SELECT\r\n                attrs->>'object',\r\n                attrs->>'dupBehavior',\r\n                attrs->>'isCascade'\r\n            FROM reclada.v_active_object\r\n            WHERE class_name = 'Relationship'\r\n                AND attrs->>'type'                      = _rel_type\r\n                AND NULLIF(attrs->>'subject','')::uuid  = _parent_guid\r\n                    INTO _new_parent_guid, _dup_behavior, _is_cascade;\r\n\r\n            IF _new_parent_guid IS NOT NULL THEN\r\n                _parent_guid := _new_parent_guid;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.v_object_unifields\r\n            WHERE class_uuid = _class_uuid\r\n        )\r\n        THEN\r\n            INSERT INTO create_duplicate_tmp\r\n            SELECT obj_guid,\r\n                dup_behavior,\r\n                is_cascade,\r\n                dup_field\r\n            FROM reclada.get_duplicates(_attrs, _class_uuid);\r\n\r\n            IF (_parent_guid IS NOT NULL) THEN\r\n                IF (_dup_behavior = 'Update' AND _is_cascade) THEN\r\n                    SELECT count(DISTINCT obj_guid), string_agg(DISTINCT obj_guid::text, ',')\r\n                    FROM create_duplicate_tmp\r\n                        INTO _cnt, _guid_list;\r\n                    IF (_cnt >1) THEN\r\n                        RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                    ELSIF (_cnt = 1) THEN\r\n                        SELECT DISTINCT obj_guid, is_cascade\r\n                        FROM create_duplicate_tmp\r\n                            INTO _obj_guid, _is_cascade;\r\n                        new_data := _data;\r\n                        PERFORM reclada_object.create_relationship(\r\n                                _rel_type,\r\n                                _obj_guid,\r\n                                (new_data->>'GUID')::uuid,\r\n                                format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                        new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                        new_data = reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                        SELECT reclada_object.update(new_data)\r\n                            INTO res;\r\n                        affected := array_append( affected, _obj_guid);\r\n                        skip_insert := true;\r\n                    END IF;\r\n                END IF;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM reclada.v_active_object\r\n                    WHERE obj_id = _parent_guid\r\n                )\r\n                    AND _new_parent_guid IS NULL\r\n                THEN\r\n                    IF (_obj_guid IS NULL) THEN\r\n                        RAISE EXCEPTION 'GUID is required.';\r\n                    END IF;\r\n                    INSERT INTO reclada.draft(guid, parent_guid, data)\r\n                        VALUES(_obj_guid, _parent_guid, _data);\r\n                    skip_insert := true;\r\n                END IF;\r\n            END IF;\r\n\r\n            IF (NOT skip_insert) THEN\r\n                SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg (DISTINCT obj_guid::text, ',')\r\n                FROM create_duplicate_tmp\r\n                GROUP BY dup_behavior\r\n                    INTO _cnt, _dup_behavior, _guid_list;\r\n                IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n                    RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                END IF;\r\n                FOR _obj_guid, _dup_behavior, _is_cascade, _uni_field IN\r\n                    SELECT obj_guid, dup_behavior, is_cascade, dup_field\r\n                    FROM create_duplicate_tmp\r\n                LOOP\r\n                    new_data := _data;\r\n                    CASE _dup_behavior\r\n                        WHEN 'Replace' THEN\r\n                            IF (_is_cascade = true) THEN\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', a)::jsonb)\r\n                                FROM reclada.get_children(_obj_guid) a;\r\n                            ELSE\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                            END IF;\r\n                        WHEN 'Update' THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                _rel_type,\r\n                                _obj_guid,\r\n                                (new_data->>'GUID')::uuid,\r\n                                format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            new_data := reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                            SELECT reclada_object.update(new_data)\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                        WHEN 'Reject' THEN\r\n                            RAISE EXCEPTION 'The object was rejected.';\r\n                        WHEN 'Copy'    THEN\r\n                            _attrs := _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                        WHEN 'Insert' THEN\r\n                            -- DO nothing\r\n                        WHEN 'Merge' THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                _rel_type,\r\n                                _obj_guid,\r\n                                (new_data->>'GUID')::uuid,\r\n                                '{"dupBehavior": "Merge"}'::jsonb);\r\n                            SELECT reclada_object.update(reclada_object.merge(new_data - 'class', data,schema->'attributes'->'schema') || format('{"GUID": "%s"}', _obj_guid)::jsonb || format('{"transactionID": %s}', tran_id)::jsonb)\r\n                            FROM reclada.v_active_object\r\n                            WHERE obj_id = _obj_guid\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                    END CASE;\r\n                END LOOP;\r\n            END IF;\r\n            DELETE FROM create_duplicate_tmp;\r\n        END IF;\r\n        \r\n        IF (NOT skip_insert) THEN\r\n            _obj_guid := (_data->>'GUID')::uuid;\r\n            IF EXISTS (\r\n                SELECT 1\r\n                FROM reclada.object \r\n                WHERE GUID = _obj_guid\r\n            ) THEN\r\n                RAISE EXCEPTION 'GUID: % is duplicate', _obj_guid;\r\n            END IF;\r\n            --raise notice 'schema: %',schema;\r\n\r\n            INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n                SELECT  CASE\r\n                            WHEN _obj_guid IS NULL\r\n                                THEN public.uuid_generate_v4()\r\n                            ELSE _obj_guid\r\n                        END AS GUID,\r\n                        _class_uuid, \r\n                        _attrs,\r\n                        tran_id,\r\n                        _parent_guid\r\n            RETURNING GUID INTO _obj_guid;\r\n            affected := array_append( affected, _obj_guid);\r\n            inserted := array_append( inserted, _obj_guid);\r\n            PERFORM reclada_object.datasource_insert\r\n                (\r\n                    _class_name,\r\n                    _obj_guid,\r\n                    _attrs\r\n                );\r\n\r\n            PERFORM reclada_object.refresh_mv(_class_name);\r\n        END IF;\r\n    END LOOP;\r\n\r\n    SELECT array_agg(_affected_objects->>'GUID')\r\n    FROM (\r\n        SELECT jsonb_array_elements(_affected_objects) AS _affected_objects\r\n        FROM (\r\n            SELECT reclada_object.create(data) AS _affected_objects\r\n            FROM reclada.draft\r\n            WHERE parent_guid = ANY (affected)\r\n        ) a\r\n    ) b\r\n    WHERE _affected_objects->>'GUID' IS NOT NULL\r\n        INTO inserted_from_draft;\r\n    affected := affected || inserted_from_draft;    \r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb;\r\n    notify_res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (inserted)\r\n                )\r\n            )::jsonb; \r\n    \r\n    DELETE FROM reclada.draft \r\n        WHERE guid = ANY (affected);\r\n\r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            notify_res\r\n        );\r\n    RETURN res;\r\nEND;\r\n$function$\n;\n\nupdate reclada.object\n    set attributes = attributes - 'parentList'\n    where class = reclada_object.get_jsonschema_GUID();\n\nupdate reclada.object\n    set attributes = jsonb_set(\n            attributes,\n            '{schema,properties}',\n            (attributes#>'{schema,properties}') - 'parentList'\n        )\n    where guid = reclada_object.get_jsonschema_GUID();	2022-01-21 15:51:33.280927+00
48	47	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 47 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\n\n\ncreate table reclada.field\n(\n    id      bigint\n        NOT NULL\n        GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1)\n        UNIQUE ,\n    path      text\n        NOT NULL,\n    json_type text\n        NOT NULL,\n    PRIMARY KEY (path, json_type)\n);\n\ncreate table reclada.unique_object\n(\n    id bigint\n        NOT NULL\n        GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1)\n        UNIQUE,\n    id_field bigint[]\n        NOT NULL,\n    PRIMARY KEY (id_field)\n);\n\ncreate table reclada.unique_object_reclada_object\n(\n    id bigint\n        NOT NULL\n        GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1),\n    id_unique_object    bigint\n        NOT NULL\n        REFERENCES reclada.unique_object(id),\n    id_reclada_object    bigint\n        NOT NULL\n        REFERENCES reclada.object(id) ON DELETE CASCADE,\n    PRIMARY KEY(id_unique_object,id_reclada_object)\n);\n\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.create_subclass.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.get_schema.sql'\ni 'function/reclada_object.explode_jsonb.sql'\ni 'function/reclada.update_unique_object.sql'\ni 'function/reclada.random_string.sql'\ni 'function/api.reclada_object_list.sql'\ni 'view/reclada.v_ui_active_object.sql'\ni 'function/reclada.get_duplicates.sql'\ni 'function/reclada_object.refresh_mv.sql'\ni 'view/reclada.v_filter_mapping.sql'\ni 'view/reclada.v_get_duplicates_query.sql'\ni 'function/reclada.get_unifield_index_name.sql'\n\n\nselect reclada.update_unique_object(null, true);\n\n\n\nUPDATE reclada.object\nSET\nattributes = '{\n    "schema": {\n        "id": "expr",\n        "type": "object",\n        "required": [\n          "value",\n          "operator"\n        ],\n        "properties": {\n          "value": {\n            "type": "array",\n            "items": {\n              "anyOf": [\n                {\n                  "type": "string"\n                },\n                {\n                  "type": "null"\n                },\n                {\n                  "type": "number"\n                },\n                {\n                  "$ref": "expr"\n                },\n                {\n                  "type": "boolean"\n                },\n                {\n                  "type": "array",\n                  "items": {\n                    "anyOf": [\n                      {\n                        "type": "string"\n                      },\n                      {\n                        "type": "number"\n                      }\n                    ]\n                  }\n                }\n              ]\n            },\n            "minItems": 1\n          },\n          "operator": {\n            "type": "string"\n          }\n        }\n      },\n    "function": "reclada_object.get_query_condition_filter"\n}'::jsonb\nWHERE attributes->>'function' = 'reclada_object.get_query_condition_filter'\nAND class IN (SELECT reclada_object.get_guid_for_class('DTOJsonSchema'));\n\nUPDATE reclada.object\nSET attributes = (SELECT jsonb_set(attributes, '{schema, properties}', attributes #> '{schema, properties}' || '{"disable": {"type": "boolean", "default": false}}'::jsonb))\nWHERE class IN (SELECT reclada_object.get_guid_for_class('jsonschema'))\nAND attributes->>'forClass' != 'ObjectDisplay'\nAND attributes->>'forClass' != 'jsonschema';\n\ni 'view/reclada.v_filter_available_operator.sql'\n\nDROP VIEW IF EXISTS reclada.v_unifields_pivoted;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_unifields;\nDROP VIEW IF EXISTS reclada.v_parent_field;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_task;\nDROP VIEW IF EXISTS reclada.v_ui_active_object;\nDROP VIEW IF EXISTS reclada.v_dto_json_schema;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_class_lite;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_user;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_status;\nDROP VIEW IF EXISTS reclada.v_object_display;\n\ni 'function/reclada_object.get_jsonschema_guid.sql'\ni 'view/reclada.v_class_lite.sql'\ni 'function/reclada_object.get_guid_for_class.sql'\ni 'view/reclada.v_object_status.sql'\n\n\ni 'function/reclada_object.delete.sql'\ni 'view/reclada.v_object_display.sql'\ni 'function/reclada_object.need_flat.sql'\n\n\ni 'view/reclada.v_user.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_dto_json_schema.sql'\ni 'view/reclada.v_ui_active_object.sql'\ni 'view/reclada.v_task.sql'\ni 'view/reclada.v_revision.sql'\ni 'view/reclada.v_import_info.sql'\ni 'view/reclada.v_class.sql'\ni 'view/reclada.v_parent_field.sql'\ni 'view/reclada.v_object_unifields.sql'\n\ni 'view/reclada.v_filter_mapping.sql'\n\nCREATE INDEX relationship_type_subject_object_index ON reclada.object USING btree ((attributes->>'type'), ((attributes->>'subject')::uuid), status, ((attributes->>'object')::uuid))\nWHERE attributes->>'subject' IS NOT NULL AND attributes->>'object' IS NOT NULL;\n\nDROP INDEX parent_guid_index;\nCREATE INDEX parent_guid_index ON reclada.object USING hash (parent_guid)\nWHERE parent_guid IS NOT NULL;\n\nDROP INDEX document_fileguid_index;\nCREATE INDEX document_fileguid_index ON reclada.object USING btree ((attributes ->> 'fileGUID'))\nWHERE attributes ->> 'fileGUID' IS NOT NULL;\n\nDROP INDEX file_uri_index;\n\nDROP INDEX job_status_index;\nCREATE INDEX job_status_index ON reclada.object USING btree ((attributes ->> 'status'))\nWHERE attributes ->> 'status' IS NOT NULL;\n\nDROP INDEX revision_index;\nCREATE INDEX revision_index ON reclada.object USING btree ((attributes ->> 'revision'))\nWHERE attributes ->> 'revision' IS NOT NULL;\n\nDROP INDEX runner_type_index;\nCREATE INDEX runner_type_index ON reclada.object USING btree ((attributes ->> 'type'))\nWHERE attributes ->> 'type' IS NOT NULL;\n\nDROP INDEX guid_index;\nCREATE INDEX guid_index ON reclada.object USING hash (guid);\n\nDROP INDEX checksum_index_;\nCREATE INDEX checksum_index_ ON reclada.object USING hash ((attributes ->> 'checksum'))\nWHERE attributes ->> 'checksum' IS NOT NULL;\n\nDROP INDEX uri_index_;\nCREATE INDEX uri_index_ ON reclada.object USING hash ((attributes ->> 'uri'))\nWHERE attributes ->> 'uri' IS NOT NULL;\n\nDO $$\nDECLARE\n_field_name             text;\n_btree_fields           text[];\n_gin_fields             text[];\n_hash_fields            text[];\nBEGIN\n    SELECT array_remove( array_agg(CASE WHEN c.type = 'number' THEN req_field END), NULL) AS btree_index,\n        array_remove( array_agg(CASE WHEN c.type = 'array' THEN req_field END), NULL) AS gin_index,\n        array_remove( array_agg(CASE WHEN c.type = 'string' AND (c.is_enum OR c.is_guid) THEN req_field END), NULL) AS hash_index\n    FROM (\n        SELECT DISTINCT a.req_field,\n            b.TYPE,\n            c.KEY IS NOT NULL AS is_enum,\n            d.key IS NOT NULL AS is_guid\n        FROM (\n            SELECT lower(jsonb_array_elements_text(attrs->'schema'->'required')) AS req_field, vc.obj_id \n            FROM reclada.v_class vc\n        ) a\n        JOIN (\n            SELECT lower(a.KEY) AS key, a.value->>'type' AS type, vc.obj_id \n            FROM reclada.v_class vc   \n            CROSS JOIN jsonb_each(attrs->'schema'->'properties') a\n            WHERE for_class NOT IN ('ObjectDisplay')\n        ) b ON a.req_field = b.KEY AND a.obj_id=b.obj_id\n        LEFT JOIN (\n            SELECT lower(a.KEY) AS key, vc.obj_id\n            FROM reclada.v_class vc   \n            CROSS JOIN jsonb_each(attrs->'schema'->'properties') a\n            WHERE for_class NOT IN ('ObjectDisplay')    AND a.value->>'enum' IS NOT null\n        ) c ON a.req_field = c.KEY AND a.obj_id = c.obj_id\n        LEFT JOIN (\n            SELECT lower(a.KEY) AS key, vc.obj_id, a.value\n            FROM reclada.v_class vc   \n            CROSS JOIN jsonb_each(attrs->'schema'->'properties') a\n            WHERE for_class NOT IN ('ObjectDisplay')    AND a.value->>'pattern' ='[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}'\n        ) d  ON a.req_field = d.KEY AND a.obj_id = d.obj_id\n        WHERE req_field NOT IN ( '{}')\n            AND req_field NOT IN (       \n                SELECT substring(ind_expr, cut_start+5, cut_end-cut_start-6)\n                FROM (\n                    SELECT relname,\n                        ind_expr,\n                        strpos(ind_expr,'->>') AS cut_start,\n                        strpos(ind_expr,'::text') AS cut_end\n                    FROM (\n                        SELECT i.relname,\n                            pg_catalog.pg_get_expr(ix.indexprs, ix.indrelid) AS ind_expr\n                        FROM pg_catalog.pg_index ix\n                        JOIN pg_catalog.pg_class i ON i.oid = ix.indexrelid \n                        JOIN pg_catalog.pg_class t ON t.oid = ix.indrelid \n                        JOIN pg_catalog.pg_namespace n ON t.relnamespace = n.oid\n                        WHERE t.relname = 'object'\n                            AND nspname = 'reclada'\n                            AND ix.indexprs IS NOT NULL\n                    ) a\n                WHERE length(ind_expr) - length(REPLACE(ind_expr,'->>',''))= 3\n                ) b\n            )\n        ORDER BY 1\n    ) c\n    INTO _btree_fields, _gin_fields, _hash_fields;\n    \n    IF _btree_fields IS NOT NULL THEN\n        FOREACH _field_name IN ARRAY _btree_fields LOOP\n            EXECUTE 'CREATE INDEX '|| _field_name || '_index_v47 ON reclada.object USING BTREE ( (attributes->'''||_field_name ||''')) WHERE attributes ->'''||_field_name ||''' IS NOT NULL';\n        END LOOP;\n    END IF;\n    IF _gin_fields IS NOT NULL THEN\n        FOREACH _field_name IN ARRAY _gin_fields LOOP\n            EXECUTE 'CREATE INDEX '|| _field_name || '_index_v47 ON reclada.object USING GIN ( (attributes->'''||_field_name ||''')) WHERE attributes ->'''||_field_name ||''' IS NOT NULL';\n        END LOOP;\n    END IF;\n    IF _hash_fields IS NOT NULL THEN\n        FOREACH _field_name IN ARRAY _hash_fields LOOP\n            EXECUTE 'CREATE INDEX '|| _field_name || '_index_v47 ON reclada.object USING HASH ( (attributes->'''||_field_name ||''')) WHERE attributes ->'''||_field_name ||''' IS NOT NULL';\n        END LOOP;\n    END IF;\nEND$$;\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, current version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\ndrop table reclada.unique_object_reclada_object;\ndrop table reclada.unique_object;\ndrop table reclada.field;\n\nDROP view IF EXISTS reclada.v_unifields_pivoted ;\nCREATE OR REPLACE VIEW reclada.v_unifields_pivoted\nAS\n SELECT vou.class_uuid,\n    vou.uni_number,\n    vou.dup_behavior,\n    vou.is_cascade,\n    vou.copy_field,\n    max(\n        CASE\n            WHEN vou.field_number = 1 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f1,\n    max(\n        CASE\n            WHEN vou.field_number = 2 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f2,\n    max(\n        CASE\n            WHEN vou.field_number = 3 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f3,\n    max(\n        CASE\n            WHEN vou.field_number = 4 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f4,\n    max(\n        CASE\n            WHEN vou.field_number = 5 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f5,\n    max(\n        CASE\n            WHEN vou.field_number = 6 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f6,\n    max(\n        CASE\n            WHEN vou.field_number = 7 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f7,\n    max(\n        CASE\n            WHEN vou.field_number = 8 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f8\n   FROM v_object_unifields vou\n  WHERE vou.is_mandatory\n  GROUP BY vou.class_uuid, vou.uni_number, vou.dup_behavior, vou.is_cascade, vou.copy_field\n  ORDER BY vou.class_uuid, vou.uni_number, vou.dup_behavior;\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    _data         jsonb;\r\n    new_data      jsonb;\r\n    _class_name    text;\r\n    _class_uuid   uuid;\r\n    tran_id       bigint;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    _obj_guid     uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    inserted      uuid[];\r\n    inserted_from_draft uuid[];\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _is_cascade   boolean;\r\n    _uni_field    text;\r\n    _parent_guid  uuid;\r\n    _parent_field   text;\r\n    skip_insert     boolean;\r\n    notify_res      jsonb;\r\n    _cnt             int;\r\n    _new_parent_guid       uuid;\r\n    _rel_type       text := 'GUID changed for dupBehavior';\r\n    _guid_list      text;\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision AND others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    CREATE TEMPORARY TABLE IF NOT EXISTS create_duplicate_tmp (\r\n        obj_guid        uuid,\r\n        dup_behavior    reclada.dp_bhvr,\r\n        is_cascade      boolean,\r\n        dup_field       text\r\n    )\r\n    ON COMMIT DROP;\r\n\r\n    FOR _data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n        skip_insert := false;\r\n        _class_name := _data->>'class';\r\n\r\n        IF (_class_name IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n        _class_uuid := reclada.try_cast_uuid(_class_name);\r\n\r\n        _attrs := _data->'attributes';\r\n        IF (_attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        tran_id := (_data->>'transactionID')::bigint;\r\n        IF tran_id IS NULL THEN\r\n            tran_id := reclada.get_transaction_id();\r\n        END IF;\r\n\r\n        IF _class_uuid IS NULL THEN\r\n            SELECT reclada_object.get_schema(_class_name) \r\n            INTO schema;\r\n            _class_uuid := (schema->>'GUID')::uuid;\r\n        ELSE\r\n            SELECT v.data, v.for_class\r\n            FROM reclada.v_class v\r\n            WHERE _class_uuid = v.obj_id\r\n            INTO schema, _class_name;\r\n        END IF;\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', _class_name;\r\n        END IF;\r\n\r\n        IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', _attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: \r\n                %, \r\n                schema: \r\n                %', \r\n                _attrs,\r\n                schema#>>'{attributes,schema}';\r\n        END IF;\r\n        \r\n        IF _data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        SELECT prnt_guid, prnt_field\r\n        FROM reclada_object.get_parent_guid(_data,_class_name)\r\n            INTO _parent_guid,\r\n                _parent_field;\r\n        _obj_guid := _data->>'GUID';\r\n\r\n        IF (_parent_guid IS NOT NULL) THEN\r\n            SELECT\r\n                attrs->>'object',\r\n                attrs->>'dupBehavior',\r\n                attrs->>'isCascade'\r\n            FROM reclada.v_active_object\r\n            WHERE class_name = 'Relationship'\r\n                AND attrs->>'type'                      = _rel_type\r\n                AND NULLIF(attrs->>'subject','')::uuid  = _parent_guid\r\n                    INTO _new_parent_guid, _dup_behavior, _is_cascade;\r\n\r\n            IF _new_parent_guid IS NOT NULL THEN\r\n                _parent_guid := _new_parent_guid;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.v_object_unifields\r\n            WHERE class_uuid = _class_uuid\r\n        )\r\n        THEN\r\n            INSERT INTO create_duplicate_tmp\r\n            SELECT obj_guid,\r\n                dup_behavior,\r\n                is_cascade,\r\n                dup_field\r\n            FROM reclada.get_duplicates(_attrs, _class_uuid);\r\n\r\n            IF (_parent_guid IS NOT NULL) THEN\r\n                IF (_dup_behavior = 'Update' AND _is_cascade) THEN\r\n                    SELECT count(DISTINCT obj_guid), string_agg(DISTINCT obj_guid::text, ',')\r\n                    FROM create_duplicate_tmp\r\n                        INTO _cnt, _guid_list;\r\n                    IF (_cnt >1) THEN\r\n                        RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                    ELSIF (_cnt = 1) THEN\r\n                        SELECT DISTINCT obj_guid, is_cascade\r\n                        FROM create_duplicate_tmp\r\n                            INTO _obj_guid, _is_cascade;\r\n                        new_data := _data;\r\n                        PERFORM reclada_object.create_relationship(\r\n                                _rel_type,\r\n                                _obj_guid,\r\n                                (new_data->>'GUID')::uuid,\r\n                                format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                        new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                        new_data = reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                        SELECT reclada_object.update(new_data)\r\n                            INTO res;\r\n                        affected := array_append( affected, _obj_guid);\r\n                        skip_insert := true;\r\n                    END IF;\r\n                END IF;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM reclada.v_active_object\r\n                    WHERE obj_id = _parent_guid\r\n                )\r\n                    AND _new_parent_guid IS NULL\r\n                THEN\r\n                    IF (_obj_guid IS NULL) THEN\r\n                        RAISE EXCEPTION 'GUID is required.';\r\n                    END IF;\r\n                    INSERT INTO reclada.draft(guid, parent_guid, data)\r\n                        VALUES(_obj_guid, _parent_guid, _data);\r\n                    skip_insert := true;\r\n                END IF;\r\n            END IF;\r\n\r\n            IF (NOT skip_insert) THEN\r\n                SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg (DISTINCT obj_guid::text, ',')\r\n                FROM create_duplicate_tmp\r\n                GROUP BY dup_behavior\r\n                    INTO _cnt, _dup_behavior, _guid_list;\r\n                IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n                    RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                END IF;\r\n                FOR _obj_guid, _dup_behavior, _is_cascade, _uni_field IN\r\n                    SELECT obj_guid, dup_behavior, is_cascade, dup_field\r\n                    FROM create_duplicate_tmp\r\n                LOOP\r\n                    new_data := _data;\r\n                    CASE _dup_behavior\r\n                        WHEN 'Replace' THEN\r\n                            IF (_is_cascade = true) THEN\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', a)::jsonb)\r\n                                FROM reclada.get_children(_obj_guid) a;\r\n                            ELSE\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                            END IF;\r\n                        WHEN 'Update' THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                _rel_type,\r\n                                _obj_guid,\r\n                                (new_data->>'GUID')::uuid,\r\n                                format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            new_data := reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                            SELECT reclada_object.update(new_data)\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                        WHEN 'Reject' THEN\r\n                            RAISE EXCEPTION 'The object was rejected.';\r\n                        WHEN 'Copy'    THEN\r\n                            _attrs := _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                        WHEN 'Insert' THEN\r\n                            -- DO nothing\r\n                        WHEN 'Merge' THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                _rel_type,\r\n                                _obj_guid,\r\n                                (new_data->>'GUID')::uuid,\r\n                                '{"dupBehavior": "Merge"}'::jsonb);\r\n                            SELECT reclada_object.update(reclada_object.merge(new_data - 'class', data,schema->'attributes'->'schema') || format('{"GUID": "%s"}', _obj_guid)::jsonb || format('{"transactionID": %s}', tran_id)::jsonb)\r\n                            FROM reclada.v_active_object\r\n                            WHERE obj_id = _obj_guid\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                    END CASE;\r\n                END LOOP;\r\n            END IF;\r\n            DELETE FROM create_duplicate_tmp;\r\n        END IF;\r\n        \r\n        IF (NOT skip_insert) THEN\r\n            _obj_guid := (_data->>'GUID')::uuid;\r\n            IF EXISTS (\r\n                SELECT 1\r\n                FROM reclada.object \r\n                WHERE GUID = _obj_guid\r\n            ) THEN\r\n                RAISE EXCEPTION 'GUID: % is duplicate', _obj_guid;\r\n            END IF;\r\n            --raise notice 'schema: %',schema;\r\n\r\n            INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n                SELECT  CASE\r\n                            WHEN _obj_guid IS NULL\r\n                                THEN public.uuid_generate_v4()\r\n                            ELSE _obj_guid\r\n                        END AS GUID,\r\n                        _class_uuid, \r\n                        _attrs,\r\n                        tran_id,\r\n                        _parent_guid\r\n            RETURNING GUID INTO _obj_guid;\r\n            affected := array_append( affected, _obj_guid);\r\n            inserted := array_append( inserted, _obj_guid);\r\n            PERFORM reclada_object.datasource_insert\r\n                (\r\n                    _class_name,\r\n                    _obj_guid,\r\n                    _attrs\r\n                );\r\n\r\n            PERFORM reclada_object.refresh_mv(_class_name);\r\n        END IF;\r\n    END LOOP;\r\n\r\n    SELECT array_agg(_affected_objects->>'GUID')\r\n    FROM (\r\n        SELECT jsonb_array_elements(_affected_objects) AS _affected_objects\r\n        FROM (\r\n            SELECT reclada_object.create(data) AS _affected_objects\r\n            FROM reclada.draft\r\n            WHERE parent_guid = ANY (affected)\r\n        ) a\r\n    ) b\r\n    WHERE _affected_objects->>'GUID' IS NOT NULL\r\n        INTO inserted_from_draft;\r\n    affected := affected || inserted_from_draft;    \r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb;\r\n    notify_res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (inserted)\r\n                )\r\n            )::jsonb; \r\n    \r\n    DELETE FROM reclada.draft \r\n        WHERE guid = ANY (affected);\r\n\r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            notify_res\r\n        );\r\n    RETURN res;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _class_list     jsonb;\r\n    _class          text;\r\n    _properties     jsonb;\r\n    _required       jsonb;\r\n    _parent_list    jsonb := '[]';\r\n    new_class       text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n    version_        integer;\r\n    class_guid      uuid;\r\n    _uniFields      jsonb;\r\n    _idx_name       text;\r\n    _f_list         text;\r\n    _f_name         text = 'reclada_object.create_subclass';\r\nBEGIN\r\n\r\n    _class_list := data->'class';\r\n    IF (_class_list IS NULL) THEN\r\n        perform reclada.raise_exception('The reclada object class is not specified',_f_name);\r\n    END IF;\r\n\r\n    IF (jsonb_typeof(_class_list) != 'array') THEN\r\n        _class_list := '[]'::jsonb || _class_list;\r\n    END IF;\r\n\r\n    attrs := data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    new_class = attrs->>'newClass';\r\n    _properties := coalesce((attrs->'properties'),'{}'::jsonb);\r\n    _required   := coalesce((attrs -> 'required'),'[]'::jsonb);\r\n    FOR _class IN SELECT jsonb_array_elements_text(_class_list)\r\n    LOOP\r\n\r\n        SELECT reclada_object.get_schema(_class) \r\n            INTO class_schema;\r\n\r\n        IF (class_schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', _class;\r\n        END IF;\r\n\r\n        _properties :=  coalesce((class_schema#>'{attributes,schema,properties}'),'{}'::jsonb) || _properties;\r\n\r\n        SELECT jsonb_agg(el) \r\n            FROM \r\n            (\r\n                SELECT DISTINCT \r\n                        pg_catalog.jsonb_array_elements(\r\n                            coalesce(   class_schema#> '{attributes,schema,required}',\r\n                                        'null'::jsonb\r\n                                    ) || _required\r\n                        ) as el\r\n            ) arr\r\n                WHERE jsonb_typeof(el) != 'null'\r\n            INTO _required;\r\n\r\n        SELECT class_schema->>'GUID'\r\n            INTO class_guid;\r\n        \r\n        _parent_list := _parent_list || to_jsonb(class_guid);\r\n\r\n    END LOOP;\r\n    SELECT max(version) + 1\r\n    FROM reclada.v_class_lite v\r\n    WHERE v.for_class = new_class\r\n    INTO version_;\r\n\r\n    version_ := coalesce(version_,1);\r\n    class_schema := class_schema->'attributes'->'schema';\r\n\r\n    PERFORM reclada_object.create(format('{\r\n        "class": "jsonschema",\r\n        "attributes": {\r\n            "forClass": "%s",\r\n            "version": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n            },\r\n            "parentList":%s\r\n        }\r\n    }',\r\n    new_class,\r\n    version_,\r\n    _properties,\r\n    _required,\r\n    _parent_list\r\n    )::jsonb);\r\n\r\n    IF ( jsonb_typeof(attrs->'dupChecking') = 'array' ) THEN\r\n        FOR _uniFields IN (\r\n            SELECT jsonb_array_elements(attrs->'dupChecking')->'uniFields'\r\n        ) LOOP\r\n            IF ( jsonb_typeof(_uniFields) = 'array' ) THEN\r\n                SELECT\r\n                    reclada.get_unifield_index_name( array_agg(f ORDER BY f)) AS idx_name, \r\n                    string_agg('(attributes ->> ''' || f || ''')','||' ORDER BY f) AS fields_list\r\n                FROM (\r\n                    SELECT jsonb_array_elements_text (_uniFields::jsonb) f\r\n                ) a\r\n                    INTO _idx_name, _f_list;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM pg_catalog.pg_indexes pi2 \r\n                    WHERE schemaname ='reclada' AND tablename ='object' AND indexname =_idx_name\r\n                ) THEN\r\n                    EXECUTE E'CREATE INDEX ' || _idx_name || ' ON reclada.object USING HASH ((' || _f_list || '))';\r\n                END IF;\r\n            END IF;\r\n        END LOOP;\r\n        PERFORM reclada_object.refresh_mv('uniFields');\r\n    END IF;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_schema ;\nCREATE OR REPLACE FUNCTION reclada_object.get_schema(class text)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT data\r\n    FROM reclada.v_class v\r\n    WHERE v.for_class = class\r\n    ORDER BY v.version DESC\r\n    LIMIT 1\r\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(_data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name       TEXT = 'reclada_object.update';\r\n    _class_name   text;\r\n    _class_uuid   uuid;\r\n    _obj_id       uuid;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    old_obj       jsonb;\r\n    branch        uuid;\r\n    revid         uuid;\r\n    _parent_guid  uuid;\r\n    _parent_field text;\r\n    _obj_guid     uuid;\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _uni_field    text;\r\n    _cnt          int;\r\n    _guid_list      text;\r\nBEGIN\r\n\r\n    _class_name := _data->>'class';\r\n    IF (_class_name IS NULL) THEN\r\n        perform reclada.raise_exception(\r\n                        'The reclada object class is not specified',\r\n                        _f_name\r\n                    );\r\n    END IF;\r\n    _class_uuid := reclada.try_cast_uuid(_class_name);\r\n    _obj_id := _data->>'GUID';\r\n    IF (_obj_id IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no GUID';\r\n    END IF;\r\n\r\n    _attrs := _data->'attributes';\r\n    IF (_attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    if _class_uuid is null then\r\n        SELECT reclada_object.get_schema(_class_name) \r\n            INTO schema;\r\n    else\r\n        select v.data, v.for_class \r\n            from reclada.v_class v\r\n                where _class_uuid = v.obj_id\r\n            INTO schema, _class_name;\r\n    end if;\r\n    -- TODO: don't allow update jsonschema\r\n    IF (schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', _class_name;\r\n    END IF;\r\n\r\n    IF (_class_uuid IS NULL) THEN\r\n        _class_uuid := (schema->>'GUID')::uuid;\r\n    END IF;\r\n    schema := schema #> '{attributes,schema}';\r\n    IF (NOT(public.validate_json_schema(schema, _attrs))) THEN\r\n        RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n    END IF;\r\n\r\n    SELECT \tv.data\r\n        FROM reclada.v_object v\r\n\t        WHERE v.obj_id = _obj_id\r\n                AND v.class_name = _class_name \r\n\t    INTO old_obj;\r\n\r\n    IF (old_obj IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object, no such id';\r\n    END IF;\r\n\r\n    branch := _data->'branch';\r\n    SELECT reclada_revision.create(user_info->>'sub', branch, _obj_id) \r\n        INTO revid;\r\n\r\n    SELECT prnt_guid, prnt_field\r\n    FROM reclada_object.get_parent_guid(_data,_class_name)\r\n        INTO _parent_guid,\r\n            _parent_field;\r\n\r\n    IF (_parent_guid IS NULL) THEN\r\n        _parent_guid := old_obj->>'parentGUID';\r\n    END IF;\r\n    \r\n    IF EXISTS (\r\n        SELECT 1\r\n        FROM reclada.v_object_unifields\r\n        WHERE class_uuid=_class_uuid\r\n    )\r\n    THEN\r\n        SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg(DISTINCT obj_guid::text, ',')\r\n        FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)\r\n        GROUP BY dup_behavior\r\n            INTO _cnt, _dup_behavior, _guid_list;\r\n        IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n            RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n        END IF;\r\n        FOR _obj_guid, _dup_behavior, _uni_field IN (\r\n                SELECT obj_guid, dup_behavior, dup_field\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)\r\n            ) LOOP\r\n            IF _dup_behavior IN ('Update','Merge') THEN\r\n                UPDATE reclada.object o\r\n                    SET status = reclada_object.get_archive_status_obj_id()\r\n                WHERE o.GUID = _obj_guid\r\n                    AND status != reclada_object.get_archive_status_obj_id();\r\n            END IF;\r\n            CASE _dup_behavior\r\n                WHEN 'Replace' THEN\r\n                    PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                WHEN 'Update' THEN                    \r\n                    _data := reclada_object.remove_parent_guid(_data, _parent_field);\r\n                    _data := reclada_object.update_json_by_guid(_obj_guid, _data);\r\n                    RETURN reclada_object.update(_data);\r\n                WHEN 'Reject' THEN\r\n                    RAISE EXCEPTION 'Duplicate found (GUID: %). Object rejected.', _obj_guid;\r\n                WHEN 'Copy'    THEN\r\n                    _attrs = _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                    IF (NOT(public.validate_json_schema(schema, _attrs))) THEN\r\n                        RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n                    END IF;\r\n                WHEN 'Insert' THEN\r\n                    -- DO nothing\r\n                WHEN 'Merge' THEN                    \r\n                    RETURN reclada_object.update(\r\n                        reclada_object.merge(\r\n                            _data - 'class', \r\n                            vao.data, \r\n                            schema\r\n                        ) || format('{"GUID": "%s"}', _obj_guid)::jsonb\r\n                    )\r\n                        FROM reclada.v_active_object vao\r\n                            WHERE obj_id = _obj_guid;\r\n            END CASE;\r\n        END LOOP;\r\n    END IF;\r\n\r\n    with t as \r\n    (\r\n        update reclada.object o\r\n            set status = reclada_object.get_archive_status_obj_id()\r\n                where o.GUID = _obj_id\r\n                    and status != reclada_object.get_archive_status_obj_id()\r\n                        RETURNING id\r\n    )\r\n    INSERT INTO reclada.object( GUID,\r\n                                class,\r\n                                status,\r\n                                attributes,\r\n                                transaction_id,\r\n                                parent_guid\r\n                              )\r\n        select  v.obj_id,\r\n                _class_uuid,\r\n                reclada_object.get_active_status_obj_id(),--status \r\n                _attrs || format('{"revision":"%s"}',revid)::jsonb,\r\n                transaction_id,\r\n                _parent_guid\r\n            FROM reclada.v_object v\r\n            JOIN \r\n            (   \r\n                select id \r\n                    FROM \r\n                    (\r\n                        select id, 1 as q\r\n                            from t\r\n                        union \r\n                        select id, 2 as q\r\n                            from reclada.object ro\r\n                                where ro.guid = _obj_id\r\n                                    ORDER BY ID DESC \r\n                                        LIMIT 1\r\n                    ) ta\r\n                    ORDER BY q ASC \r\n                        LIMIT 1\r\n            ) as tt\r\n                on tt.id = v.id\r\n\t            WHERE v.obj_id = _obj_id;\r\n    PERFORM reclada_object.datasource_insert\r\n            (\r\n                _class_name,\r\n                _obj_id,\r\n                _attrs\r\n            );\r\n    PERFORM reclada_object.refresh_mv(_class_name);\r\n\r\n    IF ( _class_name = 'jsonschema' AND jsonb_typeof(_attrs->'dupChecking') = 'array') THEN\r\n        PERFORM reclada_object.refresh_mv('uniFields');\r\n    END IF; \r\n                  \r\n    select v.data \r\n        FROM reclada.v_active_object v\r\n            WHERE v.obj_id = _obj_id\r\n        into _data;\r\n    PERFORM reclada_notification.send_object_notification('update', _data);\r\n    RETURN _data;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false, ver text DEFAULT '1'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    _class              text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    _exec_text           text;\r\n    _pre_query           text;\r\n    _from               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\n    _object_display     JSONB;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    if ver = '1' then\r\n        tran_id := (data->>'transactionID')::bigint;\r\n        _class := data->>'class';\r\n    elseif ver = '2' then\r\n        tran_id := (data->>'{transactionID}')::bigint;\r\n        _class := data->>'{class}';\r\n    end if;\r\n    _filter = data->'filter';\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(\r\n            E'obj.data#>''{%s}'' %s', \r\n            case ver\r\n                when '2'\r\n                    then REPLACE(REPLACE(T.value->>'field','{', '"{' ),'}', '}"' )\r\n                else\r\n                    T.value->>'field'\r\n            end,\r\n            COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    \r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSEIF ver = '1' then\r\n        class_uuid := reclada.try_cast_uuid(_class);\r\n\r\n        IF (class_uuid IS NULL) THEN\r\n            SELECT v.obj_id\r\n                FROM reclada.v_class v\r\n                    WHERE _class = v.for_class\r\n                    ORDER BY v.version DESC\r\n                    limit 1 \r\n            INTO class_uuid;\r\n            IF (class_uuid IS NULL) THEN\r\n                perform reclada.raise_exception(\r\n                        format('Class not found: %s', _class),\r\n                        _f_name\r\n                    );\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', _class) AS condition\r\n                        where _class is not null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                            and _class is null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    -- TODO: add ELSE\r\n    IF ver = '2' THEN\r\n        _pre_query := (select val from reclada.v_ui_active_object);\r\n        _from := 'res AS obj';\r\n        _pre_query := REPLACE(_pre_query,'#@#@#where#@#@#', query_conditions  );\r\n\r\n    ELSE\r\n        _pre_query := '';\r\n        _from := 'reclada.v_active_object AS obj\r\n                            WHERE #@#@#where#@#@#';\r\n        _from := REPLACE(_from, '#@#@#where#@#@#', query_conditions  );\r\n    END IF;\r\n    _exec_text := _pre_query ||\r\n                'SELECT to_jsonb(array_agg(t.data))\r\n                    FROM \r\n                    (\r\n                        SELECT obj.data\r\n                            FROM '\r\n                            || _from\r\n                            || ' \r\n                            ORDER BY #@#@#orderby#@#@#\r\n                            OFFSET #@#@#offset#@#@#\r\n                            LIMIT #@#@#limit#@#@#\r\n                    ) AS t';\r\n    _exec_text := REPLACE(_exec_text, '#@#@#orderby#@#@#'  , order_by          );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#offset#@#@#'   , offset_           );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#limit#@#@#'    , limit_            );\r\n    -- RAISE NOTICE 'conds: %', _exec_text;\r\n    EXECUTE _exec_text\r\n        INTO objects;\r\n    objects := coalesce(objects,'[]'::jsonb);\r\n    IF gui THEN\r\n\r\n        if ver = '2' then\r\n            class_uuid := coalesce(class_uuid, (objects#>>'{0,"{class}"}')::uuid);\r\n            if class_uuid is not null then\r\n                _class :=   (\r\n                                select cl.for_class \r\n                                    from reclada.v_class_lite cl\r\n                                        where class_uuid = cl.obj_id\r\n                                            limit 1\r\n                            );\r\n\r\n                _exec_text := _pre_query ||',\r\n                dd as (\r\n                    select distinct unnest(obj.display_key) v\r\n                        FROM '|| _from ||'\r\n                ),\r\n                on_data as \r\n                (\r\n                    select  jsonb_object_agg(\r\n                                t.v, \r\n                                replace(dd.template,''#@#attrname#@#'',t.v)::jsonb \r\n                            ) t\r\n                        from dd as t\r\n                        JOIN reclada.v_default_display dd\r\n                            on t.v like ''%'' || dd.json_type\r\n                )\r\n                select jsonb_set(templ.v,''{table}'', od.t || coalesce(d.table,coalesce(d.table,templ.v->''table'')))\r\n                    from on_data od\r\n                    join (\r\n                        select replace(template,''#@#classname#@#'','''|| _class ||''')::jsonb v\r\n                            from reclada.v_default_display \r\n                                where json_type = ''ObjectDisplay''\r\n                                    limit 1\r\n                    ) templ\r\n                        on true\r\n                    left join reclada.v_object_display d\r\n                        on d.class_guid::text = '''|| coalesce( class_uuid::text, '' ) ||'''';\r\n\r\n                -- raise notice '%',_exec_text;\r\n                EXECUTE _exec_text\r\n                    INTO _object_display;\r\n            end if;\r\n        end if;\r\n\r\n        _exec_text := _pre_query || '\r\n            SELECT  COUNT(1),\r\n                    TO_CHAR(\r\n                        MAX(\r\n                            GREATEST(\r\n                                obj.created_time, \r\n                                (\r\n                                    SELECT  TO_TIMESTAMP(\r\n                                                MAX(date_time),\r\n                                                ''YYYY-MM-DD hh24:mi:ss.US TZH''\r\n                                            )\r\n                                        FROM reclada.v_revision vr\r\n                                            WHERE vr.obj_id = UUID(obj.attrs ->>''revision'')\r\n                                )\r\n                            )\r\n                        ),\r\n                        ''YYYY-MM-DD hh24:mi:ss.MS TZH''\r\n                    )\r\n                    FROM '|| _from;\r\n        EXECUTE _exec_text\r\n            INTO number_of_objects, last_change;\r\n        \r\n        IF _object_display IS NOT NULL then\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects,\r\n                    'display', _object_display\r\n                );\r\n        ELSE\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects\r\n            );\r\n        end if;\r\n    ELSE\r\n        \r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada.update_unique_object ;\n\nDROP function IF EXISTS reclada.random_string ;\n\nDROP function IF EXISTS api.reclada_object_list ;\nCREATE OR REPLACE FUNCTION api.reclada_object_list(data jsonb DEFAULT NULL::jsonb, ver text DEFAULT '1'::text, draft text DEFAULT 'false'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _class              text;\r\n    user_info           jsonb;\r\n    result              jsonb;\r\n    _filter             jsonb;\r\n    _guid               uuid;\r\nBEGIN\r\n\r\n    if draft != 'false' then\r\n        return array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                        FROM reclada.draft o\r\n                            where id = \r\n                                (\r\n                                    select max(id) \r\n                                        FROM reclada.draft d\r\n                                            where o.guid = d.guid\r\n                                )\r\n                            -- and o.user = user_info->>'guid'\r\n                )\r\n            )::jsonb;\r\n    end if;\r\n\r\n    _class := CASE ver\r\n                when '1'\r\n                    then data->>'class'\r\n                when '2'\r\n                    then data->>'{class}'\r\n            end;\r\n    IF(_class IS NULL) THEN\r\n        RAISE EXCEPTION 'reclada object class not specified';\r\n    END IF;\r\n\r\n    _guid := CASE ver\r\n        when '1'\r\n            then data->>'GUID'\r\n        when '2'\r\n            then data->>'{GUID}'\r\n    end;\r\n\r\n    _filter = data->'filter';\r\n\r\n    if _guid is not null then\r\n        SELECT format(  '{\r\n                            "operator":"AND",\r\n                            "value":[\r\n                                {\r\n                                    "operator":"=",\r\n                                    "value":["{class}","%s"]\r\n                                },\r\n                                {\r\n                                    "operator":"=",\r\n                                    "value":["{GUID}","%s"]\r\n                                }\r\n                            ]\r\n                        }',\r\n                    _class,\r\n                    _guid\r\n                )::jsonb \r\n            INTO _filter;\r\n\r\n    ELSEIF _filter IS NOT NULL THEN\r\n        SELECT format(  '{\r\n                            "operator":"AND",\r\n                            "value":[\r\n                                {\r\n                                    "operator":"=",\r\n                                    "value":["{class}","%s"]\r\n                                },\r\n                                %s\r\n                            ]\r\n                        }',\r\n                _class,\r\n                _filter\r\n            )::jsonb \r\n            INTO _filter;\r\n    ELSEIF ver = '2' then\r\n        SELECT format( '{\r\n                            "operator":"=",\r\n                            "value":["{class}","%s"]\r\n                        }',\r\n                _class\r\n            )::jsonb \r\n            INTO _filter;\r\n    END IF;\r\n    \r\n    data := Jsonb_set(data,'{filter}', _filter);\r\n\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'list', _class))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to % %', 'list', _class;\r\n    END IF;\r\n\r\n    SELECT reclada_object.list(data, true, ver) \r\n        INTO result;\r\n    RETURN result;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.explode_jsonb ;\n\nDROP function IF EXISTS reclada_object.refresh_mv ;\nCREATE OR REPLACE FUNCTION reclada_object.refresh_mv(class_name text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\n\r\nBEGIN\r\n    CASE class_name\r\n        WHEN 'ObjectStatus' THEN\r\n            REFRESH MATERIALIZED VIEW reclada.v_object_status;\r\n        WHEN 'User' THEN\r\n            REFRESH MATERIALIZED VIEW reclada.v_user;\r\n        WHEN 'jsonschema' THEN\r\n            REFRESH MATERIALIZED VIEW reclada.v_class_lite;\r\n        WHEN 'uniFields' THEN\r\n            REFRESH MATERIALIZED VIEW reclada.v_class_lite;\r\n            REFRESH MATERIALIZED VIEW reclada.v_object_unifields;\r\n        ELSE\r\n            NULL;\r\n    END CASE;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada.get_duplicates ;\nCREATE OR REPLACE FUNCTION reclada.get_duplicates(_attrs jsonb, _class_uuid uuid, exclude_uuid uuid DEFAULT NULL::uuid)\n RETURNS TABLE(obj_guid uuid, dup_behavior dp_bhvr, is_cascade boolean, dup_field text)\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT vao.obj_id, vup.dup_behavior, vup.is_cascade, vup.copy_field\r\n        FROM reclada.v_active_object vao\r\n        JOIN reclada.v_unifields_pivoted vup ON vao."class" = vup.class_uuid\r\n        WHERE (vao.attrs ->> f1) \r\n                || COALESCE((vao.attrs ->> f2),'') \r\n                || COALESCE((vao.attrs ->> f3),'') \r\n                || COALESCE((vao.attrs ->> f4),'') \r\n                || COALESCE((vao.attrs ->> f5),'') \r\n                || COALESCE((vao.attrs ->> f6),'') \r\n                || COALESCE((vao.attrs ->> f7),'') \r\n                || COALESCE((vao.attrs ->> f8),'')\r\n            = (_attrs ->> f1) \r\n                || COALESCE((_attrs ->> f2),'') \r\n                || COALESCE((_attrs ->> f3),'') \r\n                || COALESCE((_attrs ->> f4),'') \r\n                || COALESCE((_attrs ->> f5),'') \r\n                || COALESCE((_attrs ->> f6),'') \r\n                || COALESCE((_attrs ->> f7),'') \r\n                || COALESCE((_attrs ->> f8),'')\r\n            AND vao."class" = _class_uuid\r\n            AND (vao.obj_id != exclude_uuid OR exclude_uuid IS NULL)\r\n$function$\n;\nDROP view IF EXISTS reclada.v_filter_mapping ;\nCREATE OR REPLACE VIEW reclada.v_filter_mapping\nAS\n SELECT '{class}'::text AS pattern,\n    'class_name'::text AS repl;\nDROP view IF EXISTS reclada.v_get_duplicates_query ;\n\nDROP function IF EXISTS reclada.get_unifield_index_name ;\nCREATE OR REPLACE FUNCTION reclada.get_unifield_index_name(fields text[])\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\r\n\tSELECT array_to_string(fields,'_')||'_index_';\r\n$function$\n;\n\nDROP INDEX relationship_type_subject_object_index;\n\nDROP INDEX parent_guid_index;\nCREATE INDEX parent_guid_index ON reclada.object USING btree ((parent_guid));\n\nDROP INDEX document_fileguid_index;\nCREATE INDEX document_fileguid_index ON reclada.object USING btree ((attributes ->> 'fileGUID'));\n\nCREATE INDEX file_uri_index ON reclada.object USING btree ((attributes ->> 'uri'));\n\nDROP INDEX job_status_index;\nCREATE INDEX job_status_index ON reclada.object USING btree ((attributes ->> 'status'));\n\nDROP INDEX revision_index;\nCREATE INDEX revision_index ON reclada.object USING btree ((attributes ->> 'revision'));\n\nDROP INDEX runner_type_index;\nCREATE INDEX runner_type_index ON reclada.object USING btree ((attributes ->> 'type'));\n\nDROP INDEX guid_index;\nCREATE INDEX guid_index ON reclada.object USING btree ((guid));\n\nDROP INDEX checksum_index_;\nCREATE INDEX checksum_index_ ON reclada.object USING hash ((attributes ->> 'checksum'));\n\nDROP INDEX uri_index_;\nCREATE INDEX uri_index_ ON reclada.object USING hash ((attributes ->> 'uri'));\n\nDO $$\nDECLARE\n_index_name text;\n_indexes        TEXT[];\nBEGIN\n    SELECT array_agg(indexname)\n    FROM pg_catalog.pg_indexes\n    WHERE indexname LIKE '%_v47'\n        AND schemaname ='reclada'\n        AND tablename ='object'\n    INTO _indexes;\n    \n    IF _indexes IS NOT NULL THEN\n        FOREACH _index_name IN ARRAY _indexes LOOP\n            EXECUTE 'DROP INDEX '|| _index_name;\n        END LOOP;\n    END IF;\nEND$$;\n\n\nUPDATE reclada.object\nSET attributes = '{\n    "schema": {\n        "id": "expr",\n        "type": "object",\n        "required": [\n          "value",\n          "operator"\n        ],\n        "properties": {\n          "value": {\n            "type": "array",\n            "items": {\n              "anyOf": [\n                {\n                  "type": "string"\n                },\n                {\n                  "type": "null"\n                },\n                {\n                  "type": "number"\n                },\n                {\n                  "$ref": "expr"\n                },\n                {\n                  "type": "array",\n                  "items": {\n                    "anyOf": [\n                      {\n                        "type": "string"\n                      },\n                      {\n                        "type": "number"\n                      }\n                    ]\n                  }\n                }\n              ]\n            },\n            "minItems": 1\n          },\n          "operator": {\n            "type": "string"\n          }\n        }\n      },\n    "function": "reclada_object.get_query_condition_filter"\n}'::jsonb\nWHERE attributes->>'function' = 'reclada_object.get_query_condition_filter'\nAND class IN (SELECT reclada_object.get_guid_for_class('DTOJsonSchema'));\n\n\nUPDATE reclada.object\nSET attributes = attributes #- '{schema, properties, disable}'\nWHERE class IN (SELECT reclada_object.get_guid_for_class('jsonschema'))\nAND attributes->>'forClass' != 'ObjectDisplay'\nAND attributes->>'forClass' != 'jsonschema';\n\n\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition_filter(data jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE \r\n    _count   INT;\r\n    _res     TEXT;\r\n    _f_name TEXT = 'reclada_object.get_query_condition_filter';\r\nBEGIN \r\n    \r\n    perform reclada.validate_json(data, _f_name);\r\n    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE\r\n    CREATE TEMP TABLE mytable AS\r\n        SELECT  res.lvl              AS lvl         , \r\n                res.rn               AS rn          , \r\n                res.idx              AS idx         ,\r\n                res.prev             AS prev        , \r\n                res.val              AS val         ,  \r\n                res.parsed           AS parsed      , \r\n                coalesce(\r\n                    po.inner_operator, \r\n                    op.operator\r\n                )                   AS op           , \r\n                coalesce\r\n                (\r\n                    iop.input_type,\r\n                    op.input_type\r\n                )                   AS input_type   ,\r\n                case \r\n                    when iop.input_type is not NULL \r\n                        then NULL \r\n                    else \r\n                        op.output_type\r\n                end                 AS output_type  ,\r\n                po.operator         AS po           ,\r\n                po.input_type       AS po_input_type,\r\n                iop.brackets        AS po_inner_brackets\r\n            FROM reclada_object.parse_filter(data) res\r\n            LEFT JOIN reclada.v_filter_available_operator op\r\n                ON res.op = op.operator\r\n            LEFT JOIN reclada_object.parse_filter(data) p\r\n                on  p.lvl = res.lvl-1\r\n                    and res.prev = p.rn\r\n            LEFT JOIN reclada.v_filter_available_operator po\r\n                on po.operator = p.op\r\n            LEFT JOIN reclada.v_filter_inner_operator iop\r\n                on iop.operator = po.inner_operator;\r\n\r\n    PERFORM reclada.raise_exception('Operator does not allowed ', _f_name)\r\n        FROM mytable t\r\n            WHERE t.op IS NULL;\r\n\r\n\r\n    UPDATE mytable u\r\n        SET parsed = to_jsonb(p.v)\r\n            FROM mytable t\r\n            JOIN LATERAL \r\n            (\r\n                SELECT  t.parsed #>> '{}' v\r\n            ) as pt\r\n                ON TRUE\r\n            LEFT JOIN reclada.v_filter_mapping fm\r\n                ON pt.v = fm.pattern\r\n            JOIN LATERAL \r\n            (\r\n                SELECT CASE \r\n                        WHEN t.op LIKE '%<@%' AND t.idx=1 AND jsonb_typeof(t.parsed)='string'\r\n                            THEN format('data #> ''%s''!= ''[]''::jsonb AND data #> ''%s''!= ''{}''::jsonb AND data #> ''%s''', pt.v, pt.v, pt.v)\r\n                        WHEN fm.repl is not NULL \r\n                            then \r\n                                case \r\n                                    when t.input_type in ('TEXT')\r\n                                        then fm.repl || '::TEXT'\r\n                                    else '(''"''||' ||fm.repl ||'||''"'')::jsonb' -- don't use FORMAT (concat null)\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) in ('number', 'boolean')\r\n                            then \r\n                                case \r\n                                    when t.input_type in ('NUMERIC','INT')\r\n                                        then pt.v\r\n                                    else '''' || pt.v || '''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'string' \r\n                            then    \r\n                                case\r\n                                    WHEN pt.v LIKE '{%}'\r\n                                        THEN\r\n                                            case\r\n                                                when t.input_type = 'TEXT'\r\n                                                    then format('(data #>> ''%s'')', pt.v)\r\n                                                when t.input_type = 'JSONB' or t.input_type is null\r\n                                                    then format('data #> ''%s''', pt.v)\r\n                                                else\r\n                                                    format('(data #>> ''%s'')::', pt.v) || t.input_type\r\n                                            end\r\n                                    when t.input_type = 'TEXT'\r\n                                        then ''''||REPLACE(pt.v,'''','''''')||''''\r\n                                    when t.input_type = 'JSONB' or t.input_type is null\r\n                                        then '''"'||REPLACE(pt.v,'''','''''')||'"''::jsonb'\r\n                                    else ''''||REPLACE(pt.v,'''','''''')||'''::'||t.input_type\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'null'\r\n                            then 'null'\r\n                        WHEN jsonb_typeof(t.parsed) = 'array'\r\n                            then ''''||REPLACE(pt.v,'''','''''')||'''::jsonb'\r\n                        ELSE\r\n                            pt.v\r\n                    END AS v\r\n            ) as p\r\n                ON TRUE\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND t.parsed IS NOT NULL;\r\n\r\n    update mytable u\r\n        set op = CASE \r\n                    when f.btwn\r\n                        then ' BETWEEN '\r\n                    else u.op -- f.inop\r\n                end,\r\n            parsed = format(vb.operand_format,u.parsed)::jsonb\r\n        FROM mytable t\r\n        join lateral\r\n        (\r\n            select  t.op like ' %/BETWEEN ' btwn, \r\n                    t.po_inner_brackets is not null inop\r\n        ) f \r\n            on true\r\n        join reclada.v_filter_between vb\r\n            on t.op = vb.operator\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND (f.btwn or f.inop);\r\n\r\n\r\n    INSERT INTO mytable (lvl,rn)\r\n        VALUES (0,0);\r\n\r\n    _count := 1;\r\n\r\n    WHILE (_count>0) LOOP\r\n        WITH r AS \r\n        (\r\n            UPDATE mytable\r\n                SET parsed = to_json(t.converted)::JSONB \r\n                FROM \r\n                (\r\n                    SELECT     \r\n                            res.lvl-1 lvl,\r\n                            res.prev rn,\r\n                            res.op,\r\n                            1 q,\r\n                            case \r\n                                when not res.po_inner_brackets \r\n                                    then array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) \r\n                                else\r\n                                    CASE COUNT(1) \r\n                                        WHEN 1\r\n                                            THEN \r\n                                                CASE res.output_type\r\n                                                    when 'NUMERIC'\r\n                                                        then format('(%s %s)::TEXT::JSONB', res.op, min(res.parsed #>> '{}') )\r\n                                                    else \r\n                                                        format('(%s %s)', res.op, min(res.parsed #>> '{}') )\r\n                                                end\r\n                                        ELSE\r\n                                            CASE \r\n                                                when res.output_type = 'TEXT'\r\n                                                    then '(''"''||'||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||'||''"'')::JSONB'\r\n                                                when res.output_type in ('NUMERIC','INT')\r\n                                                    then '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')::TEXT::JSONB'\r\n                                                else\r\n                                                    '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')'\r\n                                            end\r\n                                    end\r\n                            end AS converted\r\n                        FROM mytable res \r\n                            WHERE res.parsed IS NOT NULL\r\n                                AND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)\r\n                            GROUP BY  res.prev, res.op, res.lvl, res.input_type, res.output_type, res.po_inner_brackets\r\n                ) t\r\n                WHERE\r\n                    t.lvl = mytable.lvl\r\n                        AND t.rn = mytable.rn\r\n                RETURNING 1\r\n        )\r\n            SELECT COUNT(1) \r\n                FROM r\r\n                INTO _count;\r\n    END LOOP;\r\n    \r\n    SELECT parsed #>> '{}' \r\n        FROM mytable\r\n            WHERE lvl = 0 AND rn = 0\r\n        INTO _res;\r\n    -- perform reclada.raise_notice( _res);\r\n    DROP TABLE mytable;\r\n    RETURN _res;\r\nEND \r\n$function$\n;\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _class_list     jsonb;\r\n    _class          text;\r\n    _properties     jsonb;\r\n    _required       jsonb;\r\n    _parent_list    jsonb := '[]';\r\n    new_class       text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n    version_        integer;\r\n    class_guid      uuid;\r\n    _uniFields      jsonb;\r\n    _idx_name       text;\r\n    _f_list         text;\r\n    _f_name         text = 'reclada_object.create_subclass';\r\nBEGIN\r\n\r\n    _class_list := data->'class';\r\n    IF (_class_list IS NULL) THEN\r\n        perform reclada.raise_exception('The reclada object class is not specified',_f_name);\r\n    END IF;\r\n\r\n    IF (jsonb_typeof(_class_list) != 'array') THEN\r\n        _class_list := '[]'::jsonb || _class_list;\r\n    END IF;\r\n\r\n    attrs := data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    new_class = attrs->>'newClass';\r\n    _properties := coalesce((attrs->'properties'),'{}'::jsonb);\r\n    _required   := coalesce((attrs -> 'required'),'[]'::jsonb);\r\n    FOR _class IN SELECT jsonb_array_elements_text(_class_list)\r\n    LOOP\r\n\r\n        SELECT reclada_object.get_schema(_class) \r\n            INTO class_schema;\r\n\r\n        IF (class_schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', _class;\r\n        END IF;\r\n\r\n        _properties :=  coalesce((class_schema#>'{attributes,schema,properties}'),'{}'::jsonb) || _properties;\r\n\r\n        SELECT jsonb_agg(el) \r\n            FROM \r\n            (\r\n                SELECT DISTINCT \r\n                        pg_catalog.jsonb_array_elements(\r\n                            coalesce(   class_schema#> '{attributes,schema,required}',\r\n                                        'null'::jsonb\r\n                                    ) || _required\r\n                        ) as el\r\n            ) arr\r\n                WHERE jsonb_typeof(el) != 'null'\r\n            INTO _required;\r\n\r\n        SELECT class_schema->>'GUID'\r\n            INTO class_guid;\r\n        \r\n        _parent_list := _parent_list || to_jsonb(class_guid);\r\n\r\n    END LOOP;\r\n    SELECT max(version) + 1\r\n    FROM reclada.v_class_lite v\r\n    WHERE v.for_class = new_class\r\n    INTO version_;\r\n\r\n    version_ := coalesce(version_,1);\r\n    class_schema := class_schema->'attributes'->'schema';\r\n\r\n    PERFORM reclada_object.create(format('{\r\n        "class": "jsonschema",\r\n        "attributes": {\r\n            "forClass": "%s",\r\n            "version": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n            },\r\n            "parentList":%s\r\n        }\r\n    }',\r\n    new_class,\r\n    version_,\r\n    _properties,\r\n    _required,\r\n    _parent_list\r\n    )::jsonb);\r\n\r\n    IF ( jsonb_typeof(attrs->'dupChecking') = 'array' ) THEN\r\n        FOR _uniFields IN (\r\n            SELECT jsonb_array_elements(attrs->'dupChecking')->'uniFields'\r\n        ) LOOP\r\n            IF ( jsonb_typeof(_uniFields) = 'array' ) THEN\r\n                SELECT\r\n                    reclada.get_unifield_index_name( array_agg(f ORDER BY f)) AS idx_name, \r\n                    string_agg('(attributes ->> ''' || f || ''')','||' ORDER BY f) AS fields_list\r\n                FROM (\r\n                    SELECT jsonb_array_elements_text (_uniFields::jsonb) f\r\n                ) a\r\n                    INTO _idx_name, _f_list;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM pg_catalog.pg_indexes pi2 \r\n                    WHERE schemaname ='reclada' AND tablename ='object' AND indexname =_idx_name\r\n                ) THEN\r\n                    EXECUTE E'CREATE INDEX ' || _idx_name || ' ON reclada.object USING HASH ((' || _f_list || '))';\r\n                END IF;\r\n            END IF;\r\n        END LOOP;\r\n        PERFORM reclada_object.refresh_mv('uniFields');\r\n    END IF;\r\n\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_filter_available_operator ;\nCREATE OR REPLACE VIEW reclada.v_filter_available_operator\nAS\n SELECT ' = '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' LIKE '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' NOT LIKE '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' || '::text AS operator,\n    'TEXT'::text AS input_type,\n    'TEXT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ~ '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !~ '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ~* '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !~* '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' SIMILAR TO '::text AS operator,\n    'TEXT'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' > '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' < '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' <= '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' != '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' >= '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' AND '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' OR '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' NOT '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' XOR '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' OPERATOR(reclada.##) '::text AS operator,\n    'BOOL'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IS '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IS NOT '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' IN '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    ' , '::text AS inner_operator\nUNION\n SELECT ' @> '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' <@ '::text AS operator,\n    'JSONB'::text AS input_type,\n    'BOOL'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' + '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' - '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' * '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' / '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' % '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ^ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' |/ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' ||/ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' !! '::text AS operator,\n    'INT'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' @ '::text AS operator,\n    'NUMERIC'::text AS input_type,\n    'NUMERIC'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' & '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' | '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' # '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' << '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' >> '::text AS operator,\n    'INT'::text AS input_type,\n    'INT'::text AS output_type,\n    NULL::text AS inner_operator\nUNION\n SELECT ' BETWEEN '::text AS operator,\n    'TIMESTAMP WITH TIME ZONE'::text AS input_type,\n    'BOOL'::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' Y/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' MON/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' D/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' H/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' MIN/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' S/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' DOW/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' DOY/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' Q/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator\nUNION\n SELECT ' W/BETWEEN '::text AS operator,\n    NULL::text AS input_type,\n    NULL::text AS output_type,\n    ' AND '::text AS inner_operator;\n\n\n\n\nDROP VIEW IF EXISTS reclada.v_unifields_pivoted;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_unifields;\nDROP VIEW IF EXISTS reclada.v_parent_field;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_task;\nDROP VIEW IF EXISTS reclada.v_ui_active_object;\nDROP VIEW IF EXISTS reclada.v_dto_json_schema;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_class_lite;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_user;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_status;\nDROP VIEW IF EXISTS reclada.v_object_display;\n\nDROP function IF EXISTS reclada_object.get_jsonschema_guid ;\nCREATE OR REPLACE FUNCTION reclada_object.get_jsonschema_guid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT class\r\n        FROM reclada.object o\r\n            where o.GUID = \r\n                (\r\n                    select class \r\n                        from reclada.object \r\n                            where class is not null \r\n                    limit 1\r\n                )\r\n$function$\n;\n\n\nCREATE MATERIALIZED VIEW reclada.v_class_lite\nAS\n    SELECT  obj.id,\n            obj.GUID as obj_id,\n            obj.attributes->>'forClass' as for_class,\n            (attributes->>'version')::bigint as version,\n            obj.created_time,\n            obj.attributes,\n            obj.status\n\tFROM reclada.object obj\n   \tWHERE obj.class = reclada_object.get_jsonschema_GUID();\n\nDROP function IF EXISTS reclada_object.get_guid_for_class ;\nCREATE OR REPLACE FUNCTION reclada_object.get_guid_for_class(class text)\n RETURNS TABLE(obj_id uuid)\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT obj_id\r\n        from reclada.v_class_lite\r\n            where for_class = class\r\n$function$\n;\n\nCREATE MATERIALIZED VIEW reclada.v_object_status\nAS\n    SELECT  obj.id            ,\n            obj.GUID as obj_id,\n            obj.attributes->>'caption' as caption,\n            obj.created_time  ,\n            obj.attributes as attrs\n\tFROM reclada.object obj\n   \tWHERE class in (select reclada_object.get_guid_for_class('ObjectStatus'));\n     \nCREATE MATERIALIZED VIEW reclada.v_user\nAS\n    SELECT  obj.id            ,\n            obj.GUID as obj_id,\n            obj.attributes->>'login' as login,\n            obj.created_time  ,\n            obj.attributes as attrs\n\tFROM reclada.object obj\n   \tWHERE class in (select reclada_object.get_guid_for_class('User'))\n        and status = reclada_object.get_active_status_obj_id();\nANALYZE reclada.v_user;\n\n\nDROP function IF EXISTS reclada_object.delete ;\nCREATE OR REPLACE FUNCTION reclada_object.delete(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_obj_id            uuid;\r\n    tran_id             bigint;\r\n    _class_name         text;\r\n    _class_name_from_uuid   text;\r\n    _class_uuid          uuid;\r\n    list_id             bigint[];\r\n    _for_class           text;\r\n    _uniFields_index_name          text;\r\nBEGIN\r\n\r\n    v_obj_id := data->>'GUID';\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    _class_name := data->>'class';\r\n\r\n    IF (v_obj_id IS NULL AND _class_name IS NULL AND tran_id IS NULl) THEN\r\n        RAISE EXCEPTION 'Could not delete object with no GUID, class and transactionID';\r\n    END IF;\r\n\r\n    _class_uuid := reclada.try_cast_uuid(_class_name);\r\n    IF _class_uuid IS NOT NULL THEN\r\n        SELECT v.for_class \r\n        FROM reclada.v_class_lite v\r\n        WHERE _class_uuid = v.obj_id\r\n            INTO _class_name_from_uuid;\r\n    END IF;\r\n\r\n    WITH t AS\r\n    (    \r\n        UPDATE reclada.object u\r\n            SET status = reclada_object.get_archive_status_obj_id()\r\n            FROM reclada.object o\r\n                LEFT JOIN\r\n                (   SELECT obj_id FROM reclada_object.get_GUID_for_class(_class_name)\r\n                    UNION SELECT _class_uuid WHERE _class_uuid IS NOT NULL\r\n                ) c ON o.class = c.obj_id\r\n                WHERE u.id = o.id AND\r\n                (\r\n                    (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                )\r\n                    AND o.status != reclada_object.get_archive_status_obj_id()\r\n                    RETURNING o.id\r\n    ) \r\n        SELECT\r\n            array\r\n            (\r\n                SELECT t.id FROM t\r\n            )\r\n        INTO list_id;\r\n\r\n    SELECT array_to_json\r\n    (\r\n        array\r\n        (\r\n            SELECT o.data\r\n            FROM reclada.v_object o\r\n            WHERE o.id IN (SELECT unnest(list_id))\r\n        )\r\n    )::jsonb\r\n    INTO data;\r\n\r\n    IF (jsonb_array_length(data) <= 1) THEN\r\n        data := data->0;\r\n    END IF;\r\n    \r\n    IF (data IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not delete object, no such GUID';\r\n    END IF;\r\n\r\n    PERFORM reclada_object.refresh_mv(COALESCE(_class_name_from_uuid, _class_name));\r\n\r\n    PERFORM reclada_notification.send_object_notification('delete', data);\r\n\r\n    RETURN data;\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_object_display ;\nCREATE OR REPLACE VIEW reclada.v_object_display\nAS\n SELECT obj.id,\n    obj.guid,\n    (obj.attributes ->> 'classGUID'::text)::uuid AS class_guid,\n    obj.attributes ->> 'caption'::text AS caption,\n    obj.attributes -> 'table'::text AS "table",\n    obj.attributes -> 'card'::text AS card,\n    obj.attributes -> 'preview'::text AS preview,\n    obj.attributes -> 'list'::text AS list,\n    obj.created_time,\n    obj.attributes,\n    obj.status\n   FROM object obj\n  WHERE obj.class = (( SELECT reclada_object.get_guid_for_class('ObjectDisplay'::text) AS get_guid_for_class)) AND obj.status = reclada_object.get_active_status_obj_id();\nDROP function IF EXISTS reclada_object.need_flat ;\nCREATE OR REPLACE FUNCTION reclada_object.need_flat(_class_name text)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\r\n    select exists\r\n        (\r\n            select true as r\r\n                from reclada.v_object_display d\r\n                join reclada_object.get_GUID_for_class(_class_name) tf\r\n                    on tf.obj_id = d.class_guid\r\n                where d.table is not null\r\n        )\r\n$function$\n;\n\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    ( SELECT (r.attributes ->> 'num'::text)::bigint AS num\n           FROM object r\n          WHERE (r.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class)) AND r.guid = NULLIF(t.attributes ->> 'revision'::text, ''::text)::uuid\n         LIMIT 1) AS revision_num,\n    os.caption AS status_caption,\n    NULLIF(t.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID",\n                    t.parent_guid AS "parentGUID",\n                    t.created_time AS "createdTime") tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id,\n    t.parent_guid\n   FROM object t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_object_display ;\nCREATE OR REPLACE VIEW reclada.v_object_display\nAS\n SELECT obj.id,\n    obj.guid,\n    (obj.attributes ->> 'classGUID'::text)::uuid AS class_guid,\n    obj.attributes ->> 'caption'::text AS caption,\n    obj.attributes -> 'table'::text AS "table",\n    obj.attributes -> 'card'::text AS card,\n    obj.attributes -> 'preview'::text AS preview,\n    obj.attributes -> 'list'::text AS list,\n    obj.created_time,\n    obj.attributes,\n    obj.status\n   FROM object obj\n  WHERE obj.class = (( SELECT reclada_object.get_guid_for_class('ObjectDisplay'::text) AS get_guid_for_class)) AND obj.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id,\n    t.parent_guid\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_dto_json_schema ;\nCREATE OR REPLACE VIEW reclada.v_dto_json_schema\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'function'::text AS function,\n    obj.attrs -> 'schema'::text AS schema,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'DTOJsonSchema'::text;\nDROP view IF EXISTS reclada.v_ui_active_object ;\nCREATE OR REPLACE VIEW reclada.v_ui_active_object\nAS\n SELECT 'with recursive \r\nd as ( \r\n    select  data, \r\n            obj_id\r\n        FROM reclada.v_active_object obj \r\n            where #@#@#where#@#@#\r\n),\r\nt as\r\n(\r\n    SELECT  je.key,\r\n            1 as q,\r\n            jsonb_typeof(je.value) typ,\r\n            d.obj_id,\r\n            je.value\r\n        from d \r\n        JOIN LATERAL jsonb_each(d.data) je\r\n            on true\r\n        where jsonb_typeof(je.value) != ''null''\r\n    union\r\n    SELECT \r\n            d.key ||'',''|| je.key as key ,\r\n            d.q,\r\n            jsonb_typeof(je.value) typ,\r\n            d.obj_id,\r\n            je.value\r\n        from (\r\n            select  d.data #> (''{''||t.key||''}'')::text[] as data, \r\n                    t.q+1 as q,\r\n                    t.key,\r\n                    d.obj_id\r\n            from t \r\n            join d\r\n                on t.typ = ''object''\r\n        ) d\r\n        JOIN LATERAL jsonb_each(d.data) je\r\n            on true\r\n        where jsonb_typeof(je.value) != ''null''\r\n),\r\nres as\r\n(\r\n    select  rr.obj_id,\r\n            rr.data,\r\n            rr.display_key,\r\n            o.attrs,\r\n            o.created_time\r\n        from\r\n        (\r\n            select  t.obj_id,\r\n                    jsonb_object_agg\r\n                    (\r\n                        ''{''||t.key||''}'',\r\n                        t.value\r\n                    ) as data,\r\n                    array_agg(\r\n                        ''{''||t.key||''}:''||t.typ \r\n                    ) as display_key\r\n                from t \r\n                    where t.typ != ''object''\r\n                    group by t.obj_id\r\n        ) rr\r\n        join reclada.v_active_object o\r\n            on o.obj_id = rr.obj_id\r\n)\r\n'::text AS val;\nDROP view IF EXISTS reclada.v_task ;\nCREATE OR REPLACE VIEW reclada.v_task\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    obj.attrs ->> 'type'::text AS type,\n    obj.attrs ->> 'command'::text AS command,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'Task'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    (obj.attrs ->> 'version'::text)::bigint AS version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_parent_field ;\nCREATE OR REPLACE VIEW reclada.v_parent_field\nAS\n SELECT v_class.for_class,\n    v_class.obj_id AS class_uuid,\n    v_class.attributes ->> 'parentField'::text AS parent_field\n   FROM v_class_lite v_class\n  WHERE (v_class.attributes ->> 'parentField'::text) IS NOT NULL;\nDROP view IF EXISTS reclada.v_filter_mapping ;\nCREATE OR REPLACE VIEW reclada.v_filter_mapping\nAS\n SELECT '{class}'::text AS pattern,\n    'class_name'::text AS repl;\n\n\nCREATE MATERIALIZED VIEW reclada.v_object_unifields\nAS\n    SELECT\n        for_class,\n        class_uuid,\n        CAST (dup_behavior AS reclada.dp_bhvr) AS dup_behavior,\n        is_cascade,\n        is_mandatory,\n        uf as unifield,\n        uni_number,\n        row_number() OVER (PARTITION BY for_class,uni_number ORDER BY uf) AS field_number,\n        copy_field\n    FROM\n        (\n        SELECT\n            for_class,\n            obj_id                                      AS class_uuid,\n            dup_behavior,\n            is_cascade::boolean                         AS is_cascade,\n            (dc->>'isMandatory')::boolean               AS is_mandatory,\n            jsonb_array_elements_text(dc->'uniFields')  AS uf,\n            dc->'uniFields'::text                       AS field_list,\n            row_number() OVER ( PARTITION BY for_class ORDER BY dc->'uniFields'::text) AS uni_number,\n            copy_field\n        FROM\n            (\n            SELECT\n                for_class,\n                attributes->>'dupBehavior'           AS dup_behavior,\n                (attributes->>'isCascade')           AS is_cascade,\n                jsonb_array_elements( attributes ->'dupChecking') AS dc,\n                obj_id,\n                attributes->>'copyField' as copy_field\n            FROM\n                reclada.v_class_lite vc\n            WHERE\n                attributes ->'dupChecking' is not null\n            ) a\n        ) b\n;\n\nDROP view IF EXISTS reclada.v_unifields_pivoted ;\nCREATE OR REPLACE VIEW reclada.v_unifields_pivoted\nAS\n SELECT vou.class_uuid,\n    vou.uni_number,\n    vou.dup_behavior,\n    vou.is_cascade,\n    vou.copy_field,\n    max(\n        CASE\n            WHEN vou.field_number = 1 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f1,\n    max(\n        CASE\n            WHEN vou.field_number = 2 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f2,\n    max(\n        CASE\n            WHEN vou.field_number = 3 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f3,\n    max(\n        CASE\n            WHEN vou.field_number = 4 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f4,\n    max(\n        CASE\n            WHEN vou.field_number = 5 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f5,\n    max(\n        CASE\n            WHEN vou.field_number = 6 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f6,\n    max(\n        CASE\n            WHEN vou.field_number = 7 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f7,\n    max(\n        CASE\n            WHEN vou.field_number = 8 THEN vou.unifield\n            ELSE NULL::text\n        END) AS f8\n   FROM v_object_unifields vou\n  WHERE vou.is_mandatory\n  GROUP BY vou.class_uuid, vou.uni_number, vou.dup_behavior, vou.is_cascade, vou.copy_field\n  ORDER BY vou.class_uuid, vou.uni_number, vou.dup_behavior;\n\nCREATE INDEX class_lite_class_idx ON reclada.v_class_lite USING btree (for_class);\nCREATE INDEX class_lite_obj_idx ON reclada.v_class_lite USING btree (obj_id);\n\n\n\n	2022-02-08 06:55:08.356733+00
49	48	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 48 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\n-- i 'function/reclada_object.update.sql'\n\n\n--{ REC-564\ncreate table dev.component(\n    name        text not null,\n    repository  text not null,\n    commit_hash text not null,\n    guid        uuid not null\n);\n\ncreate table dev.component_object(\n    id     BIGINT   NOT NULL\n                    GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1)\n                    PRIMARY KEY,\n    status text  not null DEFAULT 'need to check',-- ok, update, create, delete, create_subclass \n    data   jsonb not null \n);\n\n    i 'view/reclada.v_component.sql'\n    i 'view/reclada.v_relationship.sql'\n    i 'view/reclada.v_component_object.sql'\n    i 'function/reclada_object.get_parent_guid.sql'\n    i 'function/reclada_object.create_relationship.sql'\n    -- i 'function/reclada_object.create.sql'\n\n    SELECT reclada_object.create_subclass('{\n        "class": "RecladaObject",\n        "attributes": {\n            "newClass": "Component",\n            "properties": {\n                "name": {"type": "string"},\n                "commitHash": {"type": "string"},\n                "repository": {"type": "string"}\n            },\n            "required": ["name","commitHash","repository"]\n        }\n    }'::jsonb);\n\n    SELECT reclada_object.create(\n        '{\n            "GUID": "b17500cb-e998-4f55-979b-2ba1218a3b45",\n            "class":"Component",\n            "attributes": {\n                "name":"reclada-runtime",\n                "repository":"https://gitlab.reclada.com/developers/reclada-runtime.git",\n                "commitHash":"00000"\n            }\n        }'::jsonb);\n\n    SELECT reclada_object.create(\n        '{\n            "GUID": "38d35ba3-7910-4e6e-8632-13203269e4b9",\n            "class":"Component",\n            "attributes": {\n                "name":"SciNLP",\n                "repository":"https://gitlab.reclada.com/developers/SciNLP.git",\n                "commitHash":"00000"\n            }\n        }'::jsonb);\n    \n    SELECT reclada_object.create(\n        '{\n            "GUID": "7534ae14-df31-47aa-9b46-2ad3e60b4b6e",\n            "class":"Component",\n            "attributes": {\n                "name":"db",\n                "repository":"https://gitlab.reclada.com/developers/db.git",\n                "commitHash":"00000"\n            }\n        }'::jsonb);\n\n    SELECT reclada_object.create_subclass('{\n            "class": "RecladaObject",\n            "attributes": {\n                "newClass": "Index",\n                "properties": {\n                    "name": {"type": "string"},\n                    "method": {\n                        "type": "string",\n                        "enum ": [\n                            "btree", \n                            "hash" , \n                            "gist" , \n                            "gin"\n                        ]\n                    },\n                    "wherePredicate": {\n                        "type": "string"\n                    },\n                    "fields": {\n                        "items": {\n                            "type": "string"\n                        },\n                        "type": "array",\n                        "minContains": 1\n                    }\n                },\n                "required": ["name","fields"]\n            }\n        }'::jsonb);\n\n    select reclada_object.create(\n            jsonb_build_object( 'class'  ,   'Index',\n                                'attributes', jsonb_build_object(\n                                    'name'  ,         t.name,\n                                    'method',         t.method,\n                                    'fields',         t.fields,\n                                    'wherePredicate', t.wherePredicate\n                                )\n            )\n        )\n        FROM\n        (\n            SELECT  distinct \n                    ns.nspname as schema, \n                    i.relname  as name  , \n                    am.amname  as method,\n                    t.relname  as table ,\n                    to_jsonb(\n                        regexp_split_to_array(\n                            pg_catalog.pg_get_expr(ix.indexprs, ix.indrelid),\n                            ','\n                        )\n                    ) AS fields,\n                    split_part(dml.dml,'WHERE ',2) as wherePredicate\n                FROM pg_catalog.pg_index ix\n                JOIN pg_catalog.pg_class i \n                    ON i.oid = ix.indexrelid \n                JOIN pg_catalog.pg_class t \n                    ON t.oid = ix.indrelid \n                JOIN pg_catalog.pg_namespace ns \n                    ON ns.oid = i.relnamespace\n                join pg_catalog.pg_opclass cl \n                    on cl.oid = any(ix.indclass)\n                join pg_catalog.pg_am am \n                    on am.oid = cl.opcmethod\n                cross join lateral pg_get_indexdef(\n                                        (ns.nspname||'.'||i.relname)::regclass\n                                    ) dml\n                WHERE t.relname = 'object'\n                    AND ns.nspname = 'reclada'\n                    AND ix.indexprs IS NOT NULL\n        ) t;\n    -- reclada-runtime\n    select reclada_object.create_relationship\n                        (\n                            'data of reclada-component',\n                            'b17500cb-e998-4f55-979b-2ba1218a3b45',\n                            o.guid,\n                            '{}'::jsonb,\n                            'b17500cb-e998-4f55-979b-2ba1218a3b45'\n                        )\n        from reclada.object o\n            where (\n                o.class in (select reclada_object.get_GUID_for_class('jsonschema'))\n                and o.attributes->>'forClass' in (  'Connector',\n                                                    'Environment',\n                                                    'FileExtension',\n                                                    'Job',\n                                                    'Parameter',\n                                                    'Pipeline',\n                                                    'Runner',\n                                                    'Task',\n                                                    'Trigger',\n                                                    'Value',\n                                                    'PipelineLite'\n                                                )\n                )\n                or o.class in \n                (\n                    select reclada_object.get_GUID_for_class('Runner')\n                    UNION \n                    select reclada_object.get_GUID_for_class('Task')\n                    UNION \n                    select reclada_object.get_GUID_for_class('PipelineLite')\n                    UNION \n                    select reclada_object.get_GUID_for_class('FileExtension')\n                );\n    -- SciNLP\n    select reclada_object.create_relationship\n                        (\n                            'data of reclada-component',\n                            '38d35ba3-7910-4e6e-8632-13203269e4b9',\n                            o.guid,\n                            '{}'::jsonb,\n                            '38d35ba3-7910-4e6e-8632-13203269e4b9'\n                        )\n        from reclada.object o\n            where o.class in (select reclada_object.get_GUID_for_class('jsonschema'))\n                and o.attributes->>'forClass' in (  'Document',\n                                                    'Page',\n                                                    'BBox',\n                                                    'TextBlock',\n                                                    'Table',\n                                                    'Cell',\n                                                    'NLPattern',\n                                                    'NLPatternAttribute',\n                                                    'HeaderTerm',\n                                                    'DataRow',\n                                                    'Attribute',\n                                                    'Data'\n                                                );\n\n    select reclada_object.create_relationship\n                        (\n                            'data of reclada-component',\n                            '7534ae14-df31-47aa-9b46-2ad3e60b4b6e',\n                            o.guid,\n                            '{}'::jsonb,\n                            '7534ae14-df31-47aa-9b46-2ad3e60b4b6e'\n                        )\n        from reclada.object o\n            where o.class in \n            (\n                select reclada_object.get_GUID_for_class('Context')\n                UNION\n                select reclada_object.get_GUID_for_class('Index')\n            );\n\n--} REC-564\n\n--{ REC-594\ni 'view/reclada.v_filter_mapping.sql'\ni 'view/reclada.v_object.sql' \ni 'view/reclada.v_class.sql'\n--} REC-594\n\n--{ REC-562\ni 'function/reclada_object.get_schema.sql'\ni 'function/reclada.get_validation_schema.sql'\n\ni 'function/reclada.validate_json_schema.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.create_subclass.sql'\n\n--} REC-562\n\n\n--{ REC-564\ndrop function reclada_object.datasource_insert;\ni 'function/reclada_object.object_insert.sql'\ni 'function/reclada_object.delete.sql'\ni 'function/dev.begin_install_component.sql'\ni 'function/dev.finish_install_component.sql'\ni 'view/reclada.v_ui_active_object.sql' \n\n--} REC-564\n\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, current version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\n\n--{ REC-564\n\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    _data         jsonb;\r\n    new_data      jsonb;\r\n    _class_name    text;\r\n    _class_uuid   uuid;\r\n    tran_id       bigint;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    _obj_guid     uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    inserted      uuid[];\r\n    inserted_from_draft uuid[];\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _is_cascade   boolean;\r\n    _uni_field    text;\r\n    _parent_guid  uuid;\r\n    _parent_field   text;\r\n    skip_insert     boolean;\r\n    notify_res      jsonb;\r\n    _cnt             int;\r\n    _new_parent_guid       uuid;\r\n    _rel_type       text := 'GUID changed for dupBehavior';\r\n    _guid_list      text;\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision AND others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    FOR _data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n        skip_insert := false;\r\n        _class_name := _data->>'class';\r\n\r\n        IF (_class_name IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n        _class_uuid := reclada.try_cast_uuid(_class_name);\r\n\r\n        _attrs := _data->'attributes';\r\n        IF (_attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        tran_id := (_data->>'transactionID')::bigint;\r\n        IF tran_id IS NULL THEN\r\n            tran_id := reclada.get_transaction_id();\r\n        END IF;\r\n\r\n        IF _class_uuid IS NULL THEN\r\n            SELECT reclada_object.get_schema(_class_name) \r\n            INTO schema;\r\n            _class_uuid := (schema->>'GUID')::uuid;\r\n        ELSE\r\n            SELECT v.data, v.for_class\r\n            FROM reclada.v_class v\r\n            WHERE _class_uuid = v.obj_id\r\n            INTO schema, _class_name;\r\n        END IF;\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', _class_name;\r\n        END IF;\r\n\r\n        IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', _attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: \r\n                %, \r\n                schema: \r\n                %', \r\n                _attrs,\r\n                schema#>>'{attributes,schema}';\r\n        END IF;\r\n        \r\n        IF _data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        SELECT prnt_guid, prnt_field\r\n        FROM reclada_object.get_parent_guid(_data,_class_name)\r\n            INTO _parent_guid,\r\n                _parent_field;\r\n        _obj_guid := _data->>'GUID';\r\n\r\n        IF (_parent_guid IS NOT NULL) THEN\r\n            SELECT\r\n                attrs->>'object',\r\n                attrs->>'dupBehavior',\r\n                attrs->>'isCascade'\r\n            FROM reclada.v_active_object\r\n            WHERE class_name = 'Relationship'\r\n                AND attrs->>'type'                      = _rel_type\r\n                AND (attrs->>'subject')::uuid  = _parent_guid\r\n                    INTO _new_parent_guid, _dup_behavior, _is_cascade;\r\n\r\n            IF _new_parent_guid IS NOT NULL THEN\r\n                _parent_guid := _new_parent_guid;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.v_object_unifields\r\n            WHERE class_uuid = _class_uuid\r\n        )\r\n        THEN\r\n            IF (_parent_guid IS NOT NULL) THEN\r\n                IF (_dup_behavior = 'Update' AND _is_cascade) THEN\r\n                    SELECT count(DISTINCT obj_guid), string_agg(DISTINCT obj_guid::text, ',')\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                        INTO _cnt, _guid_list;\r\n                    IF (_cnt >1) THEN\r\n                        RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                    ELSIF (_cnt = 1) THEN\r\n                        SELECT DISTINCT obj_guid, is_cascade\r\n                        FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                            INTO _obj_guid, _is_cascade;\r\n                        new_data := _data;\r\n                        IF new_data->>'GUID' IS NOT NULL THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                        END IF;\r\n                        new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                        new_data = reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                        SELECT reclada_object.update(new_data)\r\n                            INTO res;\r\n                        affected := array_append( affected, _obj_guid);\r\n                        skip_insert := true;\r\n                    END IF;\r\n                END IF;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM reclada.v_active_object\r\n                    WHERE obj_id = _parent_guid\r\n                )\r\n                    AND _new_parent_guid IS NULL\r\n                THEN\r\n                    IF (_obj_guid IS NULL) THEN\r\n                        RAISE EXCEPTION 'GUID is required.';\r\n                    END IF;\r\n                    INSERT INTO reclada.draft(guid, parent_guid, data)\r\n                        VALUES(_obj_guid, _parent_guid, _data);\r\n                    skip_insert := true;\r\n                END IF;\r\n            END IF;\r\n\r\n            IF (NOT skip_insert) THEN\r\n                SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg (DISTINCT obj_guid::text, ',')\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                GROUP BY dup_behavior\r\n                    INTO _cnt, _dup_behavior, _guid_list;\r\n                IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n                    RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                END IF;\r\n                FOR _obj_guid, _dup_behavior, _is_cascade, _uni_field IN\r\n                    SELECT obj_guid, dup_behavior, is_cascade, dup_field\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                LOOP\r\n                    new_data := _data;\r\n                    CASE _dup_behavior\r\n                        WHEN 'Replace' THEN\r\n                            IF (_is_cascade = true) THEN\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', a)::jsonb)\r\n                                FROM reclada.get_children(_obj_guid) a;\r\n                            ELSE\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                            END IF;\r\n                        WHEN 'Update' THEN\r\n                            IF new_data->>'GUID' IS NOT NULL THEN\r\n                                PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                            END IF;\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            new_data := reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                            SELECT reclada_object.update(new_data)\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                        WHEN 'Reject' THEN\r\n                            RAISE EXCEPTION 'The object was rejected.';\r\n                        WHEN 'Copy'    THEN\r\n                            _attrs := _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                        WHEN 'Insert' THEN\r\n                            -- DO nothing\r\n                        WHEN 'Merge' THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                _rel_type,\r\n                                _obj_guid,\r\n                                (new_data->>'GUID')::uuid,\r\n                                '{"dupBehavior": "Merge"}'::jsonb);\r\n                            SELECT reclada_object.update(reclada_object.merge(new_data - 'class', data,schema->'attributes'->'schema') || format('{"GUID": "%s"}', _obj_guid)::jsonb || format('{"transactionID": %s}', tran_id)::jsonb)\r\n                            FROM reclada.v_active_object\r\n                            WHERE obj_id = _obj_guid\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                    END CASE;\r\n                END LOOP;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF (NOT skip_insert) THEN\r\n            _obj_guid := (_data->>'GUID')::uuid;\r\n            IF EXISTS (\r\n                SELECT 1\r\n                FROM reclada.object \r\n                WHERE GUID = _obj_guid\r\n            ) THEN\r\n                RAISE EXCEPTION 'GUID: % is duplicate', _obj_guid;\r\n            END IF;\r\n            --raise notice 'schema: %',schema;\r\n\r\n            INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n                SELECT  CASE\r\n                            WHEN _obj_guid IS NULL\r\n                                THEN public.uuid_generate_v4()\r\n                            ELSE _obj_guid\r\n                        END AS GUID,\r\n                        _class_uuid, \r\n                        _attrs,\r\n                        tran_id,\r\n                        _parent_guid\r\n            RETURNING GUID INTO _obj_guid;\r\n            affected := array_append( affected, _obj_guid);\r\n            inserted := array_append( inserted, _obj_guid);\r\n            PERFORM reclada_object.datasource_insert\r\n                (\r\n                    _class_name,\r\n                    _obj_guid,\r\n                    _attrs\r\n                );\r\n\r\n            PERFORM reclada_object.refresh_mv(_class_name);\r\n        END IF;\r\n    END LOOP;\r\n\r\n    SELECT array_agg(_affected_objects->>'GUID')\r\n    FROM (\r\n        SELECT jsonb_array_elements(_affected_objects) AS _affected_objects\r\n        FROM (\r\n            SELECT reclada_object.create(data) AS _affected_objects\r\n            FROM reclada.draft\r\n            WHERE parent_guid = ANY (affected)\r\n        ) a\r\n    ) b\r\n    WHERE _affected_objects->>'GUID' IS NOT NULL\r\n        INTO inserted_from_draft;\r\n    affected := affected || inserted_from_draft;    \r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb;\r\n    notify_res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (inserted)\r\n                )\r\n            )::jsonb; \r\n    \r\n    DELETE FROM reclada.draft \r\n        WHERE guid = ANY (affected);\r\n\r\n    PERFORM reclada.update_unique_object(affected);\r\n        \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            notify_res\r\n        );\r\n    RETURN res;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create_relationship ;\nCREATE OR REPLACE FUNCTION reclada_object.create_relationship(_rel_type text, _obj_guid uuid, _subj_guid uuid, _extra_attrs jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _rel_cnt    int;\r\n    _obj        jsonb;\r\nBEGIN\r\n\r\n    IF (_obj_GUID IS NULL OR _subj_GUID IS NULL) THEN\r\n        RAISE EXCEPTION 'Object GUID or Subject GUID IS NULL';\r\n    END IF;\r\n\r\n    SELECT count(*)\r\n    FROM reclada.v_active_object\r\n    WHERE class_name = 'Relationship'\r\n        AND NULLIF(attrs->>'object','')::uuid   = _obj_GUID\r\n        AND NULLIF(attrs->>'subject','')::uuid  = _subj_GUID\r\n        AND attrs->>'type'                      = _rel_type\r\n            INTO _rel_cnt;\r\n    IF (_rel_cnt = 0) THEN\r\n        _obj := format('{\r\n            "class": "Relationship",\r\n            "attributes": {\r\n                "type": "%s",\r\n                "object": "%s",\r\n                "subject": "%s"\r\n                }\r\n            }',\r\n            _rel_type,\r\n            _obj_GUID,\r\n            _subj_GUID)::jsonb;\r\n        _obj := jsonb_set (_obj, '{attributes}', _obj->'attributes' || _extra_attrs);   \r\n\r\n        RETURN  reclada_object.create( _obj);\r\n    ELSE\r\n        RETURN '{}'::jsonb;\r\n    END IF;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.get_parent_guid ;\nCREATE OR REPLACE FUNCTION reclada_object.get_parent_guid(_data jsonb, _class_name text)\n RETURNS TABLE(prnt_guid uuid, prnt_field text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    _parent_field   text;\r\n    _parent_guid    uuid;\r\nBEGIN\r\n    SELECT parent_field\r\n    FROM reclada.v_parent_field\r\n    WHERE for_class = _class_name\r\n        INTO _parent_field;\r\n\r\n    _parent_guid = (_data->>'parent_guid')::uuid;\r\n    IF (_parent_guid IS NULL AND _parent_field IS NOT NULL) THEN\r\n        _parent_guid = _data->'attributes'->>_parent_field;\r\n    END IF;\r\n    RETURN QUERY\r\n    SELECT _parent_guid,\r\n        _parent_field;\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_component_object ;\n\nDROP view IF EXISTS reclada.v_relationship ;\n\nDROP view IF EXISTS reclada.v_component ;\n\n\n    delete from reclada.object \n        where parent_guid in (  '7534ae14-df31-47aa-9b46-2ad3e60b4b6e',\n                                '38d35ba3-7910-4e6e-8632-13203269e4b9',\n                                'b17500cb-e998-4f55-979b-2ba1218a3b45'\n                            );\n\n    delete from reclada.object \n        where class in (select reclada_object.get_GUID_for_class('Component'));\n\n    delete from reclada.object \n        where guid in (select reclada_object.get_GUID_for_class('Component'));\n    \n    delete from reclada.object \n        where class in (select reclada_object.get_GUID_for_class('Index'));\n    \n    delete from reclada.object \n        where guid in (select reclada_object.get_GUID_for_class('Index'));\n--} REC-564\n\n\n--{ REC-594\n\nDROP view IF EXISTS reclada.v_filter_mapping ;\nCREATE OR REPLACE VIEW reclada.v_filter_mapping\nAS\n SELECT '{class}'::text AS pattern,\n    'class_name'::text AS repl\nUNION\n SELECT '{status}'::text AS pattern,\n    'status_caption'::text AS repl\nUNION\n SELECT '{GUID}'::text AS pattern,\n    'obj_id'::text AS repl\nUNION\n SELECT '{transactionID}'::text AS pattern,\n    'transaction_id'::text AS repl\nUNION\n SELECT '{createdTime}'::text AS pattern,\n    'created_time'::text AS repl\nUNION\n SELECT '{createdBy}'::text AS pattern,\n    'created_by'::text AS repl\nUNION\n SELECT '{classGUID}'::text AS pattern,\n    'class'::text AS repl\nUNION\n SELECT '{parentGUID}'::text AS pattern,\n    'parent_guid'::text AS repl;\n\nDROP VIEW reclada.v_revision;\nDROP VIEW reclada.v_import_info;\nDROP VIEW reclada.v_dto_json_schema;\nDROP VIEW reclada.v_class;\nDROP VIEW reclada.v_task;\nDROP VIEW reclada.v_object_display;\nDROP VIEW reclada.v_active_object;\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    ( SELECT (r.attributes ->> 'num'::text)::bigint AS num\n           FROM object r\n          WHERE (r.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class)) AND r.guid = NULLIF(t.attributes ->> 'revision'::text, ''::text)::uuid\n         LIMIT 1) AS revision_num,\n    os.caption AS status_caption,\n    NULLIF(t.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    cl.default_value,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID",\n                    t.parent_guid AS "parentGUID",\n                    t.created_by AS "createdBy",\n                    t.created_time AS "createdTime") tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id,\n    t.parent_guid\n   FROM object t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id,\n    t.parent_guid,\n    t.default_value\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_object_display ;\nCREATE OR REPLACE VIEW reclada.v_object_display\nAS\n SELECT obj.id,\n    obj.guid,\n    (obj.attributes ->> 'classGUID'::text)::uuid AS class_guid,\n    obj.attributes ->> 'caption'::text AS caption,\n    obj.attributes -> 'table'::text AS "table",\n    obj.attributes -> 'card'::text AS card,\n    obj.attributes -> 'preview'::text AS preview,\n    obj.attributes -> 'list'::text AS list,\n    obj.created_time,\n    obj.attributes,\n    obj.status\n   FROM object obj\n  WHERE obj.class = (( SELECT reclada_object.get_guid_for_class('ObjectDisplay'::text) AS get_guid_for_class)) AND obj.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_task ;\nCREATE OR REPLACE VIEW reclada.v_task\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    obj.attrs ->> 'type'::text AS type,\n    obj.attrs ->> 'command'::text AS command,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'Task'::text;\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'forClass'::text AS for_class,\n    (obj.attrs ->> 'version'::text)::bigint AS version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid,\n    obj.default_value\n   FROM v_active_object obj\n  WHERE obj.class_name = 'jsonschema'::text;\nDROP view IF EXISTS reclada.v_dto_json_schema ;\nCREATE OR REPLACE VIEW reclada.v_dto_json_schema\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'function'::text AS function,\n    obj.attrs -> 'schema'::text AS schema,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'DTOJsonSchema'::text;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\n\n--} REC-594\n\n\n--{ REC-562\n\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(data jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _class_list     jsonb;\r\n    _class          text;\r\n    _properties     jsonb;\r\n    _required       jsonb;\r\n    _parent_list    jsonb := '[]';\r\n    new_class       text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n    version_        integer;\r\n    class_guid      uuid;\r\n    _uniFields      jsonb;\r\n    _idx_name       text;\r\n    _f_list         text;\r\n    _f_name         text = 'reclada_object.create_subclass';\r\n    _partial_clause text;\r\n    _field_name     text;\r\n    _create_obj     jsonb;\r\nBEGIN\r\n\r\n    _class_list := data->'class';\r\n    IF (_class_list IS NULL) THEN\r\n        perform reclada.raise_exception('The reclada object class is not specified',_f_name);\r\n    END IF;\r\n\r\n    IF (jsonb_typeof(_class_list) != 'array') THEN\r\n        _class_list := '[]'::jsonb || _class_list;\r\n    END IF;\r\n\r\n    attrs := data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    IF attrs #>'{properties, default}' IS NOT NULL THEN\r\n        RAISE EXCEPTION 'Cannot use reserved words for field name';\r\n    END IF;\r\n\r\n    new_class = attrs->>'newClass';\r\n    _properties := coalesce((attrs->'properties'),'{}'::jsonb);\r\n    _required   := coalesce((attrs -> 'required'),'[]'::jsonb);\r\n    FOR _class IN SELECT jsonb_array_elements_text(_class_list)\r\n    LOOP\r\n\r\n        SELECT reclada_object.get_schema(_class) \r\n            INTO class_schema;\r\n\r\n        IF (class_schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', _class;\r\n        END IF;\r\n\r\n        _properties :=  coalesce((class_schema#>'{attributes,schema,properties}'),'{}'::jsonb) || _properties;\r\n\r\n        SELECT jsonb_agg(el) \r\n            FROM \r\n            (\r\n                SELECT DISTINCT \r\n                        pg_catalog.jsonb_array_elements(\r\n                            coalesce(   class_schema#> '{attributes,schema,required}',\r\n                                        'null'::jsonb\r\n                                    ) || _required\r\n                        ) as el\r\n            ) arr\r\n                WHERE jsonb_typeof(el) != 'null'\r\n            INTO _required;\r\n\r\n        SELECT class_schema->>'GUID'\r\n            INTO class_guid;\r\n        \r\n        _parent_list := _parent_list || to_jsonb(class_guid);\r\n\r\n    END LOOP;\r\n    SELECT max(version) + 1\r\n    FROM reclada.v_class_lite v\r\n    WHERE v.for_class = new_class\r\n    INTO version_;\r\n\r\n    version_ := coalesce(version_,1);\r\n    class_schema := class_schema->'attributes'->'schema';\r\n\r\n    _create_obj := format('{\r\n        "class": "jsonschema",\r\n        "attributes": {\r\n            "forClass": "%s",\r\n            "version": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n            },\r\n            "parentList":%s\r\n        }\r\n    }',\r\n    new_class,\r\n    version_,\r\n    _properties,\r\n    _required,\r\n    _parent_list\r\n    )::jsonb;\r\n    IF ( jsonb_typeof(attrs->'dupChecking') = 'array' ) THEN\r\n        _create_obj := jsonb_set(_create_obj, '{attributes,dupChecking}',attrs->'dupChecking');\r\n        IF ( jsonb_typeof(attrs->'dupBehavior') = 'string' ) THEN\r\n            _create_obj := jsonb_set(_create_obj, '{attributes,dupBehavior}',attrs->'dupBehavior');\r\n        END IF;\r\n        IF ( jsonb_typeof(attrs->'isCascade') = 'boolean' ) THEN\r\n            _create_obj := jsonb_set(_create_obj, '{attributes,isCascade}',attrs->'isCascade');\r\n        END IF;\r\n        IF ( jsonb_typeof(attrs->'copyField') = 'string' ) THEN\r\n            _create_obj := jsonb_set(_create_obj, '{attributes,copyField}',attrs->'copyField');\r\n        END IF;\r\n    END IF;\r\n    IF ( jsonb_typeof(attrs->'parentField') = 'string' ) THEN\r\n        _create_obj := jsonb_set(_create_obj, '{attributes,parentField}',attrs->'parentField');\r\n    END IF;\r\n    PERFORM reclada_object.create(_create_obj);\r\n\r\n    IF ( jsonb_typeof(attrs->'dupChecking') = 'array' ) THEN\r\n        FOR _uniFields IN (\r\n            SELECT jsonb_array_elements(attrs->'dupChecking')->'uniFields'\r\n        ) LOOP\r\n            IF ( jsonb_typeof(_uniFields) = 'array' ) THEN\r\n                SELECT\r\n                    reclada.get_unifield_index_name( array_agg(f ORDER BY f)) AS idx_name, \r\n                    string_agg('(attributes ->> ''' || f || ''')','||' ORDER BY f) AS fields_list,\r\n                    string_agg('attributes ->> ''' || f || ''' IS NOT NULL',' AND ' ORDER BY f) AS partial_clause\r\n                FROM (\r\n                    SELECT jsonb_array_elements_text (_uniFields) f\r\n                ) a\r\n                    INTO _idx_name, _f_list, _partial_clause;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM pg_catalog.pg_indexes pi2 \r\n                    WHERE schemaname ='reclada' AND tablename ='object' AND indexname =_idx_name\r\n                ) THEN\r\n                    EXECUTE E'CREATE INDEX ' || _idx_name || ' ON reclada.object USING HASH ((' || _f_list || ')) WHERE ' || _partial_clause;\r\n                END IF;\r\n            END IF;\r\n        END LOOP;\r\n        PERFORM reclada_object.refresh_mv('uniFields');\r\n    END IF;\r\n\r\n    FOR _field_name IN \r\n        SELECT DISTINCT el\r\n        FROM pg_catalog.jsonb_array_elements_text(\r\n                (class_schema -> 'required') || coalesce((attrs -> 'required'),'[]'::jsonb)\r\n            ) el\r\n        WHERE NOT EXISTS (\r\n            SELECT relname, ind_expr\r\n            FROM (\r\n                SELECT i.relname, pg_get_expr(ix.indexprs, ix.indrelid) AS ind_expr\r\n                FROM pg_index ix\r\n                JOIN pg_class i ON i.oid = ix.indexrelid \r\n                JOIN pg_class t ON t.oid = ix.indrelid \r\n                WHERE t.relname = 'object'\r\n                AND ix.indexprs IS NOT NULL\r\n            ) a\r\n            WHERE\r\n                length(ind_expr) - length(REPLACE(ind_expr,'->',''))= 2\r\n                AND strpos(ind_expr,el) > 0\r\n        )\r\n    LOOP\r\n        IF _properties->_field_name->>'type' = 'number' THEN\r\n            EXECUTE E'CREATE INDEX ' || _field_name || '_index_ ON reclada.object USING BTREE (( attributes ->''' || _field_name || ''')) WHERE attributes ->''' || _field_name || ''' IS NOT NULL';\r\n        ELSIF _properties->_field_name->>'type' = 'array' THEN\r\n            EXECUTE E'CREATE INDEX ' || _field_name || '_index_ ON reclada.object USING GIN (( attributes ->''' || _field_name || ''')) WHERE attributes ->''' || _field_name || ''' IS NOT NULL';\r\n        ELSIF _properties->_field_name->>'type' = 'string' AND \r\n            (_properties->_field_name->>'enum' IS NOT NULL OR _properties->_field_name->>'pattern' = '[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}')THEN\r\n            EXECUTE E'CREATE INDEX ' || _field_name || '_index_ ON reclada.object USING HASH (( attributes ->''' || _field_name || ''')) WHERE attributes ->''' || _field_name || ''' IS NOT NULL';\r\n        END IF;\r\n    END LOOP;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(_data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name       TEXT = 'reclada_object.update';\r\n    _class_name   text;\r\n    _class_uuid   uuid;\r\n    _obj_id       uuid;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    old_obj       jsonb;\r\n    branch        uuid;\r\n    revid         uuid;\r\n    _parent_guid  uuid;\r\n    _parent_field text;\r\n    _obj_guid     uuid;\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _uni_field    text;\r\n    _cnt          int;\r\n    _guid_list      text;\r\nBEGIN\r\n\r\n    _class_name := _data->>'class';\r\n    IF (_class_name IS NULL) THEN\r\n        perform reclada.raise_exception(\r\n                        'The reclada object class is not specified',\r\n                        _f_name\r\n                    );\r\n    END IF;\r\n    _class_uuid := reclada.try_cast_uuid(_class_name);\r\n    _obj_id := _data->>'GUID';\r\n    IF (_obj_id IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object with no GUID';\r\n    END IF;\r\n\r\n    _attrs := _data->'attributes';\r\n    IF (_attrs IS NULL) THEN\r\n        RAISE EXCEPTION 'The reclada object must have attributes';\r\n    END IF;\r\n\r\n    if _class_uuid is null then\r\n        SELECT reclada_object.get_schema(_class_name) \r\n            INTO schema;\r\n    else\r\n        select v.data, v.for_class \r\n            from reclada.v_class v\r\n                where _class_uuid = v.obj_id\r\n            INTO schema, _class_name;\r\n    end if;\r\n    -- TODO: don't allow update jsonschema\r\n    IF (schema IS NULL) THEN\r\n        RAISE EXCEPTION 'No json schema available for %', _class_name;\r\n    END IF;\r\n\r\n    IF (_class_uuid IS NULL) THEN\r\n        _class_uuid := (schema->>'GUID')::uuid;\r\n    END IF;\r\n    schema := schema #> '{attributes,schema}';\r\n    IF (NOT(public.validate_json_schema(schema, _attrs))) THEN\r\n        RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n    END IF;\r\n\r\n    SELECT \tv.data\r\n        FROM reclada.v_object v\r\n\t        WHERE v.obj_id = _obj_id\r\n                AND v.class_name = _class_name \r\n\t    INTO old_obj;\r\n\r\n    IF (old_obj IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not update object, no such id';\r\n    END IF;\r\n\r\n    branch := _data->'branch';\r\n    SELECT reclada_revision.create(user_info->>'sub', branch, _obj_id) \r\n        INTO revid;\r\n\r\n    SELECT prnt_guid, prnt_field\r\n    FROM reclada_object.get_parent_guid(_data,_class_name)\r\n        INTO _parent_guid,\r\n            _parent_field;\r\n\r\n    IF (_parent_guid IS NULL) THEN\r\n        _parent_guid := old_obj->>'parentGUID';\r\n    END IF;\r\n    \r\n    IF EXISTS (\r\n        SELECT 1\r\n        FROM reclada.v_object_unifields\r\n        WHERE class_uuid=_class_uuid\r\n    )\r\n    THEN\r\n        SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg(DISTINCT obj_guid::text, ',')\r\n        FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)\r\n        GROUP BY dup_behavior\r\n            INTO _cnt, _dup_behavior, _guid_list;\r\n        IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n            RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n        END IF;\r\n        FOR _obj_guid, _dup_behavior, _uni_field IN (\r\n                SELECT obj_guid, dup_behavior, dup_field\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)\r\n            ) LOOP\r\n            IF _dup_behavior IN ('Update','Merge') THEN\r\n                UPDATE reclada.object o\r\n                    SET status = reclada_object.get_archive_status_obj_id()\r\n                WHERE o.GUID = _obj_guid\r\n                    AND status != reclada_object.get_archive_status_obj_id();\r\n            END IF;\r\n            CASE _dup_behavior\r\n                WHEN 'Replace' THEN\r\n                    PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                WHEN 'Update' THEN                    \r\n                    _data := reclada_object.remove_parent_guid(_data, _parent_field);\r\n                    _data := reclada_object.update_json_by_guid(_obj_guid, _data);\r\n                    RETURN reclada_object.update(_data);\r\n                WHEN 'Reject' THEN\r\n                    RAISE EXCEPTION 'Duplicate found (GUID: %). Object rejected.', _obj_guid;\r\n                WHEN 'Copy'    THEN\r\n                    _attrs = _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                    IF (NOT(public.validate_json_schema(schema, _attrs))) THEN\r\n                        RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n                    END IF;\r\n                WHEN 'Insert' THEN\r\n                    -- DO nothing\r\n                WHEN 'Merge' THEN                    \r\n                    RETURN reclada_object.update(\r\n                        reclada_object.merge(\r\n                            _data - 'class', \r\n                            vao.data, \r\n                            schema\r\n                        ) || format('{"GUID": "%s"}', _obj_guid)::jsonb\r\n                    )\r\n                        FROM reclada.v_active_object vao\r\n                            WHERE obj_id = _obj_guid;\r\n            END CASE;\r\n        END LOOP;\r\n    END IF;\r\n\r\n    with t as \r\n    (\r\n        update reclada.object o\r\n            set status = reclada_object.get_archive_status_obj_id()\r\n                where o.GUID = _obj_id\r\n                    and status != reclada_object.get_archive_status_obj_id()\r\n                        RETURNING id\r\n    )\r\n    INSERT INTO reclada.object( GUID,\r\n                                class,\r\n                                status,\r\n                                attributes,\r\n                                transaction_id,\r\n                                parent_guid\r\n                              )\r\n        select  v.obj_id,\r\n                _class_uuid,\r\n                reclada_object.get_active_status_obj_id(),--status \r\n                _attrs || format('{"revision":"%s"}',revid)::jsonb,\r\n                transaction_id,\r\n                _parent_guid\r\n            FROM reclada.v_object v\r\n            JOIN \r\n            (   \r\n                select id \r\n                    FROM \r\n                    (\r\n                        select id, 1 as q\r\n                            from t\r\n                        union \r\n                        select id, 2 as q\r\n                            from reclada.object ro\r\n                                where ro.guid = _obj_id\r\n                                    ORDER BY ID DESC \r\n                                        LIMIT 1\r\n                    ) ta\r\n                    ORDER BY q ASC \r\n                        LIMIT 1\r\n            ) as tt\r\n                on tt.id = v.id\r\n\t            WHERE v.obj_id = _obj_id;\r\n\r\n    PERFORM reclada.update_unique_object(ARRAY[_obj_id]);\r\n\r\n    PERFORM reclada_object.datasource_insert\r\n            (\r\n                _class_name,\r\n                _obj_id,\r\n                _attrs\r\n            );\r\n    PERFORM reclada_object.refresh_mv(_class_name);\r\n\r\n    IF ( _class_name = 'jsonschema' AND jsonb_typeof(_attrs->'dupChecking') = 'array') THEN\r\n        PERFORM reclada_object.refresh_mv('uniFields');\r\n    END IF; \r\n                  \r\n    select v.data \r\n        FROM reclada.v_active_object v\r\n            WHERE v.obj_id = _obj_id\r\n        into _data;\r\n    PERFORM reclada_notification.send_object_notification('update', _data);\r\n    RETURN _data;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    _data         jsonb;\r\n    new_data      jsonb;\r\n    _class_name    text;\r\n    _class_uuid   uuid;\r\n    tran_id       bigint;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    _obj_guid     uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    inserted      uuid[];\r\n    inserted_from_draft uuid[];\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _is_cascade   boolean;\r\n    _uni_field    text;\r\n    _parent_guid  uuid;\r\n    _parent_field   text;\r\n    skip_insert     boolean;\r\n    notify_res      jsonb;\r\n    _cnt             int;\r\n    _new_parent_guid       uuid;\r\n    _rel_type       text := 'GUID changed for dupBehavior';\r\n    _guid_list      text;\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n    /*TODO: check if some objects have revision AND others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    FOR _data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n        skip_insert := false;\r\n        _class_name := _data->>'class';\r\n\r\n        IF (_class_name IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object class is not specified';\r\n        END IF;\r\n        _class_uuid := reclada.try_cast_uuid(_class_name);\r\n\r\n        _attrs := _data->'attributes';\r\n        IF (_attrs IS NULL) THEN\r\n            RAISE EXCEPTION 'The reclada object must have attributes';\r\n        END IF;\r\n\r\n        tran_id := (_data->>'transactionID')::bigint;\r\n        IF tran_id IS NULL THEN\r\n            tran_id := reclada.get_transaction_id();\r\n        END IF;\r\n\r\n        IF _class_uuid IS NULL THEN\r\n            SELECT reclada_object.get_schema(_class_name) \r\n            INTO schema;\r\n            _class_uuid := (schema->>'GUID')::uuid;\r\n        ELSE\r\n            SELECT v.data, v.for_class\r\n            FROM reclada.v_class v\r\n            WHERE _class_uuid = v.obj_id\r\n            INTO schema, _class_name;\r\n        END IF;\r\n        IF (schema IS NULL) THEN\r\n            RAISE EXCEPTION 'No json schema available for %', _class_name;\r\n        END IF;\r\n\r\n        IF (NOT(public.validate_json_schema(schema->'attributes'->'schema', _attrs))) THEN\r\n            RAISE EXCEPTION 'JSON invalid: \r\n                %, \r\n                schema: \r\n                %', \r\n                _attrs,\r\n                schema#>>'{attributes,schema}';\r\n        END IF;\r\n        \r\n        IF _data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        SELECT prnt_guid, prnt_field\r\n        FROM reclada_object.get_parent_guid(_data,_class_name)\r\n            INTO _parent_guid,\r\n                _parent_field;\r\n        _obj_guid := _data->>'GUID';\r\n\r\n        IF (_parent_guid IS NOT NULL) THEN\r\n            SELECT\r\n                attrs->>'object',\r\n                attrs->>'dupBehavior',\r\n                attrs->>'isCascade'\r\n            FROM reclada.v_active_object\r\n            WHERE class_name = 'Relationship'\r\n                AND attrs->>'type'                      = _rel_type\r\n                AND (attrs->>'subject')::uuid  = _parent_guid\r\n                    INTO _new_parent_guid, _dup_behavior, _is_cascade;\r\n\r\n            IF _new_parent_guid IS NOT NULL THEN\r\n                _parent_guid := _new_parent_guid;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.v_object_unifields\r\n            WHERE class_uuid = _class_uuid\r\n        )\r\n        THEN\r\n            IF (_parent_guid IS NOT NULL) THEN\r\n                IF (_dup_behavior = 'Update' AND _is_cascade) THEN\r\n                    SELECT count(DISTINCT obj_guid), string_agg(DISTINCT obj_guid::text, ',')\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                        INTO _cnt, _guid_list;\r\n                    IF (_cnt >1) THEN\r\n                        RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                    ELSIF (_cnt = 1) THEN\r\n                        SELECT DISTINCT obj_guid, is_cascade\r\n                        FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                            INTO _obj_guid, _is_cascade;\r\n                        new_data := _data;\r\n                        IF new_data->>'GUID' IS NOT NULL THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                        END IF;\r\n                        new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                        new_data = reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                        SELECT reclada_object.update(new_data)\r\n                            INTO res;\r\n                        affected := array_append( affected, _obj_guid);\r\n                        skip_insert := true;\r\n                    END IF;\r\n                END IF;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM reclada.v_active_object\r\n                    WHERE obj_id = _parent_guid\r\n                )\r\n                    AND _new_parent_guid IS NULL\r\n                THEN\r\n                    IF (_obj_guid IS NULL) THEN\r\n                        RAISE EXCEPTION 'GUID is required.';\r\n                    END IF;\r\n                    INSERT INTO reclada.draft(guid, parent_guid, data)\r\n                        VALUES(_obj_guid, _parent_guid, _data);\r\n                    skip_insert := true;\r\n                END IF;\r\n            END IF;\r\n\r\n            IF (NOT skip_insert) THEN\r\n                SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg (DISTINCT obj_guid::text, ',')\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                GROUP BY dup_behavior\r\n                    INTO _cnt, _dup_behavior, _guid_list;\r\n                IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n                    RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                END IF;\r\n                FOR _obj_guid, _dup_behavior, _is_cascade, _uni_field IN\r\n                    SELECT obj_guid, dup_behavior, is_cascade, dup_field\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                LOOP\r\n                    new_data := _data;\r\n                    CASE _dup_behavior\r\n                        WHEN 'Replace' THEN\r\n                            IF (_is_cascade = true) THEN\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', a)::jsonb)\r\n                                FROM reclada.get_children(_obj_guid) a;\r\n                            ELSE\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                            END IF;\r\n                        WHEN 'Update' THEN\r\n                            IF new_data->>'GUID' IS NOT NULL THEN\r\n                                PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                            END IF;\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            new_data := reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                            SELECT reclada_object.update(new_data)\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                        WHEN 'Reject' THEN\r\n                            RAISE EXCEPTION 'The object was rejected.';\r\n                        WHEN 'Copy'    THEN\r\n                            _attrs := _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                        WHEN 'Insert' THEN\r\n                            -- DO nothing\r\n                        WHEN 'Merge' THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                _rel_type,\r\n                                _obj_guid,\r\n                                (new_data->>'GUID')::uuid,\r\n                                '{"dupBehavior": "Merge"}'::jsonb);\r\n                            SELECT reclada_object.update(reclada_object.merge(new_data - 'class', data,schema->'attributes'->'schema') || format('{"GUID": "%s"}', _obj_guid)::jsonb || format('{"transactionID": %s}', tran_id)::jsonb)\r\n                            FROM reclada.v_active_object\r\n                            WHERE obj_id = _obj_guid\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                    END CASE;\r\n                END LOOP;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF (NOT skip_insert) THEN\r\n            _obj_guid := (_data->>'GUID')::uuid;\r\n            IF EXISTS (\r\n                SELECT 1\r\n                FROM reclada.object \r\n                WHERE GUID = _obj_guid\r\n            ) THEN\r\n                RAISE EXCEPTION 'GUID: % is duplicate', _obj_guid;\r\n            END IF;\r\n            --raise notice 'schema: %',schema;\r\n\r\n            INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n                SELECT  CASE\r\n                            WHEN _obj_guid IS NULL\r\n                                THEN public.uuid_generate_v4()\r\n                            ELSE _obj_guid\r\n                        END AS GUID,\r\n                        _class_uuid, \r\n                        _attrs,\r\n                        tran_id,\r\n                        _parent_guid\r\n            RETURNING GUID INTO _obj_guid;\r\n            affected := array_append( affected, _obj_guid);\r\n            inserted := array_append( inserted, _obj_guid);\r\n            PERFORM reclada_object.datasource_insert\r\n                (\r\n                    _class_name,\r\n                    _obj_guid,\r\n                    _attrs\r\n                );\r\n\r\n            PERFORM reclada_object.refresh_mv(_class_name);\r\n        END IF;\r\n    END LOOP;\r\n\r\n    SELECT array_agg(_affected_objects->>'GUID')\r\n    FROM (\r\n        SELECT jsonb_array_elements(_affected_objects) AS _affected_objects\r\n        FROM (\r\n            SELECT reclada_object.create(data) AS _affected_objects\r\n            FROM reclada.draft\r\n            WHERE parent_guid = ANY (affected)\r\n        ) a\r\n    ) b\r\n    WHERE _affected_objects->>'GUID' IS NOT NULL\r\n        INTO inserted_from_draft;\r\n    affected := affected || inserted_from_draft;    \r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb;\r\n    notify_res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (inserted)\r\n                )\r\n            )::jsonb; \r\n    \r\n    DELETE FROM reclada.draft \r\n        WHERE guid = ANY (affected);\r\n\r\n    PERFORM reclada.update_unique_object(affected);\r\n        \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            notify_res\r\n        );\r\n    RETURN res;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false, ver text DEFAULT '1'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    _class              text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    _exec_text           text;\r\n    _pre_query           text;\r\n    _from               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\n    _object_display     JSONB;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    if ver = '1' then\r\n        tran_id := (data->>'transactionID')::bigint;\r\n        _class := data->>'class';\r\n    elseif ver = '2' then\r\n        tran_id := (data->>'{transactionID}')::bigint;\r\n        _class := data->>'{class}';\r\n    end if;\r\n    _filter = data->'filter';\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(\r\n            E'obj.data#>''{%s}'' %s', \r\n            case ver\r\n                when '2'\r\n                    then REPLACE(REPLACE(T.value->>'field','{', '"{' ),'}', '}"' )\r\n                else\r\n                    T.value->>'field'\r\n            end,\r\n            COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    \r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSEIF ver = '1' then\r\n        class_uuid := reclada.try_cast_uuid(_class);\r\n\r\n        IF (class_uuid IS NULL) THEN\r\n            SELECT v.obj_id\r\n                FROM reclada.v_class v\r\n                    WHERE _class = v.for_class\r\n                    ORDER BY v.version DESC\r\n                    limit 1 \r\n            INTO class_uuid;\r\n            IF (class_uuid IS NULL) THEN\r\n                perform reclada.raise_exception(\r\n                        format('Class not found: %s', _class),\r\n                        _f_name\r\n                    );\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', _class) AS condition\r\n                        where _class is not null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                            and _class is null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    -- TODO: add ELSE\r\n    IF ver = '2' THEN\r\n        _pre_query := (select val from reclada.v_ui_active_object);\r\n        _from := 'res AS obj';\r\n        _pre_query := REPLACE(_pre_query,'#@#@#where#@#@#', query_conditions  );\r\n\r\n    ELSE\r\n        _pre_query := '';\r\n        _from := 'reclada.v_active_object AS obj\r\n                            WHERE #@#@#where#@#@#';\r\n        _from := REPLACE(_from, '#@#@#where#@#@#', query_conditions  );\r\n    END IF;\r\n    _exec_text := _pre_query ||\r\n                'SELECT to_jsonb(array_agg(t.data))\r\n                    FROM \r\n                    (\r\n                        SELECT obj.data\r\n                            FROM '\r\n                            || _from\r\n                            || ' \r\n                            ORDER BY #@#@#orderby#@#@#'\r\n                            || case \r\n                                when ver = '2' \r\n                                    then ''\r\n                                else\r\n                                '\r\n                                OFFSET #@#@#offset#@#@#\r\n                                LIMIT #@#@#limit#@#@#'\r\n                            end\r\n                            || '\r\n                    ) AS t';\r\n    _exec_text := REPLACE(_exec_text, '#@#@#orderby#@#@#'  , order_by          );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#offset#@#@#'   , offset_           );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#limit#@#@#'    , limit_            );\r\n    -- RAISE NOTICE 'conds: %', _exec_text;\r\n    EXECUTE _exec_text\r\n        INTO objects;\r\n    objects := coalesce(objects,'[]'::jsonb);\r\n    IF gui THEN\r\n\r\n        if ver = '2' then\r\n            class_uuid := coalesce(class_uuid, (objects#>>'{0,"{class}"}')::uuid);\r\n            if class_uuid is not null then\r\n                _class :=   (\r\n                                select cl.for_class \r\n                                    from reclada.v_class_lite cl\r\n                                        where class_uuid = cl.obj_id\r\n                                            limit 1\r\n                            );\r\n\r\n                _exec_text := '\r\n                with \r\n                d as ( \r\n                    select id_unique_object\r\n                        FROM reclada.v_active_object obj \r\n                        JOIN reclada.unique_object_reclada_object as uoc\r\n                            on uoc.id_reclada_object = obj.id\r\n                                and #@#@#where#@#@#\r\n                        group by id_unique_object\r\n                ),\r\n                dd as (\r\n                    select distinct \r\n                            ''{''||f.path||''}:''||f.json_type v,\r\n                            f.json_type\r\n                        FROM d \r\n                        JOIN reclada.unique_object as uo\r\n                            on d.id_unique_object = uo.id\r\n                        JOIN reclada.field f\r\n                            on f.id = ANY (uo.id_field)\r\n                        UNION\r\n                    SELECT pattern||'':''||CASE WHEN pattern=''transactionID'' THEN ''number'' ELSE ''string'' END,\r\n                        CASE WHEN pattern=''transactionID'' THEN ''number'' ELSE ''string'' END \r\n                    FROM reclada.v_filter_mapping vfm\r\n                ),\r\n                on_data as \r\n                (\r\n                    select  jsonb_object_agg(\r\n                                t.v, \r\n                                replace(dd.template,''#@#attrname#@#'',t.v)::jsonb \r\n                            ) t\r\n                        from dd as t\r\n                        JOIN reclada.v_default_display dd\r\n                            on t.json_type = dd.json_type\r\n                )\r\n                select jsonb_set(templ.v,''{table}'', od.t || coalesce(d.table,coalesce(d.table,templ.v->''table'')))\r\n                    from on_data od\r\n                    join (\r\n                        select replace(template,''#@#classname#@#'','''|| _class ||''')::jsonb v\r\n                            from reclada.v_default_display \r\n                                where json_type = ''ObjectDisplay''\r\n                                    limit 1\r\n                    ) templ\r\n                        on true\r\n                    left join reclada.v_object_display d\r\n                        on d.class_guid::text = '''|| coalesce( class_uuid::text, '' ) ||'''';\r\n\r\n                _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );\r\n                -- raise notice '%',_exec_text;\r\n                EXECUTE _exec_text\r\n                    INTO _object_display;\r\n            end if;\r\n        end if;\r\n\r\n        _exec_text := '\r\n            SELECT  COUNT(1),\r\n                    TO_CHAR(\r\n                        MAX(\r\n                            GREATEST(\r\n                                obj.created_time, \r\n                                (\r\n                                    SELECT  TO_TIMESTAMP(\r\n                                                MAX(date_time),\r\n                                                ''YYYY-MM-DD hh24:mi:ss.US TZH''\r\n                                            )\r\n                                        FROM reclada.v_revision vr\r\n                                            WHERE vr.obj_id = UUID(obj.attrs ->>''revision'')\r\n                                )\r\n                            )\r\n                        ),\r\n                        ''YYYY-MM-DD hh24:mi:ss.MS TZH''\r\n                    )\r\n                    FROM reclada.v_active_object obj \r\n                        where #@#@#where#@#@#';\r\n\r\n        _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );\r\n        raise notice '%',_exec_text;\r\n        EXECUTE _exec_text\r\n            INTO number_of_objects, last_change;\r\n        \r\n        IF _object_display IS NOT NULL then\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects,\r\n                    'display', _object_display\r\n                );\r\n        ELSE\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects\r\n            );\r\n        end if;\r\n    ELSE\r\n        \r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada.validate_json_schema ;\n\nDROP function IF EXISTS reclada.get_validation_schema ;\n\nDROP function IF EXISTS reclada_object.get_schema ;\nCREATE OR REPLACE FUNCTION reclada_object.get_schema(_class text)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT data\r\n    FROM reclada.v_class_lite v\r\n    JOIN reclada.v_active_object vao ON v.id=vao.id\r\n    WHERE v.for_class = _class\r\n    ORDER BY v.version DESC\r\n    LIMIT 1\r\n$function$\n;\n\n--} REC-562\n\n--{ REC-564\ndrop table dev.component;\ndrop table dev.component_object;\nDROP function IF EXISTS reclada_object.datasource_insert ;\nCREATE OR REPLACE FUNCTION reclada_object.datasource_insert(_class_name text, _obj_id uuid, attributes jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n\r\n    _pipeline_lite jsonb;\r\n    _task  jsonb;\r\n    _dataset_guid  uuid;\r\n    _new_guid  uuid;\r\n    _pipeline_job_guid  uuid;\r\n    _stage         text;\r\n    _uri           text;\r\n    _dataset2ds_type text = 'defaultDataSet to DataSource';\r\n    _f_name text = 'reclada_object.datasource_insert';\r\nBEGIN\r\n    IF _class_name in ('DataSource','File') THEN\r\n\r\n        _uri := attributes->>'uri';\r\n\r\n        SELECT v.obj_id\r\n            FROM reclada.v_active_object v\r\n            WHERE v.class_name = 'DataSet'\r\n                and v.attrs->>'name' = 'defaultDataSet'\r\n            INTO _dataset_guid;\r\n\r\n        IF (_dataset_guid IS NULL) THEN\r\n            RAISE EXCEPTION 'Can''t found defaultDataSet';\r\n        END IF;\r\n        PERFORM reclada_object.create_relationship(_dataset2ds_type, _obj_id, _dataset_guid);\r\n        IF _uri LIKE '%inbox/jobs/%' THEN\r\n            PERFORM reclada_object.create_job(_uri, _obj_id);\r\n        ELSE\r\n            \r\n            SELECT data \r\n                FROM reclada.v_active_object\r\n                    WHERE class_name = 'PipelineLite'\r\n                        LIMIT 1\r\n                INTO _pipeline_lite;\r\n            _new_guid := public.uuid_generate_v4();\r\n            IF _uri LIKE '%inbox/pipelines/%/%' THEN\r\n                \r\n                _stage := SPLIT_PART(\r\n                                SPLIT_PART(_uri,'inbox/pipelines/',2),\r\n                                '/',\r\n                                2\r\n                            );\r\n                _stage = replace(_stage,'.json','');\r\n                SELECT data \r\n                    FROM reclada.v_active_object o\r\n                        where o.class_name = 'Task'\r\n                            and o.obj_id = (_pipeline_lite #>> ('{attributes,tasks,'||_stage||'}')::text[])::uuid\r\n                    into _task;\r\n                \r\n                _pipeline_job_guid = reclada.try_cast_uuid(\r\n                                        SPLIT_PART(\r\n                                            SPLIT_PART(_uri,'inbox/pipelines/',2),\r\n                                            '/',\r\n                                            1\r\n                                        )\r\n                                    );\r\n                IF _pipeline_job_guid IS NULL THEN\r\n                    perform reclada.raise_exception('PIPELINE_JOB_GUID not found',_f_name);\r\n                END IF;\r\n                \r\n                SELECT  data #>> '{attributes,inputParameters,0,uri}',\r\n                        (data #>> '{attributes,inputParameters,1,dataSourceId}')::uuid\r\n                    FROM reclada.v_active_object o\r\n                        WHERE o.obj_id = _pipeline_job_guid\r\n                    INTO _uri, _obj_id;\r\n\r\n            ELSE\r\n                SELECT data \r\n                    FROM reclada.v_active_object o\r\n                        WHERE o.class_name = 'Task'\r\n                            AND o.obj_id = (_pipeline_lite #>> '{attributes,tasks,0}')::uuid\r\n                    INTO _task;\r\n                IF _task IS NOT NULL THEN\r\n                    _pipeline_job_guid := _new_guid;\r\n                END IF;\r\n            END IF;\r\n            \r\n            PERFORM reclada_object.create_job(\r\n                _uri,\r\n                _obj_id,\r\n                _new_guid,\r\n                _task->>'GUID',\r\n                _task-> 'attributes' ->>'command',\r\n                _pipeline_job_guid\r\n            );\r\n        END IF;\r\n    END IF;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.object_insert ;\n\nDROP function IF EXISTS reclada_object.delete ;\nCREATE OR REPLACE FUNCTION reclada_object.delete(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_obj_id            uuid;\r\n    tran_id             bigint;\r\n    _class_name         text;\r\n    _class_name_from_uuid   text;\r\n    _class_uuid          uuid;\r\n    list_id             bigint[];\r\n    _for_class           text;\r\n    _uniFields_index_name          text;\r\n    _attrs              jsonb;\r\nBEGIN\r\n\r\n    v_obj_id := data->>'GUID';\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    _class_name := data->>'class';\r\n\r\n    IF (v_obj_id IS NULL AND _class_name IS NULL AND tran_id IS NULl) THEN\r\n        RAISE EXCEPTION 'Could not delete object with no GUID, class and transactionID';\r\n    END IF;\r\n\r\n    _class_uuid := reclada.try_cast_uuid(_class_name);\r\n    IF _class_uuid IS NOT NULL THEN\r\n        SELECT v.for_class \r\n        FROM reclada.v_class_lite v\r\n        WHERE _class_uuid = v.obj_id\r\n            INTO _class_name_from_uuid;\r\n    END IF;\r\n\r\n    WITH t AS\r\n    (    \r\n        UPDATE reclada.object u\r\n            SET status = reclada_object.get_archive_status_obj_id()\r\n            FROM reclada.object o\r\n                LEFT JOIN\r\n                (   SELECT obj_id FROM reclada_object.get_guid_for_class(_class_name)\r\n                    UNION SELECT _class_uuid WHERE _class_uuid IS NOT NULL\r\n                ) c ON o.class = c.obj_id\r\n                WHERE u.id = o.id AND\r\n                (\r\n                    (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                )\r\n                    AND o.status != reclada_object.get_archive_status_obj_id()\r\n                    RETURNING o.id\r\n    ) \r\n        SELECT\r\n            array\r\n            (\r\n                SELECT t.id FROM t\r\n            )\r\n        INTO list_id;\r\n\r\n    SELECT array_to_json\r\n    (\r\n        array\r\n        (\r\n            SELECT o.data\r\n            FROM reclada.v_object o\r\n            WHERE o.id IN (SELECT unnest(list_id))\r\n        )\r\n    )::jsonb\r\n    INTO data;\r\n\r\n    IF (jsonb_array_length(data) <= 1) THEN\r\n        data := data->0;\r\n    END IF;\r\n    \r\n    IF (data IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not delete object, no such GUID';\r\n    END IF;\r\n\r\n    PERFORM reclada_object.refresh_mv(class_name)\r\n    FROM reclada.v_object vo\r\n    WHERE class_name IN ('jsonschema','User','ObjectStatus')\r\n        AND id = ANY(list_id);\r\n\r\n    PERFORM reclada_notification.send_object_notification('delete', data);\r\n\r\n    RETURN data;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS dev.begin_install_component ;\n\nDROP function IF EXISTS dev.finish_install_component ;\n\n--} REC-564\ndrop index if exists reclada.fields_index_;	2022-02-15 05:33:39.415746+00
50	49	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 49 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = 'datasource_insert_trigger') o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nalter table dev.component add parent_component_name text;\n\ncreate table dev.meta_data(\n    id bigint\n        NOT NULL\n        GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1)\n        UNIQUE ,\n    ver bigint,\n    data jsonb\n);\n\ni 'function/reclada_object.list.sql'\n\n\ni 'function/dev.begin_install_component.sql'\ni 'function/dev.finish_install_component.sql'\ni 'function/dev.downgrade_version.sql'\ni 'function/reclada_object.create_subclass.sql'\ni 'function/reclada_object.create_relationship.sql'\ni 'function/dev.downgrade_component.sql'\ni 'function/reclada_object.update.sql'\n\ni 'view/reclada.v_object_display.sql'\ndrop VIEW reclada.v_component_object;\ndrop VIEW reclada.v_component;\ni 'view/reclada.v_component.sql'\ni 'view/reclada.v_component_object.sql'\n\n\nselect reclada_object.create_relationship\n                    (\n                        'data of reclada-component',\n                        db.guid,\n                        o.guid,\n                        '{}'::jsonb,\n                        db.guid\n                    )\n    from reclada.object o\n    cross join (\n        select guid \n            from reclada.v_component \n                where name = 'db' \n                limit 1\n    ) db\n        where \n        (\n            o.class in (select reclada_object.get_GUID_for_class('jsonschema'))\n            and o.attributes->>'forClass' in (  'tag', -- 1\n                                                'DataSource', -- 2\n                                                'S3Config', -- 3\n                                                'DataSet', -- 4\n                                                'Message', -- 5\n                                                'Index', -- 6\n                                                'Component', -- 7\n                                                'Context', -- 8\n                                                'DTOJsonSchema', -- 9\n                                                'File', -- 10\n                                                'User', -- 11\n                                                'ImportInfo', -- 12\n                                                'Asset', -- 13\n                                                'DBAsset', -- 14\n                                                'revision', -- 15\n                                                'ObjectDisplay' -- 16\n                                            )\n                                            \n        ) or (\n            o.class in (select reclada_object.get_GUID_for_class('DataSet'))\n            and o.attributes->>'name' = 'defaultDataSet'\n        ) or (\n            o.class in (select reclada_object.get_GUID_for_class('User'))\n            and o.attributes->>'login' = 'dev'\n        ) or (\n            o.class in (select reclada_object.get_GUID_for_class('DTOJsonSchema'))\n            and o.attributes->>'function' in ('reclada_object.list','reclada_object.get_query_condition_filter')\n        ) or (\n            o.class in (select reclada_object.get_GUID_for_class('ObjectDisplay'))\n        ) or (\n            o.class in (select reclada_object.get_GUID_for_class('Message'))\n            and o.guid not in (\n                            '0a05ffb8-c25d-400d-b3fb-59ac0fcef8a0',\n                            '0a0abcd6-5a7c-4126-8541-ca719622e51f',\n                            '0a01f056-e9c1-4c1f-b7eb-94e34827ff85',\n                            '0a0f2b7d-cb6e-4097-86a9-218ced87f896',\n                            '0a04bcd3-ecb3-4f76-b1aa-5068f38bb303',\n                            '0a0c1e85-ac9a-4d65-8bc8-e0c40f3a6c6c'\n                        )\n        );\n\n\ninsert into dev.meta_data(ver,data)\n    select  49, \n            jsonb_build_object( 'id'     , o.id ,\n                                'tran_id', u.transaction_id\n                            ) as v\n        from reclada.v_component_object o\n        join reclada.object u\n            on u.id = o.id\n        join \n        (\n            SELECT transaction_id ,attrs->>'name' component_name\n                FROM reclada.v_object \n                    where class_name = 'Component' \n        ) t\n            on t.component_name = o.component_name;\n\n\nupdate reclada.object u\n    set transaction_id = t.transaction_id\n    from reclada.v_component_object o\n    join \n    (\n        SELECT transaction_id ,attrs->>'name' component_name\n            FROM reclada.v_object \n                where class_name = 'Component' \n    ) t\n        on t.component_name = o.component_name\n        where u.id = o.id;\n    \n\n\n\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.merge.sql'\ni 'view/reclada.v_object_unifields.sql'\n\nALTER SEQUENCE IF EXISTS reclada.object_id_seq CACHE 10;\n\n-----------\ni 'view/reclada.v_ui_active_object.sql'\ni 'view/reclada.v_component_object.sql'\n\ni 'function/reclada_object.create_job.sql'\ni 'function/api.storage_generate_presigned_post.sql'\ni 'function/dev.begin_install_component.sql'\ni 'function/dev.finish_install_component.sql'\n\n\n SELECT reclada.raise_notice('Begin install component db...');\n                SELECT dev.begin_install_component('db','https://gitlab.reclada.com/developers/db.git','9cfdb8ae15d0dc2b39aceae639a9980b89fcc349');\n                \n-- 1\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "tag",\n        "properties": {\n            "name": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 2\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DataSource",\n        "properties": {\n            "name": {"type": "string"},\n            "uri": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 3\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "S3Config",\n        "properties": {\n            "endpointURL": {"type": "string"},\n            "regionName": {"type": "string"},\n            "accessKeyId": {"type": "string"},\n            "secretAccessKey": {"type": "string"},\n            "bucketName": {"type": "string"}\n            },\n        "required": ["accessKeyId", "secretAccessKey", "bucketName"]\n    }\n}'::jsonb);\n--{ 4 DataSet\nSELECT reclada_object.create_subclass('{\n        "class": "RecladaObject",\n        "attributes": {\n            "newClass": "DataSet",\n            "properties": {\n                "name": {"type": "string"},\n                "dataSources": {\n                    "type": "array",\n                    "items": {"type": "string"}\n                }\n            },\n            "required": ["name"]\n        }\n    }'::jsonb);\n\n        SELECT reclada_object.create('{\n            "GUID":"10c400ff-a328-450d-ae07-ce7d427d961c",\n            "class": "DataSet",\n            "attributes": {\n                "name": "defaultDataSet",\n                "dataSources": []\n            }\n        }'::jsonb);\n--} 4 DataSet\n\n-- 5\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Message",\n        "properties": {\n            "channelName": {"type": "string"},\n            "class": {"type": "string"},\n            "event": {\n                "type": "string",\n                "enum": [\n                    "create",\n                    "update",\n                    "list",\n                    "delete"\n                ]\n            },\n            "attributes": {\n                "type": "array", \n                "items": {"type": "string"}\n            }\n        },\n        "required": ["class", "channelName", "event"]\n    }\n}'::jsonb);\n\n--{ 6 Index\nSELECT reclada_object.create_subclass('{\n            "class": "RecladaObject",\n            "attributes": {\n                "newClass": "Index",\n                "properties": {\n                    "name": {"type": "string"},\n                    "method": {\n                        "type": "string",\n                        "enum ": [\n                            "btree", \n                            "hash" , \n                            "gist" , \n                            "gin"\n                        ]\n                    },\n                    "wherePredicate": {\n                        "type": "string"\n                    },\n                    "fields": {\n                        "items": {\n                            "type": "string"\n                        },\n                        "type": "array",\n                        "minContains": 1\n                    }\n                },\n                "required": ["name","fields"]\n            }\n        }'::jsonb);\n\n    select reclada_object.create('{\n            "GUID": "db0873d1-786f-4d5d-b790-5c3b3cd29baf",\n            "class": "Index",\n            "attributes": {\n                "name": "checksum_index_",\n                "fields": ["(attributes ->> ''checksum''::text)"],\n                "method": "hash",\n                "wherePredicate": "((attributes ->> ''checksum''::text) IS NOT NULL)"\n            }\n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db08d53b-c423-4e94-8b14-e73ebe98e991",\n            "class": "Index",\n            "attributes": {\n                "name": "repository_index_",\n                "fields": ["(attributes ->> ''repository''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''repository''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n        "GUID": "db05e253-7954-4610-b094-8f9925ea77b4",\n        "class": "Index",\n        "attributes": {\n                "name": "commithash_index_",\n                "fields": ["(attributes ->> ''commitHash''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''commitHash''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n        "GUID": "db02f980-cd5a-4c1a-9341-7a81713cd9d0",\n        "class": "Index",\n        "attributes": {\n                "name": "fields_index_",\n                "fields": ["(attributes ->> ''fields''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''fields''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0e400b-1da4-4823-bb80-15eb144a1639",\n            "class": "Index",\n            "attributes": {\n                    "name": "caption_index_",\n                    "fields": ["(attributes ->> ''caption''::text)"],\n                    "method": "btree",\n                    "wherePredicate": "((attributes ->> ''caption''::text) IS NOT NULL)"\n                }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db09fafb-91b1-4fe6-8e5c-1cd2d7d9225a",\n            "class": "Index",\n            "attributes": {\n                "name": "type_index",\n                "fields": ["(attributes ->> ''type''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''type''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0118e5-ea34-45dc-b72c-f16f6a628ddb",\n            "class": "Index",\n            "attributes": {\n                "name": "schema_index_",\n                "fields": ["(attributes ->> ''schema''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''schema''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db07c919-5bc0-4fec-961c-f558401d3e71",\n            "class": "Index",\n            "attributes": {\n                "name": "forclass_index_",\n                "fields": ["(attributes ->> ''forclass''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''forclass''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0184b8-556e-4f57-af12-d84066adbe31",\n            "class": "Index",\n            "attributes": {\n                "name": "revision_index",\n                "fields": ["(attributes ->> ''revision''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''revision''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0e22c0-e0d7-4b11-bf25-367a8fbdef83",\n            "class": "Index",\n            "attributes": {\n                "name": "subject_index_",\n                "fields": ["(attributes ->> ''subject''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''subject''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db05c9c7-17ce-4b36-89d7-81b0ddd26a6a",\n            "class": "Index",\n            "attributes": {\n                "name": "class_index_",\n                "fields": ["(attributes ->> ''class''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''class''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0a88c1-ac00-42e5-9caa-6007a1c948c6",\n            "class": "Index",\n                "attributes": {\n                "name": "name_index_",\n                "fields": ["(attributes ->> ''name''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''name''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0fdc46-6479-4d20-bd21-a6330905e45b",\n            "class": "Index",\n            "attributes": {\n                "name": "event_index_",\n                "fields": ["(attributes ->> ''event''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''event''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db02b45a-acfd-4448-a51a-8e7dc35bf3af",\n            "class": "Index",\n            "attributes": {\n                "name": "function_index_",\n                "fields": ["(attributes ->> ''function''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''function''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0b797a-b287-4282-b0f8-d985c7a439f4",\n            "class": "Index",\n            "attributes": {\n                "name": "login_index_",\n                "fields": ["(attributes ->> ''login''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''login''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db03c715-c0f9-43c3-940a-803aafa513e0",\n            "class": "Index",\n            "attributes": {\n                "name": "object_index_",\n                "fields": ["(attributes ->> ''object''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''object''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n\n--} 6 Index\n\n-- 7\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Component",\n        "properties": {\n            "name": {"type": "string"},\n            "commitHash": {"type": "string"},\n            "repository": {"type": "string"}\n        },\n        "required": ["name","commitHash","repository"]\n    }\n}'::jsonb);\n\n--{ 9 DTOJsonSchema\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DTOJsonSchema",\n        "properties": {\n            "schema": {"type": "object"},\n            "function": {"type": "string"}\n        },\n        "required": ["schema","function"]\n    }\n}'::jsonb);\n\n    SELECT reclada_object.create('{\n            "GUID":"db0bf6f5-7eea-4dbd-9f46-e0535f7fb299",\n            "class": "DTOJsonSchema",\n            "attributes": {\n                "function": "reclada_object.get_query_condition_filter",\n                "schema": {\n                    "id": "expr",\n                    "type": "object",\n                    "required": [\n                        "value",\n                        "operator"\n                    ],\n                    "properties": {\n                        "value": {\n                            "type": "array",\n                            "items": {\n                                "anyOf": [\n                                    {\n                                        "type": "string"\n                                    },\n                                    {\n                                        "type": "null"\n                                    },\n                                    {\n                                        "type": "number"\n                                    },\n                                    {\n                                        "$ref": "expr"\n                                    },\n                                    {\n                                        "type": "boolean"\n                                    },\n                                    {\n                                        "type": "array",\n                                        "items": {\n                                            "anyOf": [\n                                                {\n                                                    "type": "string"\n                                                },\n                                                {\n                                                    "type": "number"\n                                                }\n                                            ]\n                                        }\n                                    }\n                                ]\n                            },\n                            "minItems": 1\n                        },\n                        "operator": {\n                            "type": "string"\n                        }\n                    }\n                }\n            }\n        }'::jsonb);\n\n     SELECT reclada_object.create('{\n            "GUID":"db0ad26e-a522-4907-a41a-a82a916fdcf9",\n            "class": "DTOJsonSchema",\n            "attributes": {\n                "function": "reclada_object.list",\n                "schema": {\n                    "type": "object",\n                    "anyOf": [\n                        {\n                            "required": [\n                                "transactionID"\n                            ]\n                        },\n                        {\n                            "required": [\n                                "class"\n                            ]\n                        },\n                        {\n                            "required": [\n                                "filter"\n                            ]\n                        }\n                    ],\n                    "properties": {\n                        "class": {\n                            "type": "string"\n                        },\n                        "limit": {\n                            "anyOf": [\n                                {\n                                    "enum": [\n                                        "ALL"\n                                    ],\n                                    "type": "string"\n                                },\n                                {\n                                    "type": "integer"\n                                }\n                            ]\n                        },\n                        "filter": {\n                            "type": "object"\n                        },\n                        "offset": {\n                            "type": "integer"\n                        },\n                        "orderBy": {\n                            "type": "array",\n                            "items": {\n                                "type": "object",\n                                "required": [\n                                    "field"\n                                ],\n                                "properties": {\n                                    "field": {\n                                        "type": "string"\n                                    },\n                                    "order": {\n                                        "enum": [\n                                            "ASC",\n                                            "DESC"\n                                        ],\n                                        "type": "string"\n                                    }\n                                }\n                            }\n                        },\n                        "transactionID": {\n                            "type": "integer"\n                        }\n                    }\n                }\n            }\n            \n        }'::jsonb);\n--} 9 DTOJsonSchema\n\n-- 10\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n\n        "dupBehavior": "Replace",\n        "dupChecking": [\n            {\n                "isMandatory": true,\n                "uniFields": [\n                    "uri"\n                ]\n            },\n            {\n                "isMandatory": true,\n                "uniFields": [\n                    "checksum"\n                ]\n            }\n        ],\n        "isCascade": true,\n\n        "newClass": "File",\n        "properties": {\n            "uri": {"type": "string"},\n            "name": {"type": "string"},\n            "mimeType": {"type": "string"},\n            "checksum": {"type": "string"}\n        },\n        "required": ["uri","mimeType","name"]\n    }\n}'::jsonb);\n\n--{ 11 User\nSELECT reclada_object.create_subclass('{\n    "GUID":"db0db7c0-9b25-4af0-8013-d2d98460cfff",\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "User",\n        "properties": {\n            "login": {"type": "string"}\n        },\n        "required": ["login"]\n    }\n}'::jsonb);\n\n    select reclada_object.create('{\n            "GUID": "db0789c1-1b4e-4815-b70c-4ef060e90884",\n            "class": "User",\n            "attributes": {\n                "login": "dev"\n            }\n        }'::jsonb);\n--} 11 User\n\n-- 12\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "ImportInfo",\n        "properties": {\n            "tranID": {"type": "number"},\n            "name": {"type": "string"}\n        },\n        "required": ["tranID","name"]\n    }\n}'::jsonb);\n-- 13\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Asset",\n        "properties": {\n            "name": {"type": "string"},\n            "uri": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 14\nSELECT reclada_object.create_subclass('{\n    "class": "Asset",\n    "attributes": {\n        "newClass": "DBAsset"\n    }\n}'::jsonb);\n-- 15\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "revision",\n        "properties": {\n            "branch": {"type": "string"},\n            "user": {"type": "string"},\n            "num": {"type": "number"},\n            "dateTime": {"type": "string"}\n        },\n        "required": ["dateTime"]\n    }\n}'::jsonb);\n\n--{ 16 ObjectDisplay\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "ObjectDisplay",\n        "$defs": {\n            "displayType": {\n                "properties": {\n                    "orderColumn": {\n                        "items": {\n                            "type": "string"\n                        },\n                        "type": "array"\n                    },\n                    "orderRow": {\n                        "items": {\n                            "patternProperties": {\n                                "^{.*}$": {\n                                    "enum": [\n                                        "ASC",\n                                        "DESC"\n                                    ],\n                                    "type": "string"\n                                }\n                            },\n                            "type": "object"\n                        },\n                        "type": "array"\n                    }\n                },\n                "required": [\n                    "orderColumn",\n                    "orderRow"\n                ],\n                "type": "object"\n            }\n        },\n        "properties": {\n            "caption": {\n                "type": "string"\n            },\n            "card": {\n                "$ref": "#/$defs/displayType"\n            },\n            "classGUID": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "flat": {\n                "type": "bool"\n            },\n            "list": {\n                "$ref": "#/$defs/displayType"\n            },\n            "preview": {\n                "$ref": "#/$defs/displayType"\n            },\n            "table": {\n                "$ref": "#/$defs/displayType"\n            }\n        },\n        "required": [\n            "classGUID",\n            "caption"\n        ]\n    }\n}'::jsonb);\n\n    SELECT reclada_object.create(('{\n        "GUID": "db09dd42-f2a2-4e34-90ea-a6e5f5ea6dff",\n        "class": "ObjectDisplay",\n        "attributes": {\n            "card": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "list": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "table": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ],\n                "{GUID}:string": {\n                    "width": 250,\n                    "caption": "GUID",\n                    "displayCSS": "GUID"\n                },\n                "{status}:string": {\n                    "width": 250,\n                    "caption": "Status",\n                    "displayCSS": "status"\n                },\n                "{createdTime}:string": {\n                    "width": 250,\n                    "caption": "Created time",\n                    "displayCSS": "createdTime"\n                },\n                "{transactionID}:number": {\n                    "width": 250,\n                    "caption": "Transaction",\n                    "displayCSS": "transactionID"\n                },\n                "{attributes,tags}:array": {\n                    "items": {\n                        "class": "e12e729b-ac44-45bc-8271-9f0c6d4fa27b",\n                        "behavior": "preview",\n                        "displayCSS": "link"\n                    },\n                    "width": 250,\n                    "caption": "Tags",\n                    "displayCSS": "arrayLink"\n                },\n                "{attributes,name}:string": {\n                    "width": 250,\n                    "caption": "File name",\n                    "behavior": "preview",\n                    "displayCSS": "name"\n                },\n                "{attributes,checksum}:string": {\n                    "width": 250,\n                    "caption": "Checksum",\n                    "displayCSS": "checksum"\n                },\n                "{attributes,mimeType}:string": {\n                    "width": 250,\n                    "caption": "Mime type",\n                    "displayCSS": "mimeType"\n                }\n            },\n            "caption": "Files",\n            "preview": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "classGUID": "'|| (SELECT obj_id\n                                FROM reclada.v_class\n                                    WHERE for_class = 'File'\n                                    ORDER BY ID DESC\n                                    LIMIT 1 ) ||'"\n        }\n    }')::jsonb);\n\n--} 16 ObjectDisplay\n\n\n                SELECT dev.finish_install_component();\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, current version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nalter table dev.component drop column parent_component_name;\nDROP function IF EXISTS dev.finish_install_component ;\nCREATE OR REPLACE FUNCTION dev.finish_install_component()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name   text := 'dev.finish_install_component';\r\n    _obj      jsonb;\r\n    _data     jsonb;\r\nBEGIN\r\n    perform reclada.raise_exception('Component does not found.',_f_name)\r\n        where not exists(select 1 from dev.component);\r\n    \r\n    select ('{\r\n                "GUID": "' || guid::text || '",\r\n                "class":"Component",\r\n                "attributes": {\r\n                    "name":"' || name || '",\r\n                    "repository":"' || repository || '",\r\n                    "commitHash":"' || commit_hash  || '"\r\n                }\r\n            }')::jsonb\r\n        from dev.component\r\n        into _obj;\r\n\r\n    delete from dev.component;\r\n\r\n    if exists\r\n    (\r\n        select \r\n            from reclada.object o\r\n                where o.guid = (_obj->>'GUID')::uuid\r\n    ) then\r\n        perform reclada_object.update(_obj);\r\n    else\r\n        perform reclada_object.create(_obj);\r\n    end if;\r\n\r\n\r\n    update dev.component_object\r\n        set status = 'delete'\r\n            where status = 'need to check';\r\n\r\n    perform reclada_object.delete(data)\r\n        from dev.component_object\r\n            where status = 'delete';\r\n\r\n    FOR _data IN (SELECT data \r\n                    from dev.component_object \r\n                        where status = 'create_subclass'\r\n                        ORDER BY id)\r\n    LOOP\r\n        perform reclada_object.create_relationship(\r\n                'data of reclada-component',\r\n                (_obj ->>'GUID')::uuid ,\r\n                (cr.v ->>'GUID')::uuid ,\r\n                '{}'::jsonb            ,\r\n                (_obj  ->>'GUID')::uuid\r\n            )\r\n            from (select reclada_object.create_subclass(_data)#>'{0}' v) cr;\r\n    END LOOP;\r\n\r\n    perform reclada_object.create_relationship(\r\n                'data of reclada-component',\r\n                (_obj     ->>'GUID')::uuid ,\r\n                (el.value ->>'GUID')::uuid ,\r\n                '{}'::jsonb                ,\r\n                (_obj     ->>'GUID')::uuid\r\n            )\r\n        from dev.component_object c\r\n        cross join lateral (\r\n            select reclada_object.create(c.data) v\r\n        ) cr\r\n        cross join lateral jsonb_array_elements(cr.v) el\r\n            where c.status = 'create';\r\n\r\n    perform reclada_object.update(data)\r\n        from dev.component_object\r\n            where status = 'update';\r\n    return 'OK';\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS dev.begin_install_component ;\nCREATE OR REPLACE FUNCTION dev.begin_install_component(_name text, _repository text, _commit_hash text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _guid        uuid;\r\n    _f_name      text = 'dev.begin_install_component';\r\nBEGIN\r\n    perform reclada.raise_exception( '"'|| name ||'" component has is already begun installing.',_f_name)\r\n        from dev.component;\r\n\r\n    select guid \r\n        from reclada.v_component \r\n            where name = _name\r\n        into _guid;\r\n\r\n    _guid = coalesce(_guid,public.uuid_generate_v4());\r\n\r\n    insert into dev.component( name,  repository,  commit_hash,  guid)\r\n                       select _name, _repository, _commit_hash, _guid;\r\n\r\n    delete from dev.component_object;\r\n    insert into dev.component_object(data)\r\n        select obj_data \r\n            from reclada.v_component_object\r\n                where component_name = _name;\r\n    return 'OK';\r\nEND;\r\n$function$\n;\n\nDROP view IF EXISTS reclada.v_ui_active_object ;\nCREATE OR REPLACE VIEW reclada.v_ui_active_object\nAS\n SELECT 'with recursive \r\nd as ( \r\n    select  data, \r\n            obj_id,\r\n            created_time,\r\n            attrs \r\n        FROM reclada.v_active_object obj \r\n            where #@#@#where#@#@#\r\n                OFFSET #@#@#offset#@#@#\r\n                LIMIT #@#@#limit#@#@#\r\n),\r\nt as\r\n(\r\n    SELECT  je.key,\r\n            1 as q,\r\n            jsonb_typeof(je.value) typ,\r\n            d.obj_id,\r\n            je.value\r\n        from d \r\n        JOIN LATERAL jsonb_each(d.data) je\r\n            on true\r\n        -- where jsonb_typeof(je.value) != ''null''\r\n    union\r\n    SELECT \r\n            d.key ||'',''|| je.key as key ,\r\n            d.q,\r\n            jsonb_typeof(je.value) typ,\r\n            d.obj_id,\r\n            je.value\r\n        from (\r\n            select  d.data #> (''{''||t.key||''}'')::text[] as data, \r\n                    t.q+1 as q,\r\n                    t.key,\r\n                    d.obj_id\r\n            from t \r\n            join d\r\n                on t.typ = ''object''\r\n        ) d\r\n        JOIN LATERAL jsonb_each(d.data) je\r\n            on true\r\n        -- where jsonb_typeof(je.value) != ''null''\r\n),\r\nres as\r\n(\r\n    select  rr.obj_id,\r\n            rr.data,\r\n            rr.display_key,\r\n            o.attrs,\r\n            o.created_time,\r\n            o.id\r\n        from\r\n        (\r\n            select  t.obj_id,\r\n                    jsonb_object_agg\r\n                    (\r\n                        ''{''||t.key||''}'',\r\n                        t.value\r\n                    ) as data,\r\n                    array_agg(\r\n                        t.key||''#@#@#separator#@#@#''||t.typ \r\n                    ) as display_key\r\n                from t \r\n                    where t.typ != ''object''\r\n                    group by t.obj_id\r\n        ) rr\r\n        join reclada.v_active_object o\r\n            on o.obj_id = rr.obj_id\r\n)\r\n'::text AS val;\nDROP view IF EXISTS reclada.v_component_object ;\nCREATE OR REPLACE VIEW reclada.v_component_object\nAS\n SELECT c.name AS component_name,\n    c.guid AS component_guid,\n    o.class_name,\n    o.obj_id,\n    o.data AS obj_data,\n    r.guid AS relationship_guid\n   FROM v_component c\n     JOIN v_relationship r ON r.parent_guid = c.guid AND 'data of reclada-component'::text = r.type\n     JOIN v_active_object o ON o.obj_id = r.subject;\nDROP function IF EXISTS reclada_object.create_job ;\nCREATE OR REPLACE FUNCTION reclada_object.create_job(_uri text, _obj_id uuid, _new_guid uuid DEFAULT NULL::uuid, _task_guid text DEFAULT NULL::text, _task_command text DEFAULT NULL::text, _pipeline_job_guid uuid DEFAULT NULL::uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    func_name       text := 'reclada_object.create_job';\r\n    _environment    text;\r\n    _obj            jsonb;\r\nBEGIN\r\n    SELECT attrs->>'Environment'\r\n        FROM reclada.v_active_object\r\n        WHERE class_name = 'Context'\r\n        ORDER BY created_time DESC\r\n        LIMIT 1\r\n        INTO _environment;\r\n\r\n    IF _obj_id IS NULL THEN\r\n        PERFORM reclada.raise_exception('Object ID is blank.', func_name);\r\n    END IF;\r\n\r\n    _obj := format('{\r\n                "class": "Job",\r\n                "attributes": {\r\n                    "task": "%s",\r\n                    "status": "new",\r\n                    "command": "%s",\r\n                    "inputParameters": [{"uri": "%s"}, {"dataSourceId": "%s"}]\r\n                    }\r\n                }',\r\n                    COALESCE(reclada.try_cast_uuid(_task_guid), 'c94bff30-15fa-427f-9954-d5c3c151e652'::uuid),\r\n                    COALESCE(_task_command,'./run_pipeline.sh'),\r\n                    _uri,\r\n                    _obj_id::text\r\n            )::jsonb;\r\n    IF _new_guid IS NOT NULL THEN\r\n        _obj := jsonb_set(_obj,'{GUID}',format('"%s"',_new_guid)::jsonb);\r\n    END IF;\r\n\r\n    _obj := jsonb_set(_obj,'{attributes,type}',format('"%s"',_environment)::jsonb);\r\n\r\n    IF _pipeline_job_guid IS NOT NULL THEN\r\n        _obj := jsonb_set(_obj,'{attributes,inputParameters}',_obj#>'{attributes,inputParameters}' || format('{"PipelineLiteJobGUID" :"%s"}',_pipeline_job_guid)::jsonb);\r\n    END IF;\r\n    RETURN reclada_object.create(_obj);\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS api.storage_generate_presigned_post ;\nCREATE OR REPLACE FUNCTION api.storage_generate_presigned_post(data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    user_info    jsonb;\r\n    object_name  varchar;\r\n    file_type    varchar;\r\n    file_size    varchar;\r\n    context      jsonb;\r\n    bucket_name  varchar;\r\n    url          varchar;\r\n    result       jsonb;\r\n\r\nBEGIN\r\n    SELECT reclada_user.auth_by_token(data->>'accessToken') INTO user_info;\r\n    data := data - 'accessToken';\r\n\r\n    IF (NOT(reclada_user.is_allowed(user_info, 'generate presigned post', ''))) THEN\r\n        RAISE EXCEPTION 'Insufficient permissions: user is not allowed to %', 'generate presigned post';\r\n    END IF;\r\n\r\n    object_name := data->>'objectName';\r\n    file_type := data->>'fileType';\r\n    file_size := data->>'fileSize';\r\n\r\n    IF (object_name IS NULL) OR (file_type IS NULL) OR (file_size IS NULL) THEN\r\n        RAISE EXCEPTION 'Parameters objectName, fileType and fileSize must be present';\r\n    END IF;\r\n\r\n    SELECT attrs\r\n    FROM reclada.v_active_object\r\n    WHERE class_name = 'Context'\r\n    ORDER BY id DESC\r\n    LIMIT 1\r\n    INTO context;\r\n\r\n    bucket_name := data->>'bucketName';\r\n\r\n    SELECT payload::jsonb\r\n    FROM aws_lambda.invoke(\r\n        aws_commons.create_lambda_function_arn(\r\n                context->>'Lambda',\r\n                context->>'Region'\r\n        ),\r\n        format('{\r\n            "type": "post",\r\n            "fileName": "%s",\r\n            "fileType": "%s",\r\n            "fileSize": "%s",\r\n            "bucketName": "%s",\r\n            "expiration": 3600}',\r\n            object_name,\r\n            file_type,\r\n            file_size,\r\n            bucket_name\r\n            )::jsonb)\r\n    INTO url;\r\n\r\n    result = format(\r\n        '{"uploadUrl": %s}',\r\n        url\r\n    )::jsonb;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n;\n\nupdate reclada.object u\n    set transaction_id = m.tran_id\n    from (\n        select  (data->>'id')::bigint as id  ,\n                (data->>'tran_id')::bigint tran_id\n            from dev.meta_data\n    ) m\n    where m.id = u.id;\n\ndrop table dev.meta_data;\n\nDROP function IF EXISTS dev.begin_install_component ;\nCREATE OR REPLACE FUNCTION dev.begin_install_component(_name text, _repository text, _commit_hash text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _guid        uuid;\r\n    _f_name      text = 'dev.begin_install_component';\r\nBEGIN\r\n    perform reclada.raise_exception( '"'|| name ||'" component has is already begun installing.',_f_name)\r\n        from dev.component;\r\n\r\n    select guid \r\n        from reclada.v_component \r\n            where name = _name\r\n        into _guid;\r\n\r\n    _guid = coalesce(_guid,public.uuid_generate_v4());\r\n\r\n    insert into dev.component( name,  repository,  commit_hash,  guid)\r\n                       select _name, _repository, _commit_hash, _guid;\r\n\r\n    delete from dev.component_object;\r\n    insert into dev.component_object(data)\r\n        select obj_data \r\n            from reclada.v_component_object\r\n                where component_name = _name;\r\n    return 'OK';\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS dev.finish_install_component ;\nCREATE OR REPLACE FUNCTION dev.finish_install_component()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name   text := 'dev.finish_install_component';\r\n    _obj      jsonb;\r\n    _data     jsonb;\r\nBEGIN\r\n    perform reclada.raise_exception('Component does not found.',_f_name)\r\n        where not exists(select 1 from dev.component);\r\n    \r\n    select ('{\r\n                "GUID": "' || guid::text || '",\r\n                "class":"Component",\r\n                "attributes": {\r\n                    "name":"' || name || '",\r\n                    "repository":"' || repository || '",\r\n                    "commitHash":"' || commit_hash  || '"\r\n                }\r\n            }')::jsonb\r\n        from dev.component\r\n        into _obj;\r\n\r\n    delete from dev.component;\r\n\r\n    if exists\r\n    (\r\n        select \r\n            from reclada.object o\r\n                where o.guid = (_obj->>'GUID')::uuid\r\n    ) then\r\n        perform reclada_object.update(_obj);\r\n    else\r\n        perform reclada_object.create(_obj);\r\n    end if;\r\n\r\n\r\n    update dev.component_object\r\n        set status = 'delete'\r\n            where status = 'need to check';\r\n\r\n    perform reclada_object.delete(data)\r\n        from dev.component_object\r\n            where status = 'delete';\r\n\r\n    FOR _data IN (SELECT data \r\n                    from dev.component_object \r\n                        where status = 'create_subclass'\r\n                        ORDER BY id)\r\n    LOOP\r\n        perform reclada_object.create_relationship(\r\n                'data of reclada-component',\r\n                (_obj ->>'GUID')::uuid ,\r\n                (cr.v ->>'GUID')::uuid ,\r\n                '{}'::jsonb            ,\r\n                (_obj  ->>'GUID')::uuid\r\n            )\r\n            from (select reclada_object.create_subclass(_data)#>'{0}' v) cr;\r\n    END LOOP;\r\n\r\n    perform reclada_object.create_relationship(\r\n                'data of reclada-component',\r\n                (_obj     ->>'GUID')::uuid ,\r\n                (el.value ->>'GUID')::uuid ,\r\n                '{}'::jsonb                ,\r\n                (_obj     ->>'GUID')::uuid\r\n            )\r\n        from dev.component_object c\r\n        cross join lateral (\r\n            select reclada_object.create(c.data) v\r\n        ) cr\r\n        cross join lateral jsonb_array_elements(cr.v) el\r\n            where c.status = 'create';\r\n\r\n    perform reclada_object.update(data)\r\n        from dev.component_object\r\n            where status = 'update';\r\n    return 'OK';\r\n\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS dev.downgrade_component ;\n\nDROP function IF EXISTS reclada_object.create_relationship ;\nCREATE OR REPLACE FUNCTION reclada_object.create_relationship(_rel_type text, _obj_guid uuid, _subj_guid uuid, _extra_attrs jsonb DEFAULT '{}'::jsonb, _parent_guid uuid DEFAULT NULL::uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _rel_cnt    int;\r\n    _obj        jsonb;\r\nBEGIN\r\n\r\n    IF _obj_GUID IS NULL OR _subj_GUID IS NULL THEN\r\n        RAISE EXCEPTION 'Object GUID or Subject GUID IS NULL';\r\n    END IF;\r\n\r\n    SELECT count(*)\r\n    FROM reclada.v_active_object\r\n    WHERE class_name = 'Relationship'\r\n        AND (attrs->>'object')::uuid   = _obj_GUID\r\n        AND (attrs->>'subject')::uuid  = _subj_GUID\r\n        AND attrs->>'type'                      = _rel_type\r\n            INTO _rel_cnt;\r\n    IF (_rel_cnt = 0) THEN\r\n        _obj := format('{\r\n            "class": "Relationship",\r\n            "attributes": {\r\n                    "type": "%s",\r\n                    "object": "%s",\r\n                    "subject": "%s"\r\n                }\r\n            }',\r\n            _rel_type,\r\n            _obj_GUID,\r\n            _subj_GUID)::jsonb;\r\n        _obj := jsonb_set (_obj, '{attributes}', _obj->'attributes' || _extra_attrs);   \r\n        if _parent_guid is not null then\r\n            _obj := jsonb_set (_obj, '{parentGUID}', to_jsonb(_parent_guid) );   \r\n        end if;\r\n\r\n        RETURN  reclada_object.create( _obj);\r\n    ELSE\r\n        RETURN '{}'::jsonb;\r\n    END IF;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.create_subclass ;\nCREATE OR REPLACE FUNCTION reclada_object.create_subclass(_data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _class_list     jsonb;\r\n    _res            jsonb = '{}'::jsonb;\r\n    _class          text;\r\n    _properties     jsonb;\r\n    _p_properties   jsonb;\r\n    _required       jsonb;\r\n    _p_required     jsonb;\r\n    _parent_list    jsonb := '[]';\r\n    _new_class      text;\r\n    attrs           jsonb;\r\n    class_schema    jsonb;\r\n    _version        integer;\r\n    class_guid      uuid;\r\n    _uniFields      jsonb;\r\n    _idx_name       text;\r\n    _f_list         text;\r\n    _field          text;\r\n    _f_name         text = 'reclada_object.create_subclass';\r\n    _partial_clause text;\r\n    _field_name     text;\r\n    _create_obj     jsonb;\r\n    _component_guid uuid;\r\n    _obj_guid       uuid;\r\n    _row_count              int;\r\nBEGIN\r\n\r\n    _class_list := _data->'class';\r\n    IF (_class_list IS NULL) THEN\r\n        perform reclada.raise_exception('The reclada object class is not specified',_f_name);\r\n    END IF;\r\n\r\n    _obj_guid := COALESCE((_data->>'GUID')::uuid,public.uuid_generate_v4());\r\n\r\n    IF (jsonb_typeof(_class_list) != 'array') THEN\r\n        _class_list := '[]'::jsonb || _class_list;\r\n    END IF;\r\n\r\n    attrs := _data->'attributes';\r\n    IF (attrs IS NULL) THEN\r\n        PERFORM reclada.raise_exception('The reclada object must have attributes',_f_name);\r\n    END IF;\r\n\r\n    _new_class  := attrs->>'newClass';\r\n    _properties := COALESCE(attrs -> 'properties','{}'::jsonb);\r\n    _required   := COALESCE(attrs -> 'required'  ,'[]'::jsonb);\r\n\r\n    SELECT guid \r\n        FROM dev.component \r\n        INTO _component_guid;\r\n\r\n    if _component_guid is not null then\r\n        update dev.component_object\r\n            set status = 'ok'\r\n            where status = 'need to check'\r\n                and _new_class  = data #>> '{attributes,forClass}'\r\n                and _properties = data #>  '{attributes,schema,properties}'\r\n                and _required   = data #>  '{attributes,schema,required}'\r\n                and jsonb_array_length(_class_list) = jsonb_array_length(data #> '{attributes,parentList}');\r\n\r\n        GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n        if _row_count > 1 then\r\n            perform reclada.raise_exception('Can not match component objects',_f_name);\r\n        elsif _row_count = 1 then\r\n            return _res;\r\n        end if;\r\n\r\n        -- upgrade jsonschema\r\n        with u as (\r\n            update dev.component_object\r\n                set status = 'delete'\r\n                where status = 'need to check'\r\n                    and _new_class  = data #>> '{attributes,forClass}'\r\n                RETURNING 1 as v\r\n        )\r\n        insert into dev.component_object( data, status  )\r\n            select _data, 'create_subclass'\r\n                from u;\r\n\r\n        GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n        if _row_count > 1 then\r\n            perform reclada.raise_exception('Can not match component objects',_f_name);\r\n        elsif _row_count = 1 then\r\n            return _res;\r\n        end if;\r\n\r\n        insert into dev.component_object( data, status  )\r\n                select _data, 'create_subclass';\r\n            return _res;\r\n    end if;\r\n\r\n    FOR _class IN SELECT jsonb_array_elements_text(_class_list)\r\n    LOOP\r\n\r\n        SELECT reclada_object.get_schema(_class) \r\n            INTO class_schema;\r\n\r\n        IF (class_schema IS NULL) THEN\r\n            perform reclada.raise_exception('No json schema available for ' || _class, _f_name);\r\n        END IF;\r\n        \r\n        SELECT class_schema->>'GUID'\r\n            INTO class_guid;\r\n        \r\n        _parent_list := _parent_list || to_jsonb(class_guid);\r\n\r\n    END LOOP;\r\n   \r\n    SELECT max(version) + 1\r\n    FROM reclada.v_class_lite v\r\n    WHERE v.for_class = _new_class\r\n        INTO _version;\r\n\r\n    _version := coalesce(_version,1);\r\n\r\n    _create_obj := format('{\r\n        "class": "jsonschema",\r\n        "GUID": "%s",\r\n        "attributes": {\r\n            "forClass": "%s",\r\n            "version": "%s",\r\n            "schema": {\r\n                "type": "object",\r\n                "properties": %s,\r\n                "required": %s\r\n            },\r\n            "parentList":%s\r\n        }\r\n    }',\r\n    _obj_guid::text,\r\n    _new_class,\r\n    _version,\r\n    _properties,\r\n    _required,\r\n    _parent_list\r\n    )::jsonb;\r\n    IF ( jsonb_typeof(attrs->'dupChecking') = 'array' ) THEN\r\n        _create_obj := jsonb_set(_create_obj, '{attributes,dupChecking}',attrs->'dupChecking');\r\n        IF ( jsonb_typeof(attrs->'dupBehavior') = 'string' ) THEN\r\n            _create_obj := jsonb_set(_create_obj, '{attributes,dupBehavior}',attrs->'dupBehavior');\r\n        END IF;\r\n        IF ( jsonb_typeof(attrs->'isCascade') = 'boolean' ) THEN\r\n            _create_obj := jsonb_set(_create_obj, '{attributes,isCascade}',attrs->'isCascade');\r\n        END IF;\r\n        IF ( jsonb_typeof(attrs->'copyField') = 'string' ) THEN\r\n            _create_obj := jsonb_set(_create_obj, '{attributes,copyField}',attrs->'copyField');\r\n        END IF;\r\n    END IF;\r\n    IF ( jsonb_typeof(attrs->'parentField') = 'string' ) THEN\r\n        _create_obj := jsonb_set(_create_obj, '{attributes,parentField}',attrs->'parentField');\r\n    END IF;\r\n    select reclada_object.create(_create_obj)\r\n        into _res;\r\n    PERFORM reclada_object.refresh_mv('uniFields');\r\n    return _res;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(_data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name       TEXT = 'reclada_object.update';\r\n    _class_name   text;\r\n    _class_uuid   uuid;\r\n    _obj_id       uuid;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    old_obj       jsonb;\r\n    branch        uuid;\r\n    revid         uuid;\r\n    _parent_guid  uuid;\r\n    _parent_field text;\r\n    _obj_guid     uuid;\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _uni_field    text;\r\n    _cnt          int;\r\n    _guid_list      text;\r\nBEGIN\r\n\r\n    SELECT  valid_schema, \r\n            attributes,\r\n            class_name,\r\n            class_guid \r\n        FROM reclada.validate_json_schema(_data)\r\n        INTO    schema      , \r\n                _attrs      ,\r\n                _class_name ,\r\n                _class_uuid ;\r\n\r\n\r\n    _obj_id := _data->>'GUID';\r\n    IF (_obj_id IS NULL) THEN\r\n        perform reclada.raise_exception('Could not update object with no GUID',_f_name);\r\n    END IF;\r\n\r\n\r\n    -- don't allow update jsonschema\r\n    if _class_name = 'jsonschema' then\r\n        perform reclada.raise_exception('Can''t update jsonschema',_f_name);\r\n    end if;\r\n\r\n    SELECT \tv.data\r\n        FROM reclada.v_object v\r\n\t        WHERE v.obj_id = _obj_id\r\n                AND v.class_name = _class_name \r\n\t    INTO old_obj;\r\n\r\n    IF (old_obj IS NULL) THEN\r\n        perform reclada.raise_exception('Could not update object, no such id');\r\n    END IF;\r\n\r\n    branch := _data->'branch';\r\n    SELECT reclada_revision.create(user_info->>'sub', branch, _obj_id) \r\n        INTO revid;\r\n\r\n    SELECT prnt_guid, prnt_field\r\n    FROM reclada_object.get_parent_guid(_data,_class_name)\r\n        INTO _parent_guid,\r\n            _parent_field;\r\n\r\n    IF (_parent_guid IS NULL) THEN\r\n        _parent_guid := old_obj->>'parentGUID';\r\n    END IF;\r\n    \r\n    IF EXISTS (\r\n        SELECT 1\r\n        FROM reclada.v_object_unifields\r\n        WHERE class_uuid=_class_uuid\r\n    )\r\n    THEN\r\n        SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg(DISTINCT obj_guid::text, ',')\r\n        FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)\r\n        GROUP BY dup_behavior\r\n            INTO _cnt, _dup_behavior, _guid_list;\r\n        IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n            RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n        END IF;\r\n        FOR _obj_guid, _dup_behavior, _uni_field IN (\r\n                SELECT obj_guid, dup_behavior, dup_field\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)\r\n            ) LOOP\r\n            IF _dup_behavior IN ('Update','Merge') THEN\r\n                UPDATE reclada.object o\r\n                    SET status = reclada_object.get_archive_status_obj_id()\r\n                WHERE o.GUID = _obj_guid\r\n                    AND status != reclada_object.get_archive_status_obj_id();\r\n            END IF;\r\n            CASE _dup_behavior\r\n                WHEN 'Replace' THEN\r\n                    PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                WHEN 'Update' THEN                    \r\n                    _data := reclada_object.remove_parent_guid(_data, _parent_field);\r\n                    _data := reclada_object.update_json_by_guid(_obj_guid, _data);\r\n                    RETURN reclada_object.update(_data);\r\n                WHEN 'Reject' THEN\r\n                    RAISE EXCEPTION 'Duplicate found (GUID: %). Object rejected.', _obj_guid;\r\n                WHEN 'Copy'    THEN\r\n                    _attrs = _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                    IF (NOT(public.validate_json_schema(schema, _attrs))) THEN\r\n                        RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n                    END IF;\r\n                WHEN 'Insert' THEN\r\n                    -- DO nothing\r\n                WHEN 'Merge' THEN                    \r\n                    RETURN reclada_object.update(\r\n                        reclada_object.merge(\r\n                            _data - 'class', \r\n                            vao.data, \r\n                            schema\r\n                        ) || format('{"GUID": "%s"}', _obj_guid)::jsonb\r\n                    )\r\n                        FROM reclada.v_active_object vao\r\n                            WHERE obj_id = _obj_guid;\r\n            END CASE;\r\n        END LOOP;\r\n    END IF;\r\n\r\n    with t as \r\n    (\r\n        update reclada.object o\r\n            set status = reclada_object.get_archive_status_obj_id()\r\n                where o.GUID = _obj_id\r\n                    and status != reclada_object.get_archive_status_obj_id()\r\n                        RETURNING id\r\n    )\r\n    INSERT INTO reclada.object( GUID,\r\n                                class,\r\n                                status,\r\n                                attributes,\r\n                                transaction_id,\r\n                                parent_guid\r\n                              )\r\n        select  v.obj_id,\r\n                _class_uuid,\r\n                reclada_object.get_active_status_obj_id(),--status \r\n                _attrs || format('{"revision":"%s"}',revid)::jsonb,\r\n                transaction_id,\r\n                _parent_guid\r\n            FROM reclada.v_object v\r\n            JOIN \r\n            (   \r\n                select id \r\n                    FROM \r\n                    (\r\n                        select id, 1 as q\r\n                            from t\r\n                        union \r\n                        select id, 2 as q\r\n                            from reclada.object ro\r\n                                where ro.guid = _obj_id\r\n                                    ORDER BY ID DESC \r\n                                        LIMIT 1\r\n                    ) ta\r\n                    ORDER BY q ASC \r\n                        LIMIT 1\r\n            ) as tt\r\n                on tt.id = v.id\r\n\t            WHERE v.obj_id = _obj_id;\r\n\r\n    PERFORM reclada.update_unique_object(ARRAY[_obj_id]);\r\n\r\n    PERFORM reclada_object.object_insert\r\n            (\r\n                _class_name,\r\n                _obj_id,\r\n                _attrs\r\n            );\r\n    PERFORM reclada_object.refresh_mv(_class_name);\r\n\r\n    IF ( _class_name = 'jsonschema' AND jsonb_typeof(_attrs->'dupChecking') = 'array') THEN\r\n        PERFORM reclada_object.refresh_mv('uniFields');\r\n    END IF; \r\n                  \r\n    select v.data \r\n        FROM reclada.v_active_object v\r\n            WHERE v.obj_id = _obj_id\r\n        into _data;\r\n    PERFORM reclada_notification.send_object_notification('update', _data);\r\n    RETURN _data;\r\nEND;\r\n$function$\n;\n\nDROP function IF EXISTS dev.downgrade_version ;\nCREATE OR REPLACE FUNCTION dev.downgrade_version()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\ndeclare \r\n    current_ver int; \r\n    downgrade_script text;\r\n    v_state   TEXT;\r\n    v_msg     TEXT;\r\n    v_detail  TEXT;\r\n    v_hint    TEXT;\r\n    v_context TEXT;\r\nBEGIN\r\n\r\n    select max(ver) \r\n        from dev.VER\r\n    into current_ver;\r\n    \r\n    select v.downgrade_script \r\n        from dev.VER v\r\n            WHERE current_ver = v.ver\r\n        into downgrade_script;\r\n\r\n    if COALESCE(downgrade_script,'') = '' then\r\n        RAISE EXCEPTION 'downgrade_script is empty! from dev.downgrade_version()';\r\n    end if;\r\n\r\n    EXECUTE downgrade_script;\r\n\r\n    -- mark, that chanches applied\r\n    delete \r\n        from dev.VER v\r\n            where v.ver = current_ver;\r\n\r\n    v_msg = 'OK, curren version: ' || (current_ver-1)::text;\r\n    perform reclada.raise_notice(v_msg);\r\n    return v_msg;\r\nEXCEPTION when OTHERS then \r\n\tget stacked diagnostics\r\n        v_state   = returned_sqlstate,\r\n        v_msg     = message_text,\r\n        v_detail  = pg_exception_detail,\r\n        v_hint    = pg_exception_hint,\r\n        v_context = pg_exception_context;\r\n\r\n    v_state := format('Got exception:\r\nstate   : %s\r\nmessage : %s\r\ndetail  : %s\r\nhint    : %s\r\ncontext : %s\r\nSQLSTATE: %s\r\nSQLERRM : %s', \r\n                v_state, \r\n                v_msg, \r\n                v_detail, \r\n                v_hint, \r\n                v_context,\r\n                SQLSTATE,\r\n                SQLERRM);\r\n    perform dev.reg_notice(v_state);\r\n    return v_state;\r\nEND\r\n$function$\n;\nDROP view IF EXISTS reclada.v_object_display ;\nCREATE OR REPLACE VIEW reclada.v_object_display\nAS\n SELECT obj.id,\n    obj.guid,\n    (obj.attributes ->> 'classGUID'::text)::uuid AS class_guid,\n    obj.attributes ->> 'caption'::text AS caption,\n    obj.attributes -> 'table'::text AS "table",\n    obj.attributes -> 'card'::text AS card,\n    obj.attributes -> 'preview'::text AS preview,\n    obj.attributes -> 'list'::text AS list,\n    obj.created_time,\n    obj.attributes,\n    obj.status\n   FROM object obj\n  WHERE obj.class = (( SELECT reclada_object.get_guid_for_class('ObjectDisplay'::text) AS get_guid_for_class)) AND obj.status = reclada_object.get_active_status_obj_id();\ndrop VIEW reclada.v_component_object;\nDROP view IF EXISTS reclada.v_component ;\nCREATE OR REPLACE VIEW reclada.v_component\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    obj.attrs ->> 'name'::text AS name,\n    obj.attrs ->> 'repository'::text AS repository,\n    obj.attrs ->> 'commitHash'::text AS commit_hash,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'Component'::text;\nDROP view IF EXISTS reclada.v_component_object ;\nCREATE OR REPLACE VIEW reclada.v_component_object\nAS\n SELECT c.name AS component_name,\n    c.guid AS component_guid,\n    o.class_name,\n    o.obj_id,\n    o.data AS obj_data,\n    r.guid AS relationship_guid\n   FROM v_component c\n     JOIN v_relationship r ON r.parent_guid = c.guid AND 'data of reclada-component'::text = r.type\n     JOIN v_active_object o ON o.obj_id = r.subject;\n\n    delete from reclada.object \n        where guid in \n        (\n            SELECT relationship_guid \n                FROM reclada.v_component_object \n                    where class_name in (   'jsonschema', \n                                            'DataSet',\n                                            'User',\n                                            'DTOJsonSchema',\n                                            'ObjectDisplay',\n                                            'Message'\n                                        )\n                        and component_name = 'db'\n        );\n\n    -- delete from reclada.object \n    --     where class in (select reclada_object.get_GUID_for_class('Index'));\n\n\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    _data         jsonb;\r\n    new_data      jsonb;\r\n    _class_name    text;\r\n    _class_uuid   uuid;\r\n    tran_id       bigint;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    _obj_guid     uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    inserted      uuid[];\r\n    inserted_from_draft uuid[];\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _is_cascade   boolean;\r\n    _uni_field    text;\r\n    _parent_guid  uuid;\r\n    _parent_field   text;\r\n    skip_insert     boolean;\r\n    notify_res      jsonb;\r\n    _cnt             int;\r\n    _new_parent_guid       uuid;\r\n    _rel_type       text := 'GUID changed for dupBehavior';\r\n    _guid_list      text;\r\n    _component_guid uuid;\r\n    _row_count              int;\r\n    _f_name         text = 'reclada_object.create';\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n\r\n    SELECT guid \r\n        FROM dev.component \r\n        INTO _component_guid;\r\n\r\n    /*TODO: check if some objects have revision AND others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    FOR _data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n\r\n        if _component_guid is not null then\r\n            _attrs      := _data-> 'attributes';\r\n            _obj_guid   := _data->>'GUID'      ;    \r\n            select obj_id, for_class \r\n                from reclada.v_class \r\n                    where _data->>'class' in (obj_id::text, for_class)\r\n                    ORDER BY version DESC \r\n                    LIMIT 1\r\n                into _class_uuid, _class_name;\r\n\r\n            perform reclada.raise_exception('You should use reclada_object.create_subclass for new jsonschema.',_f_name)\r\n                where _class_name = 'jsonschema';\r\n\r\n            update dev.component_object\r\n                set status = 'ok'\r\n                    where status = 'need to check'\r\n                        and _obj_guid::text      = data->>'GUID'\r\n                        and _attrs               = data-> 'attributes'\r\n                        and _class_uuid::text    = data->>'class'\r\n                        and coalesce(_data->>'parentGUID','null') = coalesce(data->>'parentGUID','null') \r\n                        ------\r\n                        and _obj_guid is not null;\r\n                        ------\r\n\r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n\r\n            update dev.component_object\r\n                set status = 'update',\r\n                    data   = _data\r\n                    where status = 'need to check' \r\n                        and _obj_guid::text = data->>'GUID'\r\n                        ------\r\n                        and _obj_guid is not null;\r\n                        ------\r\n\r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n            \r\n            with t as\r\n            (\r\n                select min(id) as id\r\n                    from dev.component_object\r\n                        where status = 'need to check'\r\n                            and _attrs               = data-> 'attributes'\r\n                            and _class_uuid::text    = data->>'class'\r\n                            and coalesce(_data->>'parentGUID','null') = coalesce(data->>'parentGUID','null')\r\n                            ------\r\n                            and _obj_guid is null\r\n                            ------\r\n            )\r\n                update dev.component_object u\r\n                    set status = 'ok'\r\n                        from t\r\n                            where u.id = t.id;\r\n                    \r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n            \r\n            insert into dev.component_object( data, status  )\r\n                select _data, 'create';\r\n            continue;\r\n            \r\n        end if;\r\n\r\n        SELECT  valid_schema, \r\n                attributes,\r\n                class_name,\r\n                class_guid \r\n            FROM reclada.validate_json_schema(_data)\r\n            INTO    schema      , \r\n                    _attrs      ,\r\n                    _class_name ,\r\n                    _class_uuid ;\r\n\r\n        skip_insert := false;\r\n\r\n        tran_id := (_data->>'transactionID')::bigint;\r\n        IF tran_id IS NULL THEN\r\n            tran_id := reclada.get_transaction_id();\r\n        END IF;\r\n\r\n        IF _data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        SELECT prnt_guid, prnt_field\r\n        FROM reclada_object.get_parent_guid(_data,_class_name)\r\n            INTO _parent_guid,\r\n                _parent_field;\r\n        _obj_guid := _data->>'GUID';\r\n\r\n        IF (_parent_guid IS NOT NULL) THEN\r\n            SELECT\r\n                attrs->>'object',\r\n                attrs->>'dupBehavior',\r\n                attrs->>'isCascade'\r\n            FROM reclada.v_active_object\r\n            WHERE class_name = 'Relationship'\r\n                AND attrs->>'type'                      = _rel_type\r\n                AND (attrs->>'subject')::uuid  = _parent_guid\r\n                    INTO _new_parent_guid, _dup_behavior, _is_cascade;\r\n\r\n            IF _new_parent_guid IS NOT NULL THEN\r\n                _parent_guid := _new_parent_guid;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.v_object_unifields\r\n            WHERE class_uuid = _class_uuid\r\n        )\r\n        THEN\r\n            IF (_parent_guid IS NOT NULL) THEN\r\n                IF (_dup_behavior = 'Update' AND _is_cascade) THEN\r\n                    SELECT count(DISTINCT obj_guid), string_agg(DISTINCT obj_guid::text, ',')\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                        INTO _cnt, _guid_list;\r\n                    IF (_cnt >1) THEN\r\n                        RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                    ELSIF (_cnt = 1) THEN\r\n                        SELECT DISTINCT obj_guid, is_cascade\r\n                        FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                            INTO _obj_guid, _is_cascade;\r\n                        new_data := _data;\r\n                        IF new_data->>'GUID' IS NOT NULL THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                        END IF;\r\n                        new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                        new_data = reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                        SELECT reclada_object.update(new_data)\r\n                            INTO res;\r\n                        affected := array_append( affected, _obj_guid);\r\n                        skip_insert := true;\r\n                    END IF;\r\n                END IF;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM reclada.v_active_object\r\n                    WHERE obj_id = _parent_guid\r\n                )\r\n                    AND _new_parent_guid IS NULL\r\n                THEN\r\n                    IF (_obj_guid IS NULL) THEN\r\n                        RAISE EXCEPTION 'GUID is required.';\r\n                    END IF;\r\n                    INSERT INTO reclada.draft(guid, parent_guid, data)\r\n                        VALUES(_obj_guid, _parent_guid, _data);\r\n                    skip_insert := true;\r\n                END IF;\r\n            END IF;\r\n\r\n            IF (NOT skip_insert) THEN\r\n                SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg (DISTINCT obj_guid::text, ',')\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                GROUP BY dup_behavior\r\n                    INTO _cnt, _dup_behavior, _guid_list;\r\n                IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n                    RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                END IF;\r\n                FOR _obj_guid, _dup_behavior, _is_cascade, _uni_field IN\r\n                    SELECT obj_guid, dup_behavior, is_cascade, dup_field\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                LOOP\r\n                    new_data := _data;\r\n                    CASE _dup_behavior\r\n                        WHEN 'Replace' THEN\r\n                            IF (_is_cascade = true) THEN\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', a)::jsonb)\r\n                                FROM reclada.get_children(_obj_guid) a;\r\n                            ELSE\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                            END IF;\r\n                        WHEN 'Update' THEN\r\n                            IF new_data->>'GUID' IS NOT NULL THEN\r\n                                PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                            END IF;\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            new_data := reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                            SELECT reclada_object.update(new_data)\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                        WHEN 'Reject' THEN\r\n                            RAISE EXCEPTION 'The object was rejected.';\r\n                        WHEN 'Copy'    THEN\r\n                            _attrs := _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                        WHEN 'Insert' THEN\r\n                            -- DO nothing\r\n                        WHEN 'Merge' THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    '{"dupBehavior": "Merge"}'::jsonb\r\n                                );\r\n                            SELECT reclada_object.update(\r\n                                    reclada_object.merge(\r\n                                            new_data - 'class', \r\n                                            data,\r\n                                            schema\r\n                                        ) \r\n                                        || format('{"GUID": "%s"}', _obj_guid)::jsonb \r\n                                        || format('{"transactionID": %s}', tran_id)::jsonb\r\n                                )\r\n                            FROM reclada.v_active_object\r\n                            WHERE obj_id = _obj_guid\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                    END CASE;\r\n                END LOOP;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF (NOT skip_insert) THEN           \r\n            _obj_guid := _data->>'GUID';\r\n            IF EXISTS (\r\n                SELECT FROM reclada.object \r\n                    WHERE guid = _obj_guid\r\n            ) THEN\r\n                perform reclada.raise_exception ('GUID: '||_obj_guid::text||' is duplicate',_f_name);\r\n            END IF;\r\n\r\n            _obj_guid := coalesce(_obj_guid, public.uuid_generate_v4());\r\n\r\n            INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n                SELECT  _obj_guid AS GUID,\r\n                        _class_uuid, \r\n                        _attrs,\r\n                        tran_id,\r\n                        _parent_guid;\r\n\r\n            affected := array_append( affected, _obj_guid);\r\n            inserted := array_append( inserted, _obj_guid);\r\n            PERFORM reclada_object.object_insert\r\n                (\r\n                    _class_name,\r\n                    _obj_guid,\r\n                    _attrs\r\n                );\r\n\r\n            PERFORM reclada_object.refresh_mv(_class_name);\r\n        END IF;\r\n    END LOOP;\r\n\r\n    SELECT array_agg(_affected_objects->>'GUID')\r\n    FROM (\r\n        SELECT jsonb_array_elements(_affected_objects) AS _affected_objects\r\n        FROM (\r\n            SELECT reclada_object.create(data) AS _affected_objects\r\n            FROM reclada.draft\r\n            WHERE parent_guid = ANY (affected)\r\n        ) a\r\n    ) b\r\n    WHERE _affected_objects->>'GUID' IS NOT NULL\r\n        INTO inserted_from_draft;\r\n    affected := affected || inserted_from_draft;    \r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb;\r\n    notify_res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (inserted)\r\n                )\r\n            )::jsonb; \r\n    \r\n    DELETE FROM reclada.draft \r\n        WHERE guid = ANY (affected);\r\n\r\n    PERFORM reclada.update_unique_object(affected);\r\n        \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            notify_res\r\n        );\r\n    RETURN res;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.merge ;\nCREATE OR REPLACE FUNCTION reclada_object.merge(lobj jsonb, robj jsonb, schema jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\n    DECLARE\r\n        res     jsonb;\r\n        ltype    text;\r\n        rtype    text;\r\n    BEGIN\r\n        ltype := jsonb_typeof(lobj);\r\n        rtype := jsonb_typeof(robj);\r\n        IF (lobj IS NULL AND robj IS NOT NULL) THEN\r\n            RETURN robj;\r\n        END IF;\r\n        IF (lobj IS NOT NULL AND robj IS NULL) THEN\r\n            RETURN lobj;\r\n        END IF;\r\n        IF (ltype = 'null') THEN\r\n            RETURN robj;\r\n        END IF;\r\n        IF (ltype != rtype) THEN\r\n            RETURN lobj || robj;\r\n        END IF;\r\n        IF reclada_object.is_equal(lobj,robj) THEN\r\n            RETURN lobj;\r\n        END IF;\r\n        CASE ltype \r\n        WHEN 'object' THEN\r\n            SELECT jsonb_object_agg(key,val)\r\n            FROM (\r\n                SELECT key, reclada_object.merge(lval,rval) as val\r\n                    FROM (                     -- Using joining operators compatible with merge or hash join is obligatory\r\n                    SELECT (a.rec).key as key,\r\n                        (a.rec).value AS lval,\r\n                        (b.rec).value AS rval                                        --    with FULL OUTER JOIN. merge is compatible only with NESTED LOOPS\r\n                    FROM (SELECT jsonb_each(lobj) AS rec) a         --    so I use LEFT JOIN UNION ALL RIGHT JOIN insted of FULL OUTER JOIN.\r\n                    LEFT JOIN\r\n                        (SELECT jsonb_each(robj) AS rec) b\r\n                    ON (a.rec).key = (b.rec).key\r\n                UNION\r\n                    SELECT (a.rec).key as key,\r\n                        (b.rec).value AS lval,\r\n                        (a.rec).value AS rval\r\n                    FROM (SELECT jsonb_each(robj) AS rec) a\r\n                    LEFT JOIN\r\n                        (SELECT jsonb_each(lobj) AS rec) b\r\n                    ON (a.rec).key = (b.rec).key\r\n                ) a\r\n            ) b\r\n                INTO res;\r\n            IF schema IS NOT NULL AND NOT validate_json_schema(schema, res) THEN\r\n                RAISE EXCEPTION 'Objects aren''t mergeable. Solve duplicate conflicate manually.';\r\n            END IF;\r\n            RETURN res;\r\n        WHEN 'array' THEN\r\n            SELECT to_jsonb(array_agg(rec)) FROM (\r\n                SELECT COALESCE(a.rec, b.rec) as rec\r\n                FROM (SELECT jsonb_array_elements (lobj) AS rec) a\r\n                LEFT JOIN\r\n                    (SELECT jsonb_array_elements (robj) AS rec) b\r\n                ON reclada_object.is_equal((a.rec), (b.rec))\r\n                UNION\r\n                SELECT COALESCE(a.rec, b.rec) as rec\r\n                FROM (SELECT jsonb_array_elements (robj) AS rec) a\r\n                LEFT JOIN\r\n                    (SELECT jsonb_array_elements (lobj) AS rec) b\r\n                ON reclada_object.is_equal((a.rec), (b.rec))\r\n            ) a\r\n                INTO res;\r\n            RETURN res;\r\n        WHEN 'string' THEN\r\n            RETURN lobj || robj;\r\n        WHEN 'number' THEN\r\n            RETURN lobj || robj;\r\n        WHEN 'boolean' THEN\r\n            RETURN lobj || robj;\r\n        WHEN 'null' THEN\r\n            RETURN '{}'::jsonb;                                    -- It should be Null\r\n        ELSE\r\n            RETURN null;\r\n        END CASE;\r\n    END;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false, ver text DEFAULT '1'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    _class              text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    _exec_text           text;\r\n    _pre_query           text;\r\n    _from               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             JSONB;\r\n    _object_display     JSONB;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    if ver = '1' then\r\n        tran_id := (data->>'transactionID')::bigint;\r\n        _class := data->>'class';\r\n    elseif ver = '2' then\r\n        tran_id := (data->>'{transactionID}')::bigint;\r\n        _class := data->>'{class}';\r\n    end if;\r\n    _filter = data->'filter';\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) THEN\r\n        order_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(\r\n            E'obj.data#>''{%s}'' %s', \r\n            case ver\r\n                when '2'\r\n                    then REPLACE(REPLACE(T.value->>'field','{', '"{' ),'}', '}"' )\r\n                else\r\n                    T.value->>'field'\r\n            end,\r\n            COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    \r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSEIF ver = '1' then\r\n        class_uuid := reclada.try_cast_uuid(_class);\r\n\r\n        IF (class_uuid IS NULL) THEN\r\n            SELECT v.obj_id\r\n                FROM reclada.v_class v\r\n                    WHERE _class = v.for_class\r\n                    ORDER BY v.version DESC\r\n                    limit 1 \r\n            INTO class_uuid;\r\n            IF (class_uuid IS NULL) THEN\r\n                perform reclada.raise_exception(\r\n                        format('Class not found: %s', _class),\r\n                        _f_name\r\n                    );\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', _class) AS condition\r\n                        where _class is not null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                            and _class is null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    -- TODO: add ELSE\r\n    IF ver = '2' THEN\r\n        _pre_query := (select val from reclada.v_ui_active_object);\r\n        _from := 'res AS obj';\r\n        _pre_query := REPLACE(_pre_query,'#@#@#where#@#@#', query_conditions  );\r\n\r\n    ELSE\r\n        _pre_query := '';\r\n        _from := 'reclada.v_active_object AS obj\r\n                            WHERE #@#@#where#@#@#';\r\n        _from := REPLACE(_from, '#@#@#where#@#@#', query_conditions  );\r\n    END IF;\r\n    _exec_text := _pre_query ||\r\n                'SELECT to_jsonb(array_agg(t.data))\r\n                    FROM \r\n                    (\r\n                        SELECT obj.data\r\n                            FROM '\r\n                            || _from\r\n                            || ' \r\n                            ORDER BY #@#@#orderby#@#@#'\r\n                            || case \r\n                                when ver = '2' \r\n                                    then ''\r\n                                else\r\n                                '\r\n                                OFFSET #@#@#offset#@#@#\r\n                                LIMIT #@#@#limit#@#@#'\r\n                            end\r\n                            || '\r\n                    ) AS t';\r\n    _exec_text := REPLACE(_exec_text, '#@#@#orderby#@#@#'  , order_by          );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#offset#@#@#'   , offset_           );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#limit#@#@#'    , limit_            );\r\n    -- RAISE NOTICE 'conds: %', _exec_text;\r\n    EXECUTE _exec_text\r\n        INTO objects;\r\n    objects := coalesce(objects,'[]'::jsonb);\r\n    IF gui THEN\r\n\r\n        if ver = '2' then\r\n            class_uuid := coalesce(class_uuid, (objects#>>'{0,"{class}"}')::uuid);\r\n            if class_uuid is not null then\r\n                _class :=   (\r\n                                select cl.for_class \r\n                                    from reclada.v_class_lite cl\r\n                                        where class_uuid = cl.obj_id\r\n                                            limit 1\r\n                            );\r\n\r\n                _exec_text := '\r\n                with \r\n                d as ( \r\n                    select id_unique_object\r\n                        FROM reclada.v_active_object obj \r\n                        JOIN reclada.unique_object_reclada_object as uoc\r\n                            on uoc.id_reclada_object = obj.id\r\n                                and #@#@#where#@#@#\r\n                        group by id_unique_object\r\n                ),\r\n                dd as (\r\n                    select distinct \r\n                            ''{''||f.path||''}:''||f.json_type v,\r\n                            f.json_type\r\n                        FROM d \r\n                        JOIN reclada.unique_object as uo\r\n                            on d.id_unique_object = uo.id\r\n                        JOIN reclada.field f\r\n                            on f.id = ANY (uo.id_field)\r\n                    UNION\r\n                    SELECT  pattern||'':''|| t.v,\r\n                            t.v\r\n                    FROM reclada.v_filter_mapping vfm\r\n                    CROSS JOIN LATERAL \r\n                    (\r\n                        SELECT  CASE \r\n                                    WHEN vfm.pattern=''{transactionID}'' \r\n                                        THEN ''number'' \r\n                                    ELSE ''string'' \r\n                                END as v\r\n                    ) t\r\n                ),\r\n                on_data as \r\n                (\r\n                    select  jsonb_object_agg(\r\n                                t.v, \r\n                                replace(dd.template,''#@#attrname#@#'',t.v)::jsonb \r\n                            ) t\r\n                        from dd as t\r\n                        JOIN reclada.v_default_display dd\r\n                            on t.json_type = dd.json_type\r\n                )\r\n                select jsonb_set(templ.v,''{table}'', od.t || coalesce(d.table,coalesce(d.table,templ.v->''table'')))\r\n                    from on_data od\r\n                    join (\r\n                        select replace(template,''#@#classname#@#'','''|| _class ||''')::jsonb v\r\n                            from reclada.v_default_display \r\n                                where json_type = ''ObjectDisplay''\r\n                                    limit 1\r\n                    ) templ\r\n                        on true\r\n                    left join reclada.v_object_display d\r\n                        on d.class_guid::text = '''|| coalesce( class_uuid::text, '' ) ||'''';\r\n\r\n                _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );\r\n                -- raise notice '%',_exec_text;\r\n                EXECUTE _exec_text\r\n                    INTO _object_display;\r\n            end if;\r\n        end if;\r\n\r\n        _exec_text := '\r\n            SELECT  COUNT(1),\r\n                    TO_CHAR(\r\n                        MAX(\r\n                            GREATEST(\r\n                                obj.created_time, \r\n                                (\r\n                                    SELECT  TO_TIMESTAMP(\r\n                                                MAX(date_time),\r\n                                                ''YYYY-MM-DD hh24:mi:ss.US TZH''\r\n                                            )\r\n                                        FROM reclada.v_revision vr\r\n                                            WHERE vr.obj_id = UUID(obj.attrs ->>''revision'')\r\n                                )\r\n                            )\r\n                        ),\r\n                        ''YYYY-MM-DD hh24:mi:ss.MS TZH''\r\n                    )\r\n                    FROM reclada.v_active_object obj \r\n                        where #@#@#where#@#@#';\r\n\r\n        _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );\r\n        -- raise notice '%',_exec_text;\r\n        EXECUTE _exec_text\r\n            INTO number_of_objects, last_change;\r\n        \r\n        IF _object_display IS NOT NULL then\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects,\r\n                    'display', _object_display\r\n                );\r\n        ELSE\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects\r\n            );\r\n        end if;\r\n    ELSE\r\n        \r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_ui_active_object ;\nCREATE OR REPLACE VIEW reclada.v_ui_active_object\nAS\n SELECT 'with recursive \r\nd as ( \r\n    select  data, \r\n            obj_id,\r\n            created_time,\r\n            attrs \r\n        FROM reclada.v_active_object obj \r\n            where #@#@#where#@#@#\r\n                OFFSET #@#@#offset#@#@#\r\n                LIMIT #@#@#limit#@#@#\r\n),\r\nt as\r\n(\r\n    SELECT  je.key,\r\n            1 as q,\r\n            jsonb_typeof(je.value) typ,\r\n            d.obj_id,\r\n            je.value\r\n        from d \r\n        JOIN LATERAL jsonb_each(d.data) je\r\n            on true\r\n        -- where jsonb_typeof(je.value) != ''null''\r\n    union\r\n    SELECT \r\n            d.key ||'',''|| je.key as key ,\r\n            d.q,\r\n            jsonb_typeof(je.value) typ,\r\n            d.obj_id,\r\n            je.value\r\n        from (\r\n            select  d.data #> (''{''||t.key||''}'')::text[] as data, \r\n                    t.q+1 as q,\r\n                    t.key,\r\n                    d.obj_id\r\n            from t \r\n            join d\r\n                on t.typ = ''object''\r\n        ) d\r\n        JOIN LATERAL jsonb_each(d.data) je\r\n            on true\r\n        -- where jsonb_typeof(je.value) != ''null''\r\n),\r\nres as\r\n(\r\n    select  rr.obj_id,\r\n            rr.data,\r\n            rr.display_key,\r\n            o.attrs,\r\n            o.created_time,\r\n            o.id\r\n        from\r\n        (\r\n            select  t.obj_id,\r\n                    jsonb_object_agg\r\n                    (\r\n                        ''{''||t.key||''}'',\r\n                        t.value\r\n                    ) as data,\r\n                    array_agg(\r\n                        t.key||''#@#@#separator#@#@#''||t.typ \r\n                    ) as display_key\r\n                from t \r\n                    where t.typ != ''object''\r\n                    group by t.obj_id\r\n        ) rr\r\n        join reclada.v_active_object o\r\n            on o.obj_id = rr.obj_id\r\n)\r\n'::text AS val;\n\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_unifields;\nCREATE MATERIALIZED VIEW reclada.v_object_unifields\nAS\n    SELECT\n        for_class,\n        class_uuid,\n        CAST (dup_behavior AS reclada.dp_bhvr) AS dup_behavior,\n        is_cascade,\n        is_mandatory,\n        uf as unifield,\n        uni_number,\n        row_number() OVER (PARTITION BY for_class,uni_number ORDER BY uf) AS field_number,\n        copy_field\n    FROM\n        (\n        SELECT\n            for_class,\n            obj_id                                      AS class_uuid,\n            dup_behavior,\n            is_cascade::boolean                         AS is_cascade,\n            (dc->>'isMandatory')::boolean               AS is_mandatory,\n            jsonb_array_elements_text(dc->'uniFields')  AS uf,\n            dc->'uniFields'::text                       AS field_list,\n            row_number() OVER ( PARTITION BY for_class ORDER BY dc->'uniFields'::text) AS uni_number,\n            copy_field\n        FROM\n            (\n            SELECT\n                for_class,\n                attributes->>'dupBehavior'           AS dup_behavior,\n                (attributes->>'isCascade')           AS is_cascade,\n                jsonb_array_elements( attributes ->'dupChecking') AS dc,\n                obj_id,\n                attributes->>'copyField' as copy_field\n            FROM\n                reclada.v_class_lite vc\n            WHERE\n                attributes ->'dupChecking' is not null\n            ) a\n        ) b\n;\nANALYZE reclada.v_object_unifields;\n\nALTER SEQUENCE IF EXISTS reclada.object_id_seq CACHE 1;	2022-03-14 09:39:06.221848+00
51	50	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 50 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = obj.nam) o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\n--{REC 624\nCREATE AGGREGATE reclada.jsonb_object_agg(jsonb) (\n  SFUNC = 'jsonb_concat',\n  STYPE = jsonb,\n  INITCOND = '{}'\n);\n\ni 'function/reclada_object.get_query_condition_filter.sql'\ni 'function/reclada.jsonb_merge.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada.load_staging.sql'\n\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_unifields;\nDROP VIEW IF EXISTS reclada.v_parent_field;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_task;\nDROP VIEW IF EXISTS reclada.v_ui_active_object;\nDROP VIEW IF EXISTS reclada.v_dto_json_schema;\nDROP VIEW IF EXISTS reclada.v_component_object;\nDROP VIEW IF EXISTS reclada.v_component;\nDROP VIEW IF EXISTS reclada.v_relationship;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_class_lite;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_user;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_status;\nDROP VIEW IF EXISTS reclada.v_object_display;\n\ni 'function/reclada_object.get_jsonschema_guid.sql'\ni 'view/reclada.v_class_lite.sql'\ni 'function/reclada_object.get_guid_for_class.sql'\ni 'view/reclada.v_object_status.sql'\n\ni 'function/reclada_object.delete.sql'\ni 'view/reclada.v_object_display.sql'\ni 'function/reclada_object.need_flat.sql'\n\ni 'view/reclada.v_user.sql'\ni 'view/reclada.v_object.sql'\ni 'view/reclada.v_active_object.sql'\ni 'view/reclada.v_relationship.sql'\ni 'view/reclada.v_component.sql'\ni 'view/reclada.v_component_object.sql'\ni 'view/reclada.v_dto_json_schema.sql'\ni 'view/reclada.v_ui_active_object.sql'\ni 'view/reclada.v_task.sql'\ni 'view/reclada.v_revision.sql'\ni 'view/reclada.v_import_info.sql'\ni 'view/reclada.v_class.sql'\ni 'view/reclada.v_parent_field.sql'\ni 'view/reclada.v_object_unifields.sql'\n--REC 624}\ni 'view/reclada.v_get_duplicates_query.sql'\n\n--{REC 633\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.update.sql'\n--REC 633}\n\nDROP VIEW reclada.staging;\n\nCREATE TABLE reclada.staging(\n    data    jsonb   NOT NULL  \n);\n\ni 'trigger/load_staging.sql'\ni 'function/reclada_object.perform_trigger_function.sql'\ni 'function/reclada_object.object_insert.sql'\ni 'function/reclada_object.delete.sql'\ni 'function/reclada_object.create.sql'\ni 'view/reclada.v_trigger.sql'\ni 'view/reclada.v_db_trigger_function.sql'\n\n\n SELECT reclada.raise_notice('Begin install component db...');\n                SELECT dev.begin_install_component('db','https://gitlab.reclada.com/developers/db.git','8b83cba8da02c43762add56cdc6cda02914f1185');\n                \n-- 1\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "tag",\n        "properties": {\n            "name": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 2\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DataSource",\n        "properties": {\n            "name": {"type": "string"},\n            "uri": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 3\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "S3Config",\n        "properties": {\n            "endpointURL": {"type": "string"},\n            "regionName": {"type": "string"},\n            "accessKeyId": {"type": "string"},\n            "secretAccessKey": {"type": "string"},\n            "bucketName": {"type": "string"}\n            },\n        "required": ["accessKeyId", "secretAccessKey", "bucketName"]\n    }\n}'::jsonb);\n--{ 4 DataSet\nSELECT reclada_object.create_subclass('{\n        "class": "RecladaObject",\n        "attributes": {\n            "newClass": "DataSet",\n            "properties": {\n                "name": {"type": "string"},\n                "dataSources": {\n                    "type": "array",\n                    "items": {"type": "string"}\n                }\n            },\n            "required": ["name"]\n        }\n    }'::jsonb);\n\n        SELECT reclada_object.create('{\n            "GUID":"10c400ff-a328-450d-ae07-ce7d427d961c",\n            "class": "DataSet",\n            "attributes": {\n                "name": "defaultDataSet",\n                "dataSources": []\n            }\n        }'::jsonb);\n--} 4 DataSet\n\n-- 5\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Message",\n        "properties": {\n            "channelName": {"type": "string"},\n            "class": {"type": "string"},\n            "event": {\n                "type": "string",\n                "enum": [\n                    "create",\n                    "update",\n                    "list",\n                    "delete"\n                ]\n            },\n            "attributes": {\n                "type": "array", \n                "items": {"type": "string"}\n            }\n        },\n        "required": ["class", "channelName", "event"]\n    }\n}'::jsonb);\n\n--{ 6 Index\nSELECT reclada_object.create_subclass('{\n            "class": "RecladaObject",\n            "attributes": {\n                "newClass": "Index",\n                "properties": {\n                    "name": {"type": "string"},\n                    "method": {\n                        "type": "string",\n                        "enum ": [\n                            "btree", \n                            "hash" , \n                            "gist" , \n                            "gin"\n                        ]\n                    },\n                    "wherePredicate": {\n                        "type": "string"\n                    },\n                    "fields": {\n                        "items": {\n                            "type": "string"\n                        },\n                        "type": "array",\n                        "minContains": 1\n                    }\n                },\n                "required": ["name","fields"]\n            }\n        }'::jsonb);\n\n    select reclada_object.create('{\n            "GUID": "db0873d1-786f-4d5d-b790-5c3b3cd29baf",\n            "class": "Index",\n            "attributes": {\n                "name": "checksum_index_",\n                "fields": ["(attributes ->> ''checksum''::text)"],\n                "method": "hash",\n                "wherePredicate": "((attributes ->> ''checksum''::text) IS NOT NULL)"\n            }\n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db08d53b-c423-4e94-8b14-e73ebe98e991",\n            "class": "Index",\n            "attributes": {\n                "name": "repository_index_",\n                "fields": ["(attributes ->> ''repository''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''repository''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n        "GUID": "db05e253-7954-4610-b094-8f9925ea77b4",\n        "class": "Index",\n        "attributes": {\n                "name": "commithash_index_",\n                "fields": ["(attributes ->> ''commitHash''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''commitHash''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n        "GUID": "db02f980-cd5a-4c1a-9341-7a81713cd9d0",\n        "class": "Index",\n        "attributes": {\n                "name": "fields_index_",\n                "fields": ["(attributes ->> ''fields''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''fields''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0e400b-1da4-4823-bb80-15eb144a1639",\n            "class": "Index",\n            "attributes": {\n                    "name": "caption_index_",\n                    "fields": ["(attributes ->> ''caption''::text)"],\n                    "method": "btree",\n                    "wherePredicate": "((attributes ->> ''caption''::text) IS NOT NULL)"\n                }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db09fafb-91b1-4fe6-8e5c-1cd2d7d9225a",\n            "class": "Index",\n            "attributes": {\n                "name": "type_index",\n                "fields": ["(attributes ->> ''type''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''type''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0118e5-ea34-45dc-b72c-f16f6a628ddb",\n            "class": "Index",\n            "attributes": {\n                "name": "schema_index_",\n                "fields": ["(attributes ->> ''schema''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''schema''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db07c919-5bc0-4fec-961c-f558401d3e71",\n            "class": "Index",\n            "attributes": {\n                "name": "forclass_index_",\n                "fields": ["(attributes ->> ''forclass''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''forclass''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0184b8-556e-4f57-af12-d84066adbe31",\n            "class": "Index",\n            "attributes": {\n                "name": "revision_index",\n                "fields": ["(attributes ->> ''revision''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''revision''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0e22c0-e0d7-4b11-bf25-367a8fbdef83",\n            "class": "Index",\n            "attributes": {\n                "name": "subject_index_",\n                "fields": ["(attributes ->> ''subject''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''subject''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db05c9c7-17ce-4b36-89d7-81b0ddd26a6a",\n            "class": "Index",\n            "attributes": {\n                "name": "class_index_",\n                "fields": ["(attributes ->> ''class''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''class''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0a88c1-ac00-42e5-9caa-6007a1c948c6",\n            "class": "Index",\n                "attributes": {\n                "name": "name_index_",\n                "fields": ["(attributes ->> ''name''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''name''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0fdc46-6479-4d20-bd21-a6330905e45b",\n            "class": "Index",\n            "attributes": {\n                "name": "event_index_",\n                "fields": ["(attributes ->> ''event''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''event''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db02b45a-acfd-4448-a51a-8e7dc35bf3af",\n            "class": "Index",\n            "attributes": {\n                "name": "function_index_",\n                "fields": ["(attributes ->> ''function''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''function''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0b797a-b287-4282-b0f8-d985c7a439f4",\n            "class": "Index",\n            "attributes": {\n                "name": "login_index_",\n                "fields": ["(attributes ->> ''login''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''login''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db03c715-c0f9-43c3-940a-803aafa513e0",\n            "class": "Index",\n            "attributes": {\n                "name": "object_index_",\n                "fields": ["(attributes ->> ''object''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''object''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n\n--} 6 Index\n\n-- 7\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Component",\n        "properties": {\n            "name": {"type": "string"},\n            "commitHash": {"type": "string"},\n            "repository": {"type": "string"}\n        },\n        "required": ["name","commitHash","repository"]\n    }\n}'::jsonb);\n\n--{ 9 DTOJsonSchema\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DTOJsonSchema",\n        "properties": {\n            "schema": {"type": "object"},\n            "function": {"type": "string"}\n        },\n        "required": ["schema","function"]\n    }\n}'::jsonb);\n\n    SELECT reclada_object.create('{\n            "GUID":"db0bf6f5-7eea-4dbd-9f46-e0535f7fb299",\n            "class": "DTOJsonSchema",\n            "attributes": {\n                "function": "reclada_object.get_query_condition_filter",\n                "schema": {\n                    "id": "expr",\n                    "type": "object",\n                    "required": [\n                        "value",\n                        "operator"\n                    ],\n                    "properties": {\n                        "value": {\n                            "type": "array",\n                            "items": {\n                                "anyOf": [\n                                    {\n                                        "type": "string"\n                                    },\n                                    {\n                                        "type": "null"\n                                    },\n                                    {\n                                        "type": "number"\n                                    },\n                                    {\n                                        "$ref": "expr"\n                                    },\n                                    {\n                                        "type": "boolean"\n                                    },\n                                    {\n                                        "type": "array",\n                                        "items": {\n                                            "anyOf": [\n                                                {\n                                                    "type": "string"\n                                                },\n                                                {\n                                                    "type": "number"\n                                                }\n                                            ]\n                                        }\n                                    }\n                                ]\n                            },\n                            "minItems": 1\n                        },\n                        "operator": {\n                            "type": "string"\n                        }\n                    }\n                }\n            }\n        }'::jsonb);\n\n     SELECT reclada_object.create('{\n            "GUID":"db0ad26e-a522-4907-a41a-a82a916fdcf9",\n            "class": "DTOJsonSchema",\n            "attributes": {\n                "function": "reclada_object.list",\n                "schema": {\n                    "type": "object",\n                    "anyOf": [\n                        {\n                            "required": [\n                                "transactionID"\n                            ]\n                        },\n                        {\n                            "required": [\n                                "class"\n                            ]\n                        },\n                        {\n                            "required": [\n                                "filter"\n                            ]\n                        }\n                    ],\n                    "properties": {\n                        "class": {\n                            "type": "string"\n                        },\n                        "limit": {\n                            "anyOf": [\n                                {\n                                    "enum": [\n                                        "ALL"\n                                    ],\n                                    "type": "string"\n                                },\n                                {\n                                    "type": "integer"\n                                }\n                            ]\n                        },\n                        "filter": {\n                            "type": "object"\n                        },\n                        "offset": {\n                            "type": "integer"\n                        },\n                        "orderBy": {\n                            "type": "array",\n                            "items": {\n                                "type": "object",\n                                "required": [\n                                    "field"\n                                ],\n                                "properties": {\n                                    "field": {\n                                        "type": "string"\n                                    },\n                                    "order": {\n                                        "enum": [\n                                            "ASC",\n                                            "DESC"\n                                        ],\n                                        "type": "string"\n                                    }\n                                }\n                            }\n                        },\n                        "transactionID": {\n                            "type": "integer"\n                        }\n                    }\n                }\n            }\n            \n        }'::jsonb);\n--} 9 DTOJsonSchema\n\n-- 10\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n\n        "dupBehavior": "Replace",\n        "dupChecking": [\n            {\n                "isMandatory": true,\n                "uniFields": [\n                    "uri"\n                ]\n            },\n            {\n                "isMandatory": true,\n                "uniFields": [\n                    "checksum"\n                ]\n            }\n        ],\n        "isCascade": true,\n\n        "newClass": "File",\n        "properties": {\n            "uri": {"type": "string"},\n            "name": {"type": "string"},\n            "mimeType": {"type": "string"},\n            "checksum": {"type": "string"}\n        },\n        "required": ["uri","mimeType","name"]\n    }\n}'::jsonb);\n\n--{ 11 User\nSELECT reclada_object.create_subclass('{\n    "GUID":"db0db7c0-9b25-4af0-8013-d2d98460cfff",\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "User",\n        "properties": {\n            "login": {"type": "string"}\n        },\n        "required": ["login"]\n    }\n}'::jsonb);\n\n    select reclada_object.create('{\n            "GUID": "db0789c1-1b4e-4815-b70c-4ef060e90884",\n            "class": "User",\n            "attributes": {\n                "login": "dev"\n            }\n        }'::jsonb);\n--} 11 User\n\n-- 12\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "ImportInfo",\n        "properties": {\n            "tranID": {"type": "number"},\n            "name": {"type": "string"}\n        },\n        "required": ["tranID","name"]\n    }\n}'::jsonb);\n-- 13\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Asset",\n        "properties": {\n            "name": {"type": "string"},\n            "uri": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 14\nSELECT reclada_object.create_subclass('{\n    "class": "Asset",\n    "attributes": {\n        "newClass": "DBAsset"\n    }\n}'::jsonb);\n-- 15\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "revision",\n        "properties": {\n            "branch": {"type": "string"},\n            "user": {"type": "string"},\n            "num": {"type": "number"},\n            "dateTime": {"type": "string"}\n        },\n        "required": ["dateTime"]\n    }\n}'::jsonb);\n\n--{ 16 ObjectDisplay\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "ObjectDisplay",\n        "$defs": {\n            "displayType": {\n                "properties": {\n                    "orderColumn": {\n                        "items": {\n                            "type": "string"\n                        },\n                        "type": "array"\n                    },\n                    "orderRow": {\n                        "items": {\n                            "patternProperties": {\n                                "^{.*}$": {\n                                    "enum": [\n                                        "ASC",\n                                        "DESC"\n                                    ],\n                                    "type": "string"\n                                }\n                            },\n                            "type": "object"\n                        },\n                        "type": "array"\n                    }\n                },\n                "required": [\n                    "orderColumn",\n                    "orderRow"\n                ],\n                "type": "object"\n            }\n        },\n        "properties": {\n            "caption": {\n                "type": "string"\n            },\n            "card": {\n                "$ref": "#/$defs/displayType"\n            },\n            "classGUID": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "flat": {\n                "type": "bool"\n            },\n            "list": {\n                "$ref": "#/$defs/displayType"\n            },\n            "preview": {\n                "$ref": "#/$defs/displayType"\n            },\n            "table": {\n                "$ref": "#/$defs/displayType"\n            }\n        },\n        "required": [\n            "classGUID",\n            "caption"\n        ]\n    }\n}'::jsonb);\n\n    SELECT reclada_object.create(('{\n        "GUID": "db09dd42-f2a2-4e34-90ea-a6e5f5ea6dff",\n        "class": "ObjectDisplay",\n        "attributes": {\n            "card": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "list": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "table": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ],\n                "{GUID}:string": {\n                    "width": 250,\n                    "caption": "GUID",\n                    "displayCSS": "GUID"\n                },\n                "{status}:string": {\n                    "width": 250,\n                    "caption": "Status",\n                    "displayCSS": "status"\n                },\n                "{createdTime}:string": {\n                    "width": 250,\n                    "caption": "Created time",\n                    "displayCSS": "createdTime"\n                },\n                "{transactionID}:number": {\n                    "width": 250,\n                    "caption": "Transaction",\n                    "displayCSS": "transactionID"\n                },\n                "{attributes,tags}:array": {\n                    "items": {\n                        "class": "e12e729b-ac44-45bc-8271-9f0c6d4fa27b",\n                        "behavior": "preview",\n                        "displayCSS": "link"\n                    },\n                    "width": 250,\n                    "caption": "Tags",\n                    "displayCSS": "arrayLink"\n                },\n                "{attributes,name}:string": {\n                    "width": 250,\n                    "caption": "File name",\n                    "behavior": "preview",\n                    "displayCSS": "name"\n                },\n                "{attributes,checksum}:string": {\n                    "width": 250,\n                    "caption": "Checksum",\n                    "displayCSS": "checksum"\n                },\n                "{attributes,mimeType}:string": {\n                    "width": 250,\n                    "caption": "Mime type",\n                    "displayCSS": "mimeType"\n                }\n            },\n            "caption": "Files",\n            "preview": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "classGUID": "'|| (SELECT obj_id\n                                FROM reclada.v_class\n                                    WHERE for_class = 'File'\n                                    ORDER BY ID DESC\n                                    LIMIT 1 ) ||'"\n        }\n    }')::jsonb);\n\n--} 16 ObjectDisplay\n\n--{ 17 View\nSELECT reclada_object.create_subclass('{\n        "GUID":"db09dcaa-fc90-4760-af68-f855cbe9c2b0",\n        "class": "RecladaObject",\n        "attributes": {\n            "newClass": "View",\n            "properties": {\n                "name": {"type": "string"},\n                "query": {"type": "string"}\n            },\n            "required": ["name","query"]\n        }\n    }'::jsonb);\n--} 17 View\n\n--{ 18 Function\nSELECT reclada_object.create_subclass('{\n        "GUID":"db0d8ccd-a06e-46c3-9836-a8b4b68f3cd4",\n        "class": "RecladaObject",\n        "attributes": {\n            "newClass": "Function",\n            "$defs": {\n                "declare":{\n                    "type":"array",\n                    "items": {\n                        "type": "object",\n                        "properties":{\n                            "name":{"type": "string"},\n                            "type":{\n                                "type": "string",\n                                "enum": [\n                                    "uuid" ,\n                                    "jsonb",\n                                    "text" ,\n                                    "bigint"\n                                ]\n                            }\n                        },\n                        "required": ["name","type"]\n                    }\n                }\n            },\n            "properties": {\n                "name": {"type": "string"},\n                "parameters": { "$ref": "#/$defs/declare" },\n                "returns": {\n                    "type": "string",\n                    "enum": [\n                        "void",\n                        "uuid" ,\n                        "jsonb",\n                        "text" ,\n                        "bigint"\n                    ]\n                },\n                "declare": { "$ref": "#/$defs/declare" },\n                "body": {"type": "string"}\n            },\n            "required": ["name","returns","body"]\n        }\n    }'::jsonb);\n--} 18 Function\n\n--{ 19 DBTriggerFunction\nSELECT reclada_object.create_subclass('{\n        "GUID":"db0635d4-33be-4b5c-8af4-c90038665b7d",\n        "class": "Function",\n        "attributes": {\n            "newClass": "DBTriggerFunction",\n            "properties": {\n                "parameters": {\n                    "type":"array",\n                    "minItems": 1,\n                    "maxItems": 1,\n                    "items": {\n                        "type": "object",\n                        "properties":{\n                            "name":{\n                                "type": "string", \n                                "enum": ["object_id"]\n                            },\n                            "type":{\n                                "type": "string",\n                                "enum": ["bigint"]\n                            }\n                        },\n                        "required": ["name","type"]\n                    }\n                },\n                "returns": {\n                    "type": "string",\n                    "enum": [\n                        "void"]\n                }\n            },\n            "required": ["parameters"]\n        }\n    }'::jsonb);\n--} 19 DBTriggerFunction\n\n\n--{ 20 Trigger\nSELECT reclada_object.create_subclass('{\n    "GUID":"db05bc71-4f3c-4276-9b97-c9e83f21c813",\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DBTrigger",\n        "properties": {\n            "name": {"type": "string"},\n            "action": {\n                "type": "string",\n                "enum": [\n                    "insert",\n                    "delete"\n                ]\n            },\n            "forClasses": {\n                "type": "array",\n                "items": {"type": "string"}\n            },\n            "function":{\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            }\n        },\n        "required": ["name","action","forClasses","function"]\n    }\n }'::jsonb);\n--} 20 Trigger\n                SELECT dev.finish_install_component();\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, current version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nDROP function IF EXISTS reclada_object.get_query_condition_filter ;\nCREATE OR REPLACE FUNCTION reclada_object.get_query_condition_filter(data jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _count   INT;\r\n    _res     TEXT;\r\n    _f_name TEXT = 'reclada_object.get_query_condition_filter';\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n    -- TODO: to change VOLATILE -> IMMUTABLE, remove CREATE TEMP TABLE\r\n    CREATE TEMP TABLE mytable AS\r\n        SELECT  res.lvl              AS lvl         ,\r\n                res.rn               AS rn          ,\r\n                res.idx              AS idx         ,\r\n                res.prev             AS prev        ,\r\n                res.val              AS val         ,\r\n                res.parsed           AS parsed      ,\r\n                coalesce(\r\n                    po.inner_operator,\r\n                    op.operator\r\n                )                   AS op           ,\r\n                coalesce\r\n                (\r\n                    iop.input_type,\r\n                    op.input_type\r\n                )                   AS input_type   ,\r\n                case\r\n                    when iop.input_type is not NULL\r\n                        then NULL\r\n                    else\r\n                        op.output_type\r\n                end                 AS output_type  ,\r\n                po.operator         AS po           ,\r\n                po.input_type       AS po_input_type,\r\n                iop.brackets        AS po_inner_brackets\r\n            FROM reclada_object.parse_filter(data) res\r\n            LEFT JOIN reclada.v_filter_available_operator op\r\n                ON res.op = op.operator\r\n            LEFT JOIN reclada_object.parse_filter(data) p\r\n                on  p.lvl = res.lvl-1\r\n                    and res.prev = p.rn\r\n            LEFT JOIN reclada.v_filter_available_operator po\r\n                on po.operator = p.op\r\n            LEFT JOIN reclada.v_filter_inner_operator iop\r\n                on iop.operator = po.inner_operator;\r\n\r\n    PERFORM reclada.raise_exception('Operator is not allowed ', _f_name)\r\n        FROM mytable t\r\n            WHERE t.op IS NULL;\r\n\r\n\r\n    UPDATE mytable u\r\n        SET parsed = to_jsonb(p.v)\r\n            FROM mytable t\r\n            JOIN LATERAL\r\n            (\r\n                SELECT  t.parsed #>> '{}' v\r\n            ) as pt1\r\n                ON TRUE\r\n            LEFT JOIN reclada.v_filter_mapping fm\r\n                ON pt1.v = fm.pattern\r\n            JOIN LATERAL \r\n            (\r\n                SELECT replace(pt1.v,'{attributes,','{') as v\r\n            ) as pt\r\n                ON TRUE\r\n            JOIN LATERAL \r\n            (\r\n                SELECT CASE\r\n                        WHEN t.op LIKE '%<@%' AND t.idx=1 AND jsonb_typeof(t.parsed)='string'\r\n                            THEN format('(COALESCE(attrs #> ''%s'', default_value -> (''%s'')::text)) != ''[]''::jsonb\r\n                            AND (COALESCE(attrs #> ''%s'', default_value -> (''%s'')::text)) != ''{}''::jsonb\r\n                            AND (COALESCE(attrs #> ''%s'', default_value -> (''%s'')::text))',\r\n                            pt.v, pt.v, pt.v, pt.v, pt.v, pt.v)\r\n                        WHEN fm.repl is not NULL\r\n                            then\r\n                                case\r\n                                    when t.input_type in ('TEXT')\r\n                                        then fm.repl || '::TEXT'\r\n                                    else '(''"''||' ||fm.repl ||'||''"'')::jsonb' -- don't use FORMAT (concat null)\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) in ('number', 'boolean')\r\n                            then\r\n                                case\r\n                                    when t.input_type in ('NUMERIC','INT')\r\n                                        then pt.v\r\n                                    else '''' || pt.v || '''::jsonb'\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'string'\r\n                            then\r\n                                case\r\n                                    WHEN pt.v LIKE '{%}'\r\n                                        THEN\r\n                                            case\r\n                                                when t.input_type = 'TEXT'\r\n                                                    then format('(COALESCE(attrs #>> ''%s'', default_value ->> (''%s'')::text))', pt.v, pt.v)\r\n                                                when t.input_type = 'JSONB' or t.input_type is null\r\n                                                    then format('(COALESCE(attrs #> ''%s'', default_value -> (''%s'')::text))', pt.v, pt.v)\r\n                                                else\r\n                                                    format('(COALESCE(attrs #>> ''%s'', default_value ->> (''%s'')::text))::', pt.v, pt.v) || t.input_type\r\n                                            end\r\n                                    when t.input_type = 'TEXT'\r\n                                        then ''''||REPLACE(pt.v,'''','''''')||''''\r\n                                    when t.input_type = 'JSONB' or t.input_type is null\r\n                                        then '''"'||REPLACE(pt.v,'''','''''')||'"''::jsonb'\r\n                                    else ''''||REPLACE(pt.v,'''','''''')||'''::'||t.input_type\r\n                                end\r\n                        WHEN jsonb_typeof(t.parsed) = 'null'\r\n                            then 'null'\r\n                        WHEN jsonb_typeof(t.parsed) = 'array'\r\n                            then ''''||REPLACE(pt.v,'''','''''')||'''::jsonb'\r\n                        ELSE\r\n                            pt.v\r\n                    END AS v\r\n            ) as p\r\n                ON TRUE\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND t.parsed IS NOT NULL;\r\n\r\n    update mytable u\r\n        set op = CASE \r\n                    when f.btwn\r\n                        then ' BETWEEN '\r\n                    else u.op -- f.inop\r\n                end,\r\n            parsed = format(vb.operand_format,u.parsed)::jsonb\r\n        FROM mytable t\r\n        join lateral\r\n        (\r\n            select  t.op like ' %/BETWEEN ' btwn, \r\n                    t.po_inner_brackets is not null inop\r\n        ) f \r\n            on true\r\n        join reclada.v_filter_between vb\r\n            on t.op = vb.operator\r\n            WHERE t.lvl = u.lvl\r\n                AND t.rn = u.rn\r\n                AND (f.btwn or f.inop);\r\n\r\n\r\n    INSERT INTO mytable (lvl,rn)\r\n        VALUES (0,0);\r\n\r\n    _count := 1;\r\n\r\n    WHILE (_count>0) LOOP\r\n        WITH r AS \r\n        (\r\n            UPDATE mytable\r\n                SET parsed = to_json(t.converted)::JSONB \r\n                FROM \r\n                (\r\n                    SELECT     \r\n                            res.lvl-1 lvl,\r\n                            res.prev rn,\r\n                            res.op,\r\n                            1 q,\r\n                            case \r\n                                when not res.po_inner_brackets \r\n                                    then array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) \r\n                                else\r\n                                    CASE COUNT(1) \r\n                                        WHEN 1\r\n                                            THEN \r\n                                                CASE res.output_type\r\n                                                    when 'NUMERIC'\r\n                                                        then format('(%s %s)::TEXT::JSONB', res.op, min(res.parsed #>> '{}') )\r\n                                                    else \r\n                                                        format('(%s %s)', res.op, min(res.parsed #>> '{}') )\r\n                                                end\r\n                                        ELSE\r\n                                            CASE \r\n                                                when res.output_type = 'TEXT'\r\n                                                    then '(''"''||'||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||'||''"'')::JSONB'\r\n                                                when res.output_type in ('NUMERIC','INT')\r\n                                                    then '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')::TEXT::JSONB'\r\n                                                else\r\n                                                    '('||array_to_string(array_agg(res.parsed #>> '{}' ORDER BY res.rn), res.op) ||')'\r\n                                            end\r\n                                    end\r\n                            end AS converted\r\n                        FROM mytable res \r\n                            WHERE res.parsed IS NOT NULL\r\n                                AND res.lvl = (SELECT max(lvl)+1 FROM mytable WHERE parsed IS NULL)\r\n                            GROUP BY  res.prev, res.op, res.lvl, res.input_type, res.output_type, res.po_inner_brackets\r\n                ) t\r\n                WHERE\r\n                    t.lvl = mytable.lvl\r\n                        AND t.rn = mytable.rn\r\n                RETURNING 1\r\n        )\r\n            SELECT COUNT(1) \r\n                FROM r\r\n                INTO _count;\r\n    END LOOP;\r\n    \r\n    SELECT parsed #>> '{}' \r\n        FROM mytable\r\n            WHERE lvl = 0 AND rn = 0\r\n        INTO _res;\r\n    -- perform reclada.raise_notice( _res);\r\n    DROP TABLE mytable;\r\n    RETURN _res;\r\nEND \r\n$function$\n;\nDROP function IF EXISTS reclada.jsonb_merge ;\n\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false, ver text DEFAULT '1'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    _class              text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    _exec_text          text;\r\n    _pre_query          text;\r\n    _from               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             jsonb;\r\n    _object_display     jsonb;\r\n    _order_row          jsonb;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    if ver = '1' then\r\n        tran_id := (data->>'transactionID')::bigint;\r\n        _class := data->>'class';\r\n    elseif ver = '2' then\r\n        tran_id := (data->>'{transactionID}')::bigint;\r\n        _class := data->>'{class}';\r\n    end if;\r\n    _filter = data->'filter';\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) then\r\n        \r\n        select (vod.table #> '{orderRow}') as orderRow\r\n        \tfrom reclada.v_object_display vod\r\n        \twhere vod.class_guid = (reclada_object.get_schema(_class)#>>'{GUID}')::uuid\r\n        \tinto _order_row;\r\n        if _order_row is not null then     \r\n        \tselect '[' || string_agg(('{"field": "' || obf.field || '", ' || '"order": ' || obf.order_by || '}'), ', ') || ']'\r\n\t\t\tfrom(\r\n \t \t\t\t select je.value as order_by, \r\n \t \t\t\t \t\tsplit_part(je.key, ':', 1) as field\r\n \t \t\t\t \tfrom jsonb_array_elements(_order_row) jae\r\n \t \t\t\t \tcross join jsonb_each(jae.value) je\r\n \t \t\t) obf\r\n\t\t\t\tinto order_by_jsonb;\r\n    \tELSE\r\n        \torder_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n        end if;\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(\r\n            E'obj.data#>''{%s}'' %s', \r\n            case ver\r\n                when '2'\r\n                    then REPLACE(REPLACE(T.value->>'field','{', '"{' ),'}', '}"' )\r\n                else\r\n                    T.value->>'field'\r\n            end,\r\n            COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    \r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSEIF ver = '1' then\r\n        class_uuid := reclada.try_cast_uuid(_class);\r\n\r\n        IF (class_uuid IS NULL) THEN\r\n            SELECT v.obj_id\r\n                FROM reclada.v_class v\r\n                    WHERE _class = v.for_class\r\n                    ORDER BY v.version DESC\r\n                    limit 1 \r\n            INTO class_uuid;\r\n            IF (class_uuid IS NULL) THEN\r\n                perform reclada.raise_exception(\r\n                        format('Class not found: %s', _class),\r\n                        _f_name\r\n                    );\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', _class) AS condition\r\n                        where _class is not null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                            and _class is null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    -- TODO: add ELSE\r\n    IF ver = '2' THEN\r\n        _pre_query := (select val from reclada.v_ui_active_object);\r\n        _from := 'res AS obj';\r\n        _pre_query := REPLACE(_pre_query, '#@#@#where#@#@#'  , query_conditions);\r\n        _pre_query := REPLACE(_pre_query, '#@#@#orderby#@#@#', order_by        );\r\n        order_by :=  REPLACE(order_by, '{', '{"{');\r\n        order_by :=  REPLACE(order_by, '}', '}"}'); --obj.data#>'{some_field}'  -->  obj.data#>'{"{some_field}"}'\r\n\r\n    ELSE\r\n        _pre_query := '';\r\n        _from := 'reclada.v_active_object AS obj\r\n                            WHERE #@#@#where#@#@#';\r\n        _from := REPLACE(_from, '#@#@#where#@#@#', query_conditions  );\r\n    END IF;\r\n    _exec_text := _pre_query ||\r\n                'SELECT to_jsonb(array_agg(t.data))\r\n                    FROM \r\n                    (\r\n                        SELECT obj.data\r\n                            FROM '\r\n                            || _from\r\n                            || ' \r\n                            ORDER BY #@#@#orderby#@#@#'\r\n                            || case \r\n                                when ver = '2' \r\n                                    then ''\r\n                                else\r\n                                '\r\n                                OFFSET #@#@#offset#@#@#\r\n                                LIMIT #@#@#limit#@#@#'\r\n                            end\r\n                            || '\r\n                    ) AS t';\r\n    _exec_text := REPLACE(_exec_text, '#@#@#orderby#@#@#'  , order_by          );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#offset#@#@#'   , offset_           );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#limit#@#@#'    , limit_            );\r\n    -- RAISE NOTICE 'conds: %', _exec_text;\r\n\r\n    EXECUTE _exec_text\r\n        INTO objects;\r\n    objects := coalesce(objects,'[]'::jsonb);\r\n    IF gui THEN\r\n\r\n        if ver = '2' then\r\n            class_uuid := coalesce(class_uuid, (objects#>>'{0,"{class}"}')::uuid);\r\n            if class_uuid is not null then\r\n                _class :=   (\r\n                                select cl.for_class \r\n                                    from reclada.v_class_lite cl\r\n                                        where class_uuid = cl.obj_id\r\n                                            limit 1\r\n                            );\r\n\r\n                _exec_text := '\r\n                with \r\n                d as ( \r\n                    select id_unique_object\r\n                        FROM reclada.v_active_object obj \r\n                        JOIN reclada.unique_object_reclada_object as uoc\r\n                            on uoc.id_reclada_object = obj.id\r\n                                and #@#@#where#@#@#\r\n                        group by id_unique_object\r\n                ),\r\n                dd as (\r\n                    select distinct \r\n                            ''{''||f.path||''}:''||f.json_type v,\r\n                            f.json_type\r\n                        FROM d \r\n                        JOIN reclada.unique_object as uo\r\n                            on d.id_unique_object = uo.id\r\n                        JOIN reclada.field f\r\n                            on f.id = ANY (uo.id_field)\r\n                    UNION\r\n                    SELECT  pattern||'':''|| t.v,\r\n                            t.v\r\n                    FROM reclada.v_filter_mapping vfm\r\n                    CROSS JOIN LATERAL \r\n                    (\r\n                        SELECT  CASE \r\n                                    WHEN vfm.pattern=''{transactionID}'' \r\n                                        THEN ''number'' \r\n                                    ELSE ''string'' \r\n                                END as v\r\n                    ) t\r\n                ),\r\n                on_data as \r\n                (\r\n                    select  jsonb_object_agg(\r\n                                t.v, \r\n                                replace(dd.template,''#@#attrname#@#'',t.v)::jsonb \r\n                            ) t\r\n                        from dd as t\r\n                        JOIN reclada.v_default_display dd\r\n                            on t.json_type = dd.json_type\r\n                )\r\n                select jsonb_set(templ.v,''{table}'', od.t || coalesce(d.table,coalesce(d.table,templ.v->''table'')))\r\n                    from on_data od\r\n                    join (\r\n                        select replace(template,''#@#classname#@#'','''|| _class ||''')::jsonb v\r\n                            from reclada.v_default_display \r\n                                where json_type = ''ObjectDisplay''\r\n                                    limit 1\r\n                    ) templ\r\n                        on true\r\n                    left join reclada.v_object_display d\r\n                        on d.class_guid::text = '''|| coalesce( class_uuid::text, '' ) ||'''';\r\n\r\n                _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );\r\n                -- raise notice '%',_exec_text;\r\n                EXECUTE _exec_text\r\n                    INTO _object_display;\r\n            end if;\r\n        end if;\r\n\r\n        _exec_text := '\r\n            SELECT  COUNT(1),\r\n                    TO_CHAR(\r\n                        MAX(\r\n                            GREATEST(\r\n                                obj.created_time, \r\n                                (\r\n                                    SELECT  TO_TIMESTAMP(\r\n                                                MAX(date_time),\r\n                                                ''YYYY-MM-DD hh24:mi:ss.US TZH''\r\n                                            )\r\n                                        FROM reclada.v_revision vr\r\n                                            WHERE vr.obj_id = UUID(obj.attrs ->>''revision'')\r\n                                )\r\n                            )\r\n                        ),\r\n                        ''YYYY-MM-DD hh24:mi:ss.MS TZH''\r\n                    )\r\n                    FROM reclada.v_active_object obj \r\n                        where #@#@#where#@#@#';\r\n\r\n        _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );\r\n        -- raise notice '%',_exec_text;\r\n        EXECUTE _exec_text\r\n            INTO number_of_objects, last_change;\r\n        \r\n        IF _object_display IS NOT NULL then\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects,\r\n                    'display', _object_display\r\n                );\r\n        ELSE\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects\r\n            );\r\n        end if;\r\n    ELSE\r\n        \r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\n\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_unifields;\nDROP VIEW IF EXISTS reclada.v_parent_field;\nDROP VIEW IF EXISTS reclada.v_class;\nDROP VIEW IF EXISTS reclada.v_import_info;\nDROP VIEW IF EXISTS reclada.v_revision;\nDROP VIEW IF EXISTS reclada.v_task;\nDROP VIEW IF EXISTS reclada.v_ui_active_object;\nDROP VIEW IF EXISTS reclada.v_dto_json_schema;\nDROP VIEW IF EXISTS reclada.v_component_object;\nDROP VIEW IF EXISTS reclada.v_component;\nDROP VIEW IF EXISTS reclada.v_relationship;\nDROP VIEW IF EXISTS reclada.v_db_trigger_function;\nDROP VIEW IF EXISTS reclada.v_trigger;\nDROP VIEW IF EXISTS reclada.v_active_object;\nDROP VIEW IF EXISTS reclada.v_object;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_class_lite;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_user;\nDROP MATERIALIZED VIEW IF EXISTS reclada.v_object_status;\nDROP VIEW IF EXISTS reclada.v_object_display;\nDROP AGGREGATE IF EXISTS reclada.jsonb_object_agg(jsonb);\n\nDROP function IF EXISTS reclada_object.get_jsonschema_guid ;\nCREATE OR REPLACE FUNCTION reclada_object.get_jsonschema_guid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT class\r\n        FROM reclada.object o\r\n            where o.GUID = \r\n                (\r\n                    select class \r\n                        from reclada.object \r\n                            where class is not null \r\n                    limit 1\r\n                )\r\n$function$\n;\n\n\nCREATE MATERIALIZED VIEW reclada.v_class_lite\nAS\nWITH RECURSIVE\nobjects_schemas AS (\n    SELECT  obj.id,\n            obj.GUID AS obj_id,\n            obj.attributes->>'forClass' AS for_class,\n            (attributes->>'version')::bigint AS version,\n            obj.created_time,\n            obj.attributes,\n            obj.status\n\t    FROM reclada.object obj\n   \t    WHERE class = reclada_object.get_jsonschema_guid()\n),\npaths_to_default AS\n(\n    SELECT   ('{'||row_attrs_base.key||'}')::text[] AS path_head,\n             row_attrs_base.value AS path_tail,\n             o.obj_id\n        FROM objects_schemas o\n        CROSS JOIN LATERAL jsonb_each(o.attributes) row_attrs_base\n        WHERE jsonb_typeof(row_attrs_base.value) = 'object'\n            AND attributes::text LIKE '%default%'\n    UNION ALL\n    SELECT   p.path_head || row_attrs_rec.key AS path_head, -- {schema,properties,nested_1,nested_2,nested_3}\n             row_attrs_rec.value AS path_tail, ---{"type": "integer", "default": 100}\n             p.obj_id\n       FROM paths_to_default p\n       CROSS JOIN LATERAL jsonb_each(p.path_tail) row_attrs_rec\n       WHERE jsonb_typeof(row_attrs_rec.value) = 'object'\n),\ntmp AS\n(\n    SELECT\n            format('"%s":%s',\n                  (t.path_head[array_position(t.path_head, 'properties') + 1 : ])::text, -- {schema,properties,nested_1,nested_2,nested_3} -> {nested_1,nested_2,nested_3}\n                  t.path_tail->'default'\n            )\n             AS default_jsonb,\n            t.obj_id\n        FROM paths_to_default t\n        WHERE t.path_tail->'default' IS NOT NULL\n),\ndefault_field AS\n(\n    SELECT   format('{%s}', string_agg(default_jsonb, ','))::jsonb AS default_value,\n             obj_id\n        FROM tmp\n        GROUP BY obj_id\n)\nSELECT\n        obj.id,\n        obj.obj_id,\n        obj.attributes->>'forClass' AS for_class,\n        (attributes->>'version')::bigint AS version,\n        obj.created_time,\n        obj.attributes,\n        obj.status,\n        default_value\n    FROM objects_schemas obj\n        LEFT JOIN default_field def\n        ON def.obj_id = obj.obj_id;\n\nANALYZE reclada.v_class_lite;\n\n\nDROP function IF EXISTS reclada_object.get_guid_for_class ;\nCREATE OR REPLACE FUNCTION reclada_object.get_guid_for_class(class text)\n RETURNS TABLE(obj_id uuid)\n LANGUAGE sql\n STABLE\nAS $function$\r\n    SELECT obj_id\r\n        FROM reclada.v_class_lite\r\n            WHERE for_class = class\r\n$function$\n;\n\nCREATE MATERIALIZED VIEW reclada.v_object_status\nAS\n    SELECT  obj.id            ,\n            obj.GUID as obj_id,\n            obj.attributes->>'caption' as caption,\n            obj.created_time  ,\n            obj.attributes as attrs\n\tFROM reclada.object obj\n   \tWHERE class in (select reclada_object.get_guid_for_class('ObjectStatus'));\n--        and status = reclada_object.get_active_status_obj_id();\nANALYZE reclada.v_object_status;\n\n\nCREATE MATERIALIZED VIEW reclada.v_user\nAS\n    SELECT  obj.id            ,\n            obj.GUID as obj_id,\n            obj.attributes->>'login' as login,\n            obj.created_time  ,\n            obj.attributes as attrs\n\tFROM reclada.object obj\n   \tWHERE class in (select reclada_object.get_guid_for_class('User'))\n        and status = reclada_object.get_active_status_obj_id();\nANALYZE reclada.v_user;\n\n\n\nDROP function IF EXISTS reclada_object.delete ;\nCREATE OR REPLACE FUNCTION reclada_object.delete(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_obj_id              uuid;\r\n    tran_id               bigint;\r\n    _class_name           text;\r\n    _class_name_from_uuid text;\r\n    _uniFields_index_name text;\r\n    _class_uuid           uuid;\r\n    list_id               bigint[];\r\n    _list_class_name      text[];\r\n    _for_class            text;\r\n    _exec_text            text;\r\n    _attrs                jsonb;\r\nBEGIN\r\n\r\n    v_obj_id := data->>'GUID';\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    _class_name := data->>'class';\r\n\r\n    IF (v_obj_id IS NULL AND _class_name IS NULL AND tran_id IS NULl) THEN\r\n        RAISE EXCEPTION 'Could not delete object with no GUID, class and transactionID';\r\n    END IF;\r\n\r\n    _class_uuid := reclada.try_cast_uuid(_class_name);\r\n    IF _class_uuid IS NOT NULL THEN\r\n        SELECT v.for_class \r\n        FROM reclada.v_class_lite v\r\n        WHERE _class_uuid = v.obj_id\r\n            INTO _class_name_from_uuid;\r\n    END IF;\r\n\r\n    WITH t AS\r\n    (    \r\n        UPDATE reclada.object u\r\n            SET status = reclada_object.get_archive_status_obj_id()\r\n            FROM reclada.object o\r\n                LEFT JOIN\r\n                (   SELECT obj_id FROM reclada_object.get_guid_for_class(_class_name)\r\n                    UNION SELECT _class_uuid WHERE _class_uuid IS NOT NULL\r\n                ) c ON o.class = c.obj_id\r\n                WHERE u.id = o.id AND\r\n                (\r\n                    (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                )\r\n                    AND o.status != reclada_object.get_archive_status_obj_id()\r\n                    RETURNING o.id\r\n    ) \r\n        SELECT\r\n            array\r\n            (\r\n                SELECT t.id FROM t\r\n            )\r\n        INTO list_id;\r\n\r\n    SELECT array_to_json\r\n    (\r\n        array\r\n        (\r\n            SELECT o.data\r\n            FROM reclada.v_object o\r\n            WHERE o.id IN (SELECT unnest(list_id))\r\n        )\r\n    )::jsonb\r\n    INTO data;\r\n\r\n\r\n    SELECT string_agg('DROP INDEX reclada.'||(attrs->>'name')||';',' ')\r\n        FROM reclada.v_object o\r\n        WHERE o.id IN (SELECT unnest(list_id))\r\n            AND o.class_name = 'Index'\r\n        into _exec_text;\r\n    \r\n    if _exec_text is not null then\r\n        EXECUTE _exec_text;\r\n    end if;\r\n\r\n\r\n    IF (jsonb_array_length(data) <= 1) THEN\r\n        data := data->0;\r\n    END IF;\r\n    \r\n    IF (data IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not delete object, no such GUID';\r\n    END IF;\r\n\r\n    SELECT array_agg(distinct class_name)\r\n    FROM reclada.v_object vo\r\n    WHERE class_name IN ('jsonschema','User','ObjectStatus')\r\n        AND id = ANY(list_id)\r\n        INTO _list_class_name;\r\n    \r\n    PERFORM reclada_object.refresh_mv(cn)\r\n        FROM unnest( _list_class_name ) AS cn;\r\n\r\n    PERFORM reclada_notification.send_object_notification('delete', data);\r\n\r\n    RETURN data;\r\nEND;\r\n$function$\n;\nDROP view IF EXISTS reclada.v_object_display ;\nCREATE OR REPLACE VIEW reclada.v_object_display\nAS\n SELECT obj.id,\n    obj.guid,\n    (obj.attributes ->> 'classGUID'::text)::uuid AS class_guid,\n    obj.attributes ->> 'caption'::text AS caption,\n    obj.attributes -> 'table'::text AS "table",\n    obj.attributes -> 'card'::text AS card,\n    obj.attributes -> 'preview'::text AS preview,\n    obj.attributes -> 'list'::text AS list,\n    obj.created_time,\n    obj.attributes,\n    obj.status\n   FROM object obj\n  WHERE (obj.class IN ( SELECT reclada_object.get_guid_for_class('ObjectDisplay'::text) AS get_guid_for_class)) AND obj.status = reclada_object.get_active_status_obj_id();\nDROP function IF EXISTS reclada_object.need_flat ;\nCREATE OR REPLACE FUNCTION reclada_object.need_flat(_class_name text)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\r\n    select exists\r\n        (\r\n            select true as r\r\n                from reclada.v_object_display d\r\n                join reclada_object.get_guid_for_class(_class_name) tf\r\n                    on tf.obj_id = d.class_guid\r\n                where d.table is not null\r\n        )\r\n$function$\n;\n\nDROP view IF EXISTS reclada.v_object ;\nCREATE OR REPLACE VIEW reclada.v_object\nAS\n SELECT t.id,\n    t.guid AS obj_id,\n    t.class,\n    ( SELECT (r.attributes ->> 'num'::text)::bigint AS num\n           FROM object r\n          WHERE (r.class IN ( SELECT reclada_object.get_guid_for_class('revision'::text) AS get_guid_for_class)) AND r.guid = NULLIF(t.attributes ->> 'revision'::text, ''::text)::uuid\n         LIMIT 1) AS revision_num,\n    os.caption AS status_caption,\n    NULLIF(t.attributes ->> 'revision'::text, ''::text)::uuid AS revision,\n    t.created_time,\n    t.attributes AS attrs,\n    cl.for_class AS class_name,\n    cl.default_value,\n    (( SELECT json_agg(tmp.*) -> 0\n           FROM ( SELECT t.guid AS "GUID",\n                    t.class,\n                    os.caption AS status,\n                    t.attributes,\n                    t.transaction_id AS "transactionID",\n                    t.parent_guid AS "parentGUID",\n                    t.created_by AS "createdBy",\n                    t.created_time AS "createdTime") tmp))::jsonb AS data,\n    u.login AS login_created_by,\n    t.created_by,\n    t.status,\n    t.transaction_id,\n    t.parent_guid\n   FROM object t\n     LEFT JOIN v_object_status os ON t.status = os.obj_id\n     LEFT JOIN v_user u ON u.obj_id = t.created_by\n     LEFT JOIN v_class_lite cl ON cl.obj_id = t.class;\nDROP view IF EXISTS reclada.v_object_display ;\nCREATE OR REPLACE VIEW reclada.v_object_display\nAS\n SELECT obj.id,\n    obj.guid,\n    (obj.attributes ->> 'classGUID'::text)::uuid AS class_guid,\n    obj.attributes ->> 'caption'::text AS caption,\n    obj.attributes -> 'table'::text AS "table",\n    obj.attributes -> 'card'::text AS card,\n    obj.attributes -> 'preview'::text AS preview,\n    obj.attributes -> 'list'::text AS list,\n    obj.created_time,\n    obj.attributes,\n    obj.status\n   FROM object obj\n  WHERE (obj.class IN ( SELECT reclada_object.get_guid_for_class('ObjectDisplay'::text) AS get_guid_for_class)) AND obj.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_active_object ;\nCREATE OR REPLACE VIEW reclada.v_active_object\nAS\n SELECT t.id,\n    t.obj_id,\n    t.class,\n    t.revision_num,\n    t.status,\n    t.status_caption,\n    t.revision,\n    t.created_time,\n    t.class_name,\n    t.attrs,\n    t.data,\n    t.transaction_id,\n    t.parent_guid,\n    t.default_value\n   FROM v_object t\n  WHERE t.status = reclada_object.get_active_status_obj_id();\nDROP view IF EXISTS reclada.v_relationship ;\nCREATE OR REPLACE VIEW reclada.v_relationship\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    obj.attrs ->> 'type'::text AS type,\n    (obj.attrs ->> 'object'::text)::uuid AS object,\n    (obj.attrs ->> 'subject'::text)::uuid AS subject,\n    obj.parent_guid,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'Relationship'::text;\nDROP view IF EXISTS reclada.v_component ;\nCREATE OR REPLACE VIEW reclada.v_component\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    obj.attrs ->> 'name'::text AS name,\n    obj.attrs ->> 'repository'::text AS repository,\n    obj.attrs ->> 'commitHash'::text AS commit_hash,\n    obj.transaction_id,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'Component'::text;\nDROP view IF EXISTS reclada.v_component_object ;\nCREATE OR REPLACE VIEW reclada.v_component_object\nAS\n SELECT o.id,\n    c.name AS component_name,\n    c.guid AS component_guid,\n    o.transaction_id,\n    o.class_name,\n    o.obj_id,\n    o.data AS obj_data,\n    r.guid AS relationship_guid\n   FROM v_component c\n     JOIN v_relationship r ON r.parent_guid = c.guid AND 'data of reclada-component'::text = r.type\n     JOIN v_active_object o ON o.obj_id = r.subject;\nDROP view IF EXISTS reclada.v_dto_json_schema ;\nCREATE OR REPLACE VIEW reclada.v_dto_json_schema\nAS\n SELECT obj.id,\n    obj.obj_id,\n    obj.attrs ->> 'function'::text AS function,\n    obj.attrs -> 'schema'::text AS schema,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid\n   FROM v_active_object obj\n  WHERE obj.class_name = 'DTOJsonSchema'::text;\nDROP view IF EXISTS reclada.v_ui_active_object ;\nCREATE OR REPLACE VIEW reclada.v_ui_active_object\nAS\n SELECT 'with recursive \r\nd as ( \r\n    select  data, \r\n            obj_id,\r\n            created_time,\r\n            attrs \r\n        FROM reclada.v_active_object obj \r\n            where #@#@#where#@#@#\r\n                ORDER BY #@#@#orderby#@#@#\r\n                OFFSET #@#@#offset#@#@#\r\n                LIMIT #@#@#limit#@#@#\r\n),\r\nt as\r\n(\r\n    SELECT  je.key,\r\n            1 as q,\r\n            jsonb_typeof(je.value) typ,\r\n            d.obj_id,\r\n            je.value\r\n        from d \r\n        JOIN LATERAL jsonb_each(d.data) je\r\n            on true\r\n        -- where jsonb_typeof(je.value) != ''null''\r\n    union\r\n    SELECT \r\n            d.key ||'',''|| je.key as key ,\r\n            d.q,\r\n            jsonb_typeof(je.value) typ,\r\n            d.obj_id,\r\n            je.value\r\n        from (\r\n            select  d.data #> (''{''||t.key||''}'')::text[] as data, \r\n                    t.q+1 as q,\r\n                    t.key,\r\n                    d.obj_id\r\n            from t \r\n            join d\r\n                on t.typ = ''object''\r\n        ) d\r\n        JOIN LATERAL jsonb_each(d.data) je\r\n            on true\r\n        -- where jsonb_typeof(je.value) != ''null''\r\n),\r\nres as\r\n(\r\n    select  rr.obj_id,\r\n            rr.data,\r\n            rr.display_key,\r\n            o.attrs,\r\n            o.created_time,\r\n            o.id\r\n        from\r\n        (\r\n            select  t.obj_id,\r\n                    jsonb_object_agg\r\n                    (\r\n                        ''{''||t.key||''}'',\r\n                        t.value\r\n                    ) as data,\r\n                    array_agg(\r\n                        t.key||''#@#@#separator#@#@#''||t.typ \r\n                    ) as display_key\r\n                from t \r\n                    where t.typ != ''object''\r\n                    group by t.obj_id\r\n        ) rr\r\n        join reclada.v_active_object o\r\n            on o.obj_id = rr.obj_id\r\n)\r\n'::text AS val;\nDROP view IF EXISTS reclada.v_task ;\nCREATE OR REPLACE VIEW reclada.v_task\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    obj.attrs ->> 'type'::text AS type,\n    obj.attrs ->> 'command'::text AS command,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'Task'::text;\nDROP view IF EXISTS reclada.v_revision ;\nCREATE OR REPLACE VIEW reclada.v_revision\nAS\n SELECT obj.id,\n    obj.obj_id,\n    (obj.attrs ->> 'num'::text)::bigint AS num,\n    obj.attrs ->> 'branch'::text AS branch,\n    obj.attrs ->> 'user'::text AS "user",\n    obj.attrs ->> 'dateTime'::text AS date_time,\n    obj.attrs ->> 'old_num'::text AS old_num,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'revision'::text;\nDROP view IF EXISTS reclada.v_import_info ;\nCREATE OR REPLACE VIEW reclada.v_import_info\nAS\n SELECT obj.id,\n    obj.obj_id AS guid,\n    (obj.attrs ->> 'tranID'::text)::bigint AS tran_id,\n    obj.attrs ->> 'name'::text AS name,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data\n   FROM v_active_object obj\n  WHERE obj.class_name = 'ImportInfo'::text;\nDROP view IF EXISTS reclada.v_class ;\nCREATE OR REPLACE VIEW reclada.v_class\nAS\n SELECT obj.id,\n    obj.obj_id,\n    cl.for_class,\n    cl.version,\n    obj.revision_num,\n    obj.status_caption,\n    obj.revision,\n    obj.created_time,\n    obj.attrs,\n    obj.status,\n    obj.data,\n    obj.parent_guid,\n    obj.default_value\n   FROM v_class_lite cl\n     JOIN v_active_object obj ON cl.id = obj.id;\nDROP view IF EXISTS reclada.v_parent_field ;\nCREATE OR REPLACE VIEW reclada.v_parent_field\nAS\n SELECT v_class.for_class,\n    v_class.obj_id AS class_uuid,\n    v_class.attributes ->> 'parentField'::text AS parent_field\n   FROM v_class_lite v_class\n  WHERE (v_class.attributes ->> 'parentField'::text) IS NOT NULL;\n\n\nCREATE MATERIALIZED VIEW reclada.v_object_unifields\nAS\n    SELECT\n        for_class,\n        class_uuid,\n        CAST (dup_behavior AS reclada.dp_bhvr) AS dup_behavior,\n        is_cascade,\n        is_mandatory,\n        uf as unifield,\n        uni_number,\n        row_number() OVER (PARTITION BY for_class,uni_number ORDER BY uf) AS field_number,\n        copy_field\n    FROM\n        (\n        SELECT\n            for_class,\n            obj_id                                      AS class_uuid,\n            dup_behavior,\n            is_cascade::boolean                         AS is_cascade,\n            (dc->>'isMandatory')::boolean               AS is_mandatory,\n            jsonb_array_elements_text(dc->'uniFields')  AS uf,\n            dc->'uniFields'::text                       AS field_list,\n            row_number() OVER ( PARTITION BY for_class ORDER BY dc->'uniFields'::text) AS uni_number,\n            copy_field\n        FROM\n            (\n            SELECT\n                for_class,\n                attributes->>'dupBehavior'           AS dup_behavior,\n                (attributes->>'isCascade')           AS is_cascade,\n                jsonb_array_elements( attributes ->'dupChecking') AS dc,\n                obj_id,\n                attributes->>'copyField' as copy_field\n            FROM\n                reclada.v_class_lite vc\n            WHERE\n                attributes ->'dupChecking' is not null\n                AND vc.status = reclada_object.get_active_status_obj_id()\n            ) a\n        ) b\n;\nANALYZE reclada.v_object_unifields;\n\n--{REC 633\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    _data         jsonb;\r\n    new_data      jsonb;\r\n    _class_name    text;\r\n    _class_uuid   uuid;\r\n    tran_id       bigint;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    _obj_guid     uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    inserted      uuid[];\r\n    inserted_from_draft uuid[];\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _is_cascade   boolean;\r\n    _uni_field    text;\r\n    _parent_guid  uuid;\r\n    _parent_field   text;\r\n    skip_insert     boolean;\r\n    notify_res      jsonb;\r\n    _cnt             int;\r\n    _new_parent_guid       uuid;\r\n    _rel_type       text := 'GUID changed for dupBehavior';\r\n    _guid_list      text;\r\n    _component_guid uuid;\r\n    _row_count              int;\r\n    _f_name         text = 'reclada_object.create';\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n\r\n    SELECT guid \r\n        FROM dev.component \r\n        INTO _component_guid;\r\n\r\n    /*TODO: check if some objects have revision AND others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    FOR _data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n\r\n        if _component_guid is not null then\r\n            _attrs      := _data-> 'attributes';\r\n            _obj_guid   := _data->>'GUID'      ;    \r\n            select obj_id, for_class \r\n                from reclada.v_class \r\n                    where _data->>'class' in (obj_id::text, for_class)\r\n                    ORDER BY version DESC \r\n                    LIMIT 1\r\n                into _class_uuid, _class_name;\r\n\r\n            perform reclada.raise_exception('You should use reclada_object.create_subclass for new jsonschema.',_f_name)\r\n                where _class_name = 'jsonschema';\r\n\r\n            update dev.component_object\r\n                set status = 'ok'\r\n                    where status = 'need to check'\r\n                        and _obj_guid::text      = data->>'GUID'\r\n                        and _attrs               = data-> 'attributes'\r\n                        and _class_uuid::text    = data->>'class'\r\n                        and coalesce(_data->>'parentGUID','null') = coalesce(data->>'parentGUID','null') \r\n                        ------\r\n                        and _obj_guid is not null;\r\n                        ------\r\n\r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n\r\n            update dev.component_object\r\n                set status = 'update',\r\n                    data   = _data\r\n                    where status = 'need to check' \r\n                        and _obj_guid::text = data->>'GUID'\r\n                        ------\r\n                        and _obj_guid is not null;\r\n                        ------\r\n\r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n            \r\n            with t as\r\n            (\r\n                select min(id) as id\r\n                    from dev.component_object\r\n                        where status = 'need to check'\r\n                            and _attrs               = data-> 'attributes'\r\n                            and _class_uuid::text    = data->>'class'\r\n                            and coalesce(_data->>'parentGUID','null') = coalesce(data->>'parentGUID','null')\r\n                            ------\r\n                            and _obj_guid is null\r\n                            ------\r\n            )\r\n                update dev.component_object u\r\n                    set status = 'ok'\r\n                        from t\r\n                            where u.id = t.id;\r\n                    \r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n            \r\n            insert into dev.component_object( data, status  )\r\n                select _data, 'create';\r\n            continue;\r\n            \r\n        end if;\r\n\r\n        SELECT  valid_schema, \r\n                attributes,\r\n                class_name,\r\n                class_guid \r\n            FROM reclada.validate_json_schema(_data)\r\n            INTO    schema      , \r\n                    _attrs      ,\r\n                    _class_name ,\r\n                    _class_uuid ;\r\n\r\n        skip_insert := false;\r\n\r\n        tran_id := (_data->>'transactionID')::bigint;\r\n        IF tran_id IS NULL THEN\r\n            tran_id := reclada.get_transaction_id();\r\n        END IF;\r\n\r\n        IF _data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        SELECT prnt_guid, prnt_field\r\n        FROM reclada_object.get_parent_guid(_data,_class_name)\r\n            INTO _parent_guid,\r\n                _parent_field;\r\n        _obj_guid := _data->>'GUID';\r\n\r\n        IF (_parent_guid IS NOT NULL) THEN\r\n            SELECT\r\n                attrs->>'object',\r\n                attrs->>'dupBehavior',\r\n                attrs->>'isCascade'\r\n            FROM reclada.v_active_object\r\n            WHERE class_name = 'Relationship'\r\n                AND attrs->>'type'                      = _rel_type\r\n                AND (attrs->>'subject')::uuid  = _parent_guid\r\n                    INTO _new_parent_guid, _dup_behavior, _is_cascade;\r\n\r\n            IF _new_parent_guid IS NOT NULL THEN\r\n                _parent_guid := _new_parent_guid;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.v_object_unifields\r\n            WHERE class_uuid = _class_uuid\r\n        )\r\n        THEN\r\n            IF (_parent_guid IS NOT NULL) THEN\r\n                IF (_dup_behavior = 'Update' AND _is_cascade) THEN\r\n                    SELECT count(DISTINCT obj_guid), string_agg(DISTINCT obj_guid::text, ',')\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                        INTO _cnt, _guid_list;\r\n                    IF (_cnt >1) THEN\r\n                        RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                    ELSIF (_cnt = 1) THEN\r\n                        SELECT DISTINCT obj_guid, is_cascade\r\n                        FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                            INTO _obj_guid, _is_cascade;\r\n                        new_data := _data;\r\n                        IF new_data->>'GUID' IS NOT NULL THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                        END IF;\r\n                        new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                        new_data = reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                        SELECT reclada_object.update(new_data)\r\n                            INTO res;\r\n                        affected := array_append( affected, _obj_guid);\r\n                        skip_insert := true;\r\n                    END IF;\r\n                END IF;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM reclada.v_active_object\r\n                    WHERE obj_id = _parent_guid\r\n                )\r\n                    AND _new_parent_guid IS NULL\r\n                THEN\r\n                    IF (_obj_guid IS NULL) THEN\r\n                        RAISE EXCEPTION 'GUID is required.';\r\n                    END IF;\r\n                    INSERT INTO reclada.draft(guid, parent_guid, data)\r\n                        VALUES(_obj_guid, _parent_guid, _data);\r\n                    skip_insert := true;\r\n                END IF;\r\n            END IF;\r\n\r\n            IF (NOT skip_insert) THEN\r\n                SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg (DISTINCT obj_guid::text, ',')\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                GROUP BY dup_behavior\r\n                    INTO _cnt, _dup_behavior, _guid_list;\r\n                IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n                    RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                END IF;\r\n                FOR _obj_guid, _dup_behavior, _is_cascade, _uni_field IN\r\n                    SELECT obj_guid, dup_behavior, is_cascade, dup_field\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                LOOP\r\n                    new_data := _data;\r\n                    CASE _dup_behavior\r\n                        WHEN 'Replace' THEN\r\n                            IF (_is_cascade = true) THEN\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', a)::jsonb)\r\n                                FROM reclada.get_children(_obj_guid) a;\r\n                            ELSE\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                            END IF;\r\n                        WHEN 'Update' THEN\r\n                            IF new_data->>'GUID' IS NOT NULL THEN\r\n                                PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                            END IF;\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            new_data := reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                            SELECT reclada_object.update(new_data)\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                        WHEN 'Reject' THEN\r\n                            RAISE EXCEPTION 'The object was rejected.';\r\n                        WHEN 'Copy'    THEN\r\n                            _attrs := _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                        WHEN 'Insert' THEN\r\n                            -- DO nothing\r\n                        WHEN 'Merge' THEN\r\n                            IF new_data->>'GUID' IS NOT NULL THEN\r\n                                PERFORM reclada_object.create_relationship(\r\n                                        _rel_type,\r\n                                        _obj_guid,\r\n                                        (new_data->>'GUID')::uuid,\r\n                                        '{"dupBehavior": "Merge"}'::jsonb\r\n                                    );\r\n                            END IF;\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            SELECT reclada_object.update(\r\n                                    reclada_object.merge(\r\n                                            new_data - 'class', \r\n                                            data,\r\n                                            schema\r\n                                        ) \r\n                                        || format('{"GUID": "%s"}', _obj_guid)::jsonb \r\n                                        || format('{"transactionID": %s}', tran_id)::jsonb\r\n                                )\r\n                            FROM reclada.v_active_object\r\n                            WHERE obj_id = _obj_guid\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                    END CASE;\r\n                END LOOP;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF (NOT skip_insert) THEN           \r\n            _obj_guid := _data->>'GUID';\r\n            IF EXISTS (\r\n                SELECT FROM reclada.object \r\n                    WHERE guid = _obj_guid\r\n            ) THEN\r\n                perform reclada.raise_exception ('GUID: '||_obj_guid::text||' is duplicate',_f_name);\r\n            END IF;\r\n\r\n            _obj_guid := coalesce(_obj_guid, public.uuid_generate_v4());\r\n\r\n            INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n                SELECT  _obj_guid AS GUID,\r\n                        _class_uuid, \r\n                        _attrs,\r\n                        tran_id,\r\n                        _parent_guid;\r\n\r\n            affected := array_append( affected, _obj_guid);\r\n            inserted := array_append( inserted, _obj_guid);\r\n            PERFORM reclada_object.object_insert\r\n                (\r\n                    _class_name,\r\n                    _obj_guid,\r\n                    _attrs\r\n                );\r\n\r\n            PERFORM reclada_object.refresh_mv(_class_name);\r\n        END IF;\r\n    END LOOP;\r\n\r\n    SELECT array_agg(_affected_objects->>'GUID')\r\n    FROM (\r\n        SELECT jsonb_array_elements(_affected_objects) AS _affected_objects\r\n        FROM (\r\n            SELECT reclada_object.create(data) AS _affected_objects\r\n            FROM reclada.draft\r\n            WHERE parent_guid = ANY (affected)\r\n        ) a\r\n    ) b\r\n    WHERE _affected_objects->>'GUID' IS NOT NULL\r\n        INTO inserted_from_draft;\r\n    affected := affected || inserted_from_draft;    \r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb;\r\n    notify_res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (inserted)\r\n                )\r\n            )::jsonb; \r\n    \r\n    DELETE FROM reclada.draft \r\n        WHERE guid = ANY (affected);\r\n\r\n    PERFORM reclada.update_unique_object(affected);\r\n        \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            notify_res\r\n        );\r\n    RETURN res;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.update ;\nCREATE OR REPLACE FUNCTION reclada_object.update(_data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name       TEXT = 'reclada_object.update';\r\n    _class_name   text;\r\n    _class_uuid   uuid;\r\n    _obj_id       uuid;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    old_obj       jsonb;\r\n    branch        uuid;\r\n    revid         uuid;\r\n    _parent_guid  uuid;\r\n    _parent_field text;\r\n    _obj_guid     uuid;\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _uni_field    text;\r\n    _cnt          int;\r\n    _tran_id      bigint;\r\n    _guid_list    text;\r\nBEGIN\r\n\r\n    SELECT  valid_schema, \r\n            attributes,\r\n            class_name,\r\n            class_guid \r\n        FROM reclada.validate_json_schema(_data)\r\n        INTO    schema      , \r\n                _attrs      ,\r\n                _class_name ,\r\n                _class_uuid ;\r\n\r\n    _obj_id := _data->>'GUID';\r\n    IF (_obj_id IS NULL) THEN\r\n        perform reclada.raise_exception('Could not update object with no GUID',_f_name);\r\n    END IF;\r\n\r\n    _tran_id = coalesce(    \r\n                    (_data->>'transactionID')::bigint, \r\n                    (\r\n                        select transaction_id \r\n                            from reclada.v_active_object \r\n                                where obj_id = _obj_id\r\n                    )\r\n                );\r\n\r\n    -- don't allow update jsonschema\r\n    if _class_name = 'jsonschema' then\r\n        perform reclada.raise_exception('Can''t update jsonschema',_f_name);\r\n    end if;\r\n\r\n    SELECT \tv.data\r\n        FROM reclada.v_object v\r\n\t        WHERE v.obj_id = _obj_id\r\n                AND v.class_name = _class_name \r\n\t    INTO old_obj;\r\n\r\n    IF (old_obj IS NULL) THEN\r\n        perform reclada.raise_exception('Could not update object, no such id');\r\n    END IF;\r\n\r\n    branch := _data->'branch';\r\n    SELECT reclada_revision.create(user_info->>'sub', branch, _obj_id, _tran_id) \r\n        INTO revid;\r\n\r\n    SELECT prnt_guid, prnt_field\r\n    FROM reclada_object.get_parent_guid(_data,_class_name)\r\n        INTO _parent_guid,\r\n            _parent_field;\r\n\r\n    IF (_parent_guid IS NULL) THEN\r\n        _parent_guid := old_obj->>'parentGUID';\r\n    END IF;\r\n    \r\n    IF EXISTS (\r\n        SELECT 1\r\n        FROM reclada.v_object_unifields\r\n        WHERE class_uuid=_class_uuid\r\n    )\r\n    THEN\r\n        SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg(DISTINCT obj_guid::text, ',')\r\n        FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)\r\n        GROUP BY dup_behavior\r\n            INTO _cnt, _dup_behavior, _guid_list;\r\n        IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n            RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n        END IF;\r\n        FOR _obj_guid, _dup_behavior, _uni_field IN (\r\n                SELECT obj_guid, dup_behavior, dup_field\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid, _obj_id)\r\n            ) LOOP\r\n            IF _dup_behavior IN ('Update','Merge') THEN\r\n                UPDATE reclada.object o\r\n                    SET status = reclada_object.get_archive_status_obj_id()\r\n                WHERE o.GUID = _obj_guid\r\n                    AND status != reclada_object.get_archive_status_obj_id();\r\n            END IF;\r\n            CASE _dup_behavior\r\n                WHEN 'Replace' THEN\r\n                    PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                WHEN 'Update' THEN                    \r\n                    _data := reclada_object.remove_parent_guid(_data, _parent_field);\r\n                    _data := reclada_object.update_json_by_guid(_obj_guid, _data);\r\n                    RETURN reclada_object.update(_data);\r\n                WHEN 'Reject' THEN\r\n                    RAISE EXCEPTION 'Duplicate found (GUID: %). Object rejected.', _obj_guid;\r\n                WHEN 'Copy'    THEN\r\n                    _attrs = _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                    IF (NOT(public.validate_json_schema(schema, _attrs))) THEN\r\n                        RAISE EXCEPTION 'JSON invalid: %', _attrs;\r\n                    END IF;\r\n                WHEN 'Insert' THEN\r\n                    -- DO nothing\r\n                WHEN 'Merge' THEN     \r\n                    _data := reclada_object.remove_parent_guid(_data, _parent_field);               \r\n                    RETURN reclada_object.update(\r\n                        reclada_object.merge(\r\n                            _data - 'class', \r\n                            vao.data, \r\n                            schema\r\n                        ) || format('{"GUID": "%s"}', _obj_guid)::jsonb\r\n                    )\r\n                        FROM reclada.v_active_object vao\r\n                            WHERE obj_id = _obj_guid;\r\n            END CASE;\r\n        END LOOP;\r\n    END IF;\r\n\r\n    with t as \r\n    (\r\n        update reclada.object o\r\n            set status = reclada_object.get_archive_status_obj_id()\r\n                where o.GUID = _obj_id\r\n                    and status != reclada_object.get_archive_status_obj_id()\r\n                        RETURNING id\r\n    )\r\n    INSERT INTO reclada.object( GUID,\r\n                                class,\r\n                                status,\r\n                                attributes,\r\n                                transaction_id,\r\n                                parent_guid\r\n                              )\r\n        select  v.obj_id,\r\n                _class_uuid,\r\n                reclada_object.get_active_status_obj_id(),--status \r\n                _attrs || format('{"revision":"%s"}',revid)::jsonb,\r\n                _tran_id,\r\n                _parent_guid\r\n            FROM reclada.v_object v\r\n            JOIN \r\n            (   \r\n                select id \r\n                    FROM \r\n                    (\r\n                        select id, 1 as q\r\n                            from t\r\n                        union \r\n                        select id, 2 as q\r\n                            from reclada.object ro\r\n                                where ro.guid = _obj_id\r\n                                    ORDER BY ID DESC \r\n                                        LIMIT 1\r\n                    ) ta\r\n                    ORDER BY q ASC \r\n                        LIMIT 1\r\n            ) as tt\r\n                on tt.id = v.id\r\n\t            WHERE v.obj_id = _obj_id;\r\n\r\n    PERFORM reclada.update_unique_object(ARRAY[_obj_id]);\r\n\r\n    PERFORM reclada_object.object_insert\r\n            (\r\n                _class_name,\r\n                _obj_id,\r\n                _attrs\r\n            );\r\n    PERFORM reclada_object.refresh_mv(_class_name);\r\n\r\n    IF ( _class_name = 'jsonschema' AND jsonb_typeof(_attrs->'dupChecking') = 'array') THEN\r\n        PERFORM reclada_object.refresh_mv('uniFields');\r\n    END IF; \r\n                  \r\n    select v.data \r\n        FROM reclada.v_active_object v\r\n            WHERE v.obj_id = _obj_id\r\n        into _data;\r\n    PERFORM reclada_notification.send_object_notification('update', _data);\r\n    RETURN _data;\r\nEND;\r\n$function$\n;\n--REC 633}\n\nDROP view IF EXISTS reclada.v_get_duplicates_query ;\nCREATE OR REPLACE VIEW reclada.v_get_duplicates_query\nAS\n SELECT 'SELECT ''\r\n    SELECT vao.obj_id, \r\n            '''''' || dup_behavior || ''''''::reclada.dp_bhvr,\r\n            '' || is_cascade || '',\r\n            '' || COALESCE (copy_field,'''''''''''') ||'' FROM reclada.v_active_object vao WHERE '' ||  string_agg(predicate, '' OR '') @#@#@exclude_uuid@#@#@\r\n          FROM (SELECT string_agg(''(vao.attrs ->>'''''' || unifield || '''''')'', ''||'' ORDER BY field_number) || ''='''''' || string_agg(COALESCE((''@#@#@attrs@#@#@''::jsonb) ->> unifield,''''),''''  ORDER BY field_number) || '''''''' AS predicate,\r\n          dup_behavior , is_cascade , copy_field\r\n          FROM reclada.v_object_unifields vou \r\n          WHERE class_uuid = ''@#@#@class_uuid@#@#@''\r\n            AND is_mandatory\r\n          GROUP BY uni_number, dup_behavior , is_cascade , copy_field) a\r\n         GROUP BY dup_behavior , is_cascade , copy_field\r\n'::text AS val;\n\nDROP function IF EXISTS reclada_object.list ;\nCREATE OR REPLACE FUNCTION reclada_object.list(data jsonb, gui boolean DEFAULT false, ver text DEFAULT '1'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _f_name TEXT = 'reclada_object.list';\r\n    _class              text;\r\n    attrs               jsonb;\r\n    order_by_jsonb      jsonb;\r\n    order_by            text;\r\n    limit_              text;\r\n    offset_             text;\r\n    query_conditions    text;\r\n    number_of_objects   int;\r\n    objects             jsonb;\r\n    res                 jsonb;\r\n    _exec_text          text;\r\n    _pre_query          text;\r\n    _from               text;\r\n    class_uuid          uuid;\r\n    last_change         text;\r\n    tran_id             bigint;\r\n    _filter             jsonb;\r\n    _object_display     jsonb;\r\n    _order_row          jsonb;\r\nBEGIN\r\n\r\n    perform reclada.validate_json(data, _f_name);\r\n\r\n    if ver = '1' then\r\n        tran_id := (data->>'transactionID')::bigint;\r\n        _class := data->>'class';\r\n    elseif ver = '2' then\r\n        tran_id := (data->>'{transactionID}')::bigint;\r\n        _class := data->>'{class}';\r\n    end if;\r\n    _filter = data->'filter';\r\n\r\n    order_by_jsonb := data->'orderBy';\r\n    IF ((order_by_jsonb IS NULL) OR\r\n        (order_by_jsonb = 'null'::jsonb) OR\r\n        (order_by_jsonb = '[]'::jsonb)) then\r\n        \r\n        select (vod.table #> '{orderRow}') as orderRow\r\n        \tfrom reclada.v_object_display vod\r\n        \twhere vod.class_guid = (reclada_object.get_schema(_class)#>>'{GUID}')::uuid\r\n        \tinto _order_row;\r\n        if _order_row is not null then     \r\n        \tselect '[' || string_agg(('{"field": "' || obf.field || '", ' || '"order": ' || obf.order_by || '}'), ', ') || ']'\r\n\t\t\tfrom(\r\n \t \t\t\t select je.value as order_by, \r\n \t \t\t\t \t\tsplit_part(je.key, ':', 1) as field\r\n \t \t\t\t \tfrom jsonb_array_elements(_order_row) jae\r\n \t \t\t\t \tcross join jsonb_each(jae.value) je\r\n \t \t\t) obf\r\n\t\t\t\tinto order_by_jsonb;\r\n    \tELSE\r\n        \torder_by_jsonb := '[{"field": "GUID", "order": "ASC"}]'::jsonb;\r\n        end if;\r\n    END IF;\r\n    SELECT string_agg(\r\n        format(\r\n            E'obj.data#>''{%s}'' %s', \r\n            case ver\r\n                when '2'\r\n                    then REPLACE(REPLACE(T.value->>'field','{', '"{' ),'}', '}"' )\r\n                else\r\n                    T.value->>'field'\r\n            end,\r\n            COALESCE(T.value->>'order', 'ASC')),\r\n        ' , ')\r\n        FROM jsonb_array_elements(order_by_jsonb) T\r\n        INTO order_by;\r\n\r\n    limit_ := data->>'limit';\r\n    IF (limit_ IS NULL) THEN\r\n        limit_ := 500;\r\n    END IF;\r\n\r\n    offset_ := data->>'offset';\r\n    IF (offset_ IS NULL) THEN\r\n        offset_ := 0;\r\n    END IF;\r\n    \r\n    IF (_filter IS NOT NULL) THEN\r\n        query_conditions := reclada_object.get_query_condition_filter(_filter);\r\n    ELSEIF ver = '1' then\r\n        class_uuid := reclada.try_cast_uuid(_class);\r\n\r\n        IF (class_uuid IS NULL) THEN\r\n            SELECT v.obj_id\r\n                FROM reclada.v_class v\r\n                    WHERE _class = v.for_class\r\n                    ORDER BY v.version DESC\r\n                    limit 1 \r\n            INTO class_uuid;\r\n            IF (class_uuid IS NULL) THEN\r\n                perform reclada.raise_exception(\r\n                        format('Class not found: %s', _class),\r\n                        _f_name\r\n                    );\r\n            END IF;\r\n        end if;\r\n\r\n        attrs := data->'attributes' || '{}'::jsonb;\r\n\r\n        SELECT\r\n            string_agg(\r\n                format(\r\n                    E'(%s)',\r\n                    condition\r\n                ),\r\n                ' AND '\r\n            )\r\n            FROM (\r\n                SELECT\r\n                    format('obj.class_name = ''%s''', _class) AS condition\r\n                        where _class is not null\r\n                UNION\r\n                    SELECT format('obj.class = ''%s''', class_uuid) AS condition\r\n                        where class_uuid is not null\r\n                            and _class is null\r\n                UNION\r\n                    SELECT format('obj.transaction_id = %s', tran_id) AS condition\r\n                        where tran_id is not null\r\n                UNION\r\n                    SELECT CASE\r\n                            WHEN jsonb_typeof(data->'GUID') = 'array' THEN\r\n                            (\r\n                                SELECT string_agg\r\n                                    (\r\n                                        format(\r\n                                            E'(%s)',\r\n                                            reclada_object.get_query_condition(cond, E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                                        ),\r\n                                        ' AND '\r\n                                    )\r\n                                    FROM jsonb_array_elements(data->'GUID') AS cond\r\n                            )\r\n                            ELSE reclada_object.get_query_condition(data->'GUID', E'data->''GUID''') -- TODO: change data->'GUID' to obj_id(GUID)\r\n                        END AS condition\r\n                    WHERE coalesce(data->'GUID','null'::jsonb) != 'null'::jsonb\r\n                UNION\r\n                SELECT\r\n                    CASE\r\n                        WHEN jsonb_typeof(value) = 'array'\r\n                            THEN\r\n                                (\r\n                                    SELECT string_agg\r\n                                        (\r\n                                            format\r\n                                            (\r\n                                                E'(%s)',\r\n                                                reclada_object.get_query_condition(cond, format(E'attrs->%L', key))\r\n                                            ),\r\n                                            ' AND '\r\n                                        )\r\n                                        FROM jsonb_array_elements(value) AS cond\r\n                                )\r\n                        ELSE reclada_object.get_query_condition(value, format(E'attrs->%L', key))\r\n                    END AS condition\r\n                FROM jsonb_each(attrs)\r\n                WHERE attrs != ('{}'::jsonb)\r\n            ) conds\r\n        INTO query_conditions;\r\n    END IF;\r\n    -- TODO: add ELSE\r\n    IF ver = '2' THEN\r\n        _pre_query := (select val from reclada.v_ui_active_object);\r\n        _from := 'res AS obj';\r\n        _pre_query := REPLACE(_pre_query, '#@#@#where#@#@#'  , query_conditions);\r\n        _pre_query := REPLACE(_pre_query, '#@#@#orderby#@#@#', order_by        );\r\n        order_by :=  REPLACE(order_by, '{', '{"{');\r\n        order_by :=  REPLACE(order_by, '}', '}"}'); --obj.data#>'{some_field}'  -->  obj.data#>'{"{some_field}"}'\r\n\r\n    ELSE\r\n        _pre_query := '';\r\n        _from := 'reclada.v_active_object AS obj\r\n                            WHERE #@#@#where#@#@#';\r\n        _from := REPLACE(_from, '#@#@#where#@#@#', query_conditions  );\r\n    END IF;\r\n    _exec_text := _pre_query ||\r\n                'SELECT to_jsonb(array_agg(t.data))\r\n                    FROM \r\n                    (\r\n                        SELECT obj.data\r\n                            FROM '\r\n                            || _from\r\n                            || ' \r\n                            ORDER BY #@#@#orderby#@#@#'\r\n                            || case \r\n                                when ver = '2' \r\n                                    then ''\r\n                                else\r\n                                '\r\n                                OFFSET #@#@#offset#@#@#\r\n                                LIMIT #@#@#limit#@#@#'\r\n                            end\r\n                            || '\r\n                    ) AS t';\r\n    _exec_text := REPLACE(_exec_text, '#@#@#orderby#@#@#'  , order_by          );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#offset#@#@#'   , offset_           );\r\n    _exec_text := REPLACE(_exec_text, '#@#@#limit#@#@#'    , limit_            );\r\n    -- RAISE NOTICE 'conds: %', _exec_text;\r\n\r\n    EXECUTE _exec_text\r\n        INTO objects;\r\n    objects := coalesce(objects,'[]'::jsonb);\r\n    IF gui THEN\r\n\r\n        if ver = '2' then\r\n            class_uuid := coalesce(class_uuid, (objects#>>'{0,"{class}"}')::uuid);\r\n            if class_uuid is not null then\r\n                _class :=   (\r\n                                select cl.for_class \r\n                                    from reclada.v_class_lite cl\r\n                                        where class_uuid = cl.obj_id\r\n                                            limit 1\r\n                            );\r\n\r\n                _exec_text := '\r\n                with \r\n                d as ( \r\n                    select id_unique_object\r\n                        FROM reclada.v_active_object obj \r\n                        JOIN reclada.unique_object_reclada_object as uoc\r\n                            on uoc.id_reclada_object = obj.id\r\n                                and #@#@#where#@#@#\r\n                        group by id_unique_object\r\n                ),\r\n                dd as (\r\n                    select distinct \r\n                            ''{''||f.path||''}:''||f.json_type v,\r\n                            f.json_type\r\n                        FROM d \r\n                        JOIN reclada.unique_object as uo\r\n                            on d.id_unique_object = uo.id\r\n                        JOIN reclada.field f\r\n                            on f.id = ANY (uo.id_field)\r\n                    UNION\r\n                    SELECT  pattern||'':''|| t.v,\r\n                            t.v\r\n                    FROM reclada.v_filter_mapping vfm\r\n                    CROSS JOIN LATERAL \r\n                    (\r\n                        SELECT  CASE \r\n                                    WHEN vfm.pattern=''{transactionID}'' \r\n                                        THEN ''number'' \r\n                                    ELSE ''string'' \r\n                                END as v\r\n                    ) t\r\n                ),\r\n                on_data as \r\n                (\r\n                    select  jsonb_object_agg(\r\n                                t.v, \r\n                                replace(dd.template,''#@#attrname#@#'',t.v)::jsonb \r\n                            ) t\r\n                        from dd as t\r\n                        JOIN reclada.v_default_display dd\r\n                            on t.json_type = dd.json_type\r\n                )\r\n                select jsonb_set(templ.v,''{table}'', od.t || coalesce(d.table,coalesce(d.table,templ.v->''table'')))\r\n                    from on_data od\r\n                    join (\r\n                        select replace(template,''#@#classname#@#'','''|| _class ||''')::jsonb v\r\n                            from reclada.v_default_display \r\n                                where json_type = ''ObjectDisplay''\r\n                                    limit 1\r\n                    ) templ\r\n                        on true\r\n                    left join reclada.v_object_display d\r\n                        on d.class_guid::text = '''|| coalesce( class_uuid::text, '' ) ||'''';\r\n\r\n                _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );\r\n                -- raise notice '%',_exec_text;\r\n                EXECUTE _exec_text\r\n                    INTO _object_display;\r\n            end if;\r\n        end if;\r\n\r\n        _exec_text := '\r\n            SELECT  COUNT(1),\r\n                    TO_CHAR(\r\n                        MAX(\r\n                            GREATEST(\r\n                                obj.created_time, \r\n                                (\r\n                                    SELECT  TO_TIMESTAMP(\r\n                                                MAX(date_time),\r\n                                                ''YYYY-MM-DD hh24:mi:ss.US TZH''\r\n                                            )\r\n                                        FROM reclada.v_revision vr\r\n                                            WHERE vr.obj_id = UUID(obj.attrs ->>''revision'')\r\n                                )\r\n                            )\r\n                        ),\r\n                        ''YYYY-MM-DD hh24:mi:ss.MS TZH''\r\n                    )\r\n                    FROM reclada.v_active_object obj \r\n                        where #@#@#where#@#@#';\r\n\r\n        _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#', query_conditions  );\r\n        -- raise notice '%',_exec_text;\r\n        EXECUTE _exec_text\r\n            INTO number_of_objects, last_change;\r\n        \r\n        IF _object_display IS NOT NULL then\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects,\r\n                    'display', _object_display\r\n                );\r\n        ELSE\r\n            res := jsonb_build_object(\r\n                    'lasthange', last_change,    \r\n                    'number', number_of_objects,\r\n                    'objects', objects\r\n            );\r\n        end if;\r\n    ELSE\r\n        \r\n        res := objects;\r\n    END IF;\r\n\r\n    RETURN res;\r\n\r\nEND;\r\n$function$\n;\n\nDROP TRIGGER load_staging on reclada.staging;\n\nDROP function IF EXISTS reclada.load_staging ;\nCREATE OR REPLACE FUNCTION reclada.load_staging()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    PERFORM reclada_object.create(NEW.data);\r\n    RETURN NEW;\r\nEND\r\n$function$\n;\nDROP TABLE reclada.staging;\n\nDROP view IF EXISTS reclada.staging ;\nCREATE OR REPLACE VIEW reclada.staging\nAS\n SELECT '{}'::jsonb AS data\n  WHERE false;\nDROP trigger IF EXISTS load_staging ON reclada.staging;\nCREATE TRIGGER load_staging INSTEAD OF INSERT ON staging FOR EACH ROW EXECUTE FUNCTION load_staging();\n\n\nDROP function IF EXISTS reclada_object.create ;\nCREATE OR REPLACE FUNCTION reclada_object."create"(data_jsonb jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    branch        uuid;\r\n    _data         jsonb;\r\n    new_data      jsonb;\r\n    _class_name    text;\r\n    _class_uuid   uuid;\r\n    tran_id       bigint;\r\n    _attrs        jsonb;\r\n    schema        jsonb;\r\n    _obj_guid     uuid;\r\n    res           jsonb;\r\n    affected      uuid[];\r\n    inserted      uuid[];\r\n    inserted_from_draft uuid[];\r\n    _dup_behavior reclada.dp_bhvr;\r\n    _is_cascade   boolean;\r\n    _uni_field    text;\r\n    _parent_guid  uuid;\r\n    _parent_field   text;\r\n    skip_insert     boolean;\r\n    notify_res      jsonb;\r\n    _cnt             int;\r\n    _new_parent_guid       uuid;\r\n    _rel_type       text := 'GUID changed for dupBehavior';\r\n    _guid_list      text;\r\n    _component_guid uuid;\r\n    _row_count              int;\r\n    _f_name         text = 'reclada_object.create';\r\nBEGIN\r\n\r\n    IF (jsonb_typeof(data_jsonb) != 'array') THEN\r\n        data_jsonb := '[]'::jsonb || data_jsonb;\r\n    END IF;\r\n\r\n    SELECT guid \r\n        FROM dev.component \r\n        INTO _component_guid;\r\n\r\n    /*TODO: check if some objects have revision AND others do not */\r\n    branch:= data_jsonb->0->'branch';\r\n\r\n    FOR _data IN SELECT jsonb_array_elements(data_jsonb) \r\n    LOOP\r\n\r\n        if _component_guid is not null then\r\n            _attrs      := _data-> 'attributes';\r\n            _obj_guid   := _data->>'GUID'      ;    \r\n            select obj_id, for_class \r\n                from reclada.v_class \r\n                    where _data->>'class' in (obj_id::text, for_class)\r\n                    ORDER BY version DESC \r\n                    LIMIT 1\r\n                into _class_uuid, _class_name;\r\n\r\n            perform reclada.raise_exception('You should use reclada_object.create_subclass for new jsonschema.',_f_name)\r\n                where _class_name = 'jsonschema';\r\n\r\n            update dev.component_object\r\n                set status = 'ok'\r\n                    where status = 'need to check'\r\n                        and _obj_guid::text      = data->>'GUID'\r\n                        and _attrs               = data-> 'attributes'\r\n                        and _class_uuid::text    = data->>'class'\r\n                        and coalesce(_data->>'parentGUID','null') = coalesce(data->>'parentGUID','null') \r\n                        ------\r\n                        and _obj_guid is not null;\r\n                        ------\r\n\r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n\r\n            update dev.component_object\r\n                set status = 'update',\r\n                    data   = _data\r\n                    where status = 'need to check' \r\n                        and _obj_guid::text = data->>'GUID'\r\n                        ------\r\n                        and _obj_guid is not null;\r\n                        ------\r\n\r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n            \r\n            with t as\r\n            (\r\n                select min(id) as id\r\n                    from dev.component_object\r\n                        where status = 'need to check'\r\n                            and _attrs               = data-> 'attributes'\r\n                            and _class_uuid::text    = data->>'class'\r\n                            and coalesce(_data->>'parentGUID','null') = coalesce(data->>'parentGUID','null')\r\n                            ------\r\n                            and _obj_guid is null\r\n                            ------\r\n            )\r\n                update dev.component_object u\r\n                    set status = 'ok'\r\n                        from t\r\n                            where u.id = t.id;\r\n                    \r\n            GET DIAGNOSTICS _row_count := ROW_COUNT;\r\n            if _row_count > 1 then\r\n                perform reclada.raise_exception('Can not match component objects',_f_name);\r\n            elsif _row_count = 1 then\r\n                continue;\r\n            end if;\r\n            \r\n            insert into dev.component_object( data, status  )\r\n                select _data, 'create';\r\n            continue;\r\n            \r\n        end if;\r\n\r\n        SELECT  valid_schema, \r\n                attributes,\r\n                class_name,\r\n                class_guid \r\n            FROM reclada.validate_json_schema(_data)\r\n            INTO    schema      , \r\n                    _attrs      ,\r\n                    _class_name ,\r\n                    _class_uuid ;\r\n\r\n        skip_insert := false;\r\n\r\n        tran_id := (_data->>'transactionID')::bigint;\r\n        IF tran_id IS NULL THEN\r\n            tran_id := reclada.get_transaction_id();\r\n        END IF;\r\n\r\n        IF _data->>'id' IS NOT NULL THEN\r\n            RAISE EXCEPTION '%','Field "id" not allow!!!';\r\n        END IF;\r\n\r\n        SELECT prnt_guid, prnt_field\r\n        FROM reclada_object.get_parent_guid(_data,_class_name)\r\n            INTO _parent_guid,\r\n                _parent_field;\r\n        _obj_guid := _data->>'GUID';\r\n\r\n        IF (_parent_guid IS NOT NULL) THEN\r\n            SELECT\r\n                attrs->>'object',\r\n                attrs->>'dupBehavior',\r\n                attrs->>'isCascade'\r\n            FROM reclada.v_active_object\r\n            WHERE class_name = 'Relationship'\r\n                AND attrs->>'type'                      = _rel_type\r\n                AND (attrs->>'subject')::uuid  = _parent_guid\r\n                    INTO _new_parent_guid, _dup_behavior, _is_cascade;\r\n\r\n            IF _new_parent_guid IS NOT NULL THEN\r\n                _parent_guid := _new_parent_guid;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF EXISTS (\r\n            SELECT 1\r\n            FROM reclada.v_object_unifields\r\n            WHERE class_uuid = _class_uuid\r\n        )\r\n        THEN\r\n            IF (_parent_guid IS NOT NULL) THEN\r\n                IF (_dup_behavior = 'Update' AND _is_cascade) THEN\r\n                    SELECT count(DISTINCT obj_guid), string_agg(DISTINCT obj_guid::text, ',')\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                        INTO _cnt, _guid_list;\r\n                    IF (_cnt >1) THEN\r\n                        RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                    ELSIF (_cnt = 1) THEN\r\n                        SELECT DISTINCT obj_guid, is_cascade\r\n                        FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                            INTO _obj_guid, _is_cascade;\r\n                        new_data := _data;\r\n                        IF new_data->>'GUID' IS NOT NULL THEN\r\n                            PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                        END IF;\r\n                        new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                        new_data = reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                        SELECT reclada_object.update(new_data)\r\n                            INTO res;\r\n                        affected := array_append( affected, _obj_guid);\r\n                        skip_insert := true;\r\n                    END IF;\r\n                END IF;\r\n                IF NOT EXISTS (\r\n                    SELECT 1\r\n                    FROM reclada.v_active_object\r\n                    WHERE obj_id = _parent_guid\r\n                )\r\n                    AND _new_parent_guid IS NULL\r\n                THEN\r\n                    IF (_obj_guid IS NULL) THEN\r\n                        RAISE EXCEPTION 'GUID is required.';\r\n                    END IF;\r\n                    INSERT INTO reclada.draft(guid, parent_guid, data)\r\n                        VALUES(_obj_guid, _parent_guid, _data);\r\n                    skip_insert := true;\r\n                END IF;\r\n            END IF;\r\n\r\n            IF (NOT skip_insert) THEN\r\n                SELECT COUNT(DISTINCT obj_guid), dup_behavior, string_agg (DISTINCT obj_guid::text, ',')\r\n                FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                GROUP BY dup_behavior\r\n                    INTO _cnt, _dup_behavior, _guid_list;\r\n                IF (_cnt>1 AND _dup_behavior IN ('Update','Merge')) THEN\r\n                    RAISE EXCEPTION 'Found more than one duplicates (GUIDs: %). Resolve conflict manually.', _guid_list;\r\n                END IF;\r\n                FOR _obj_guid, _dup_behavior, _is_cascade, _uni_field IN\r\n                    SELECT obj_guid, dup_behavior, is_cascade, dup_field\r\n                    FROM reclada.get_duplicates(_attrs, _class_uuid)\r\n                LOOP\r\n                    new_data := _data;\r\n                    CASE _dup_behavior\r\n                        WHEN 'Replace' THEN\r\n                            IF (_is_cascade = true) THEN\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', a)::jsonb)\r\n                                FROM reclada.get_children(_obj_guid) a;\r\n                            ELSE\r\n                                PERFORM reclada_object.delete(format('{"GUID": "%s"}', _obj_guid)::jsonb);\r\n                            END IF;\r\n                        WHEN 'Update' THEN\r\n                            IF new_data->>'GUID' IS NOT NULL THEN\r\n                                PERFORM reclada_object.create_relationship(\r\n                                    _rel_type,\r\n                                    _obj_guid,\r\n                                    (new_data->>'GUID')::uuid,\r\n                                    format('{"dupBehavior": "Update", "isCascade": %s}', _is_cascade::text)::jsonb);\r\n                            END IF;\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            new_data := reclada_object.update_json_by_guid(_obj_guid, new_data);\r\n                            SELECT reclada_object.update(new_data)\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                        WHEN 'Reject' THEN\r\n                            RAISE EXCEPTION 'The object was rejected.';\r\n                        WHEN 'Copy'    THEN\r\n                            _attrs := _attrs || format('{"%s": "%s_%s"}', _uni_field, _attrs->> _uni_field, nextval('reclada.object_id_seq'))::jsonb;\r\n                        WHEN 'Insert' THEN\r\n                            -- DO nothing\r\n                        WHEN 'Merge' THEN\r\n                            IF new_data->>'GUID' IS NOT NULL THEN\r\n                                PERFORM reclada_object.create_relationship(\r\n                                        _rel_type,\r\n                                        _obj_guid,\r\n                                        (new_data->>'GUID')::uuid,\r\n                                        '{"dupBehavior": "Merge"}'::jsonb\r\n                                    );\r\n                            END IF;\r\n                            new_data := reclada_object.remove_parent_guid(new_data, _parent_field);\r\n                            SELECT reclada_object.update(\r\n                                    reclada_object.merge(\r\n                                            new_data - 'class', \r\n                                            data,\r\n                                            schema\r\n                                        ) \r\n                                        || format('{"GUID": "%s"}', _obj_guid)::jsonb \r\n                                        || format('{"transactionID": %s}', tran_id)::jsonb\r\n                                )\r\n                            FROM reclada.v_active_object\r\n                            WHERE obj_id = _obj_guid\r\n                                INTO res;\r\n                            affected := array_append( affected, _obj_guid);\r\n                            skip_insert := true;\r\n                    END CASE;\r\n                END LOOP;\r\n            END IF;\r\n        END IF;\r\n        \r\n        IF (NOT skip_insert) THEN           \r\n            _obj_guid := _data->>'GUID';\r\n            IF EXISTS (\r\n                SELECT FROM reclada.object \r\n                    WHERE guid = _obj_guid\r\n            ) THEN\r\n                perform reclada.raise_exception ('GUID: '||_obj_guid::text||' is duplicate',_f_name);\r\n            END IF;\r\n\r\n            _obj_guid := coalesce(_obj_guid, public.uuid_generate_v4());\r\n\r\n            INSERT INTO reclada.object(GUID,class,attributes,transaction_id, parent_guid)\r\n                SELECT  _obj_guid AS GUID,\r\n                        _class_uuid, \r\n                        _attrs,\r\n                        tran_id,\r\n                        _parent_guid;\r\n\r\n            affected := array_append( affected, _obj_guid);\r\n            inserted := array_append( inserted, _obj_guid);\r\n            PERFORM reclada_object.object_insert\r\n                (\r\n                    _class_name,\r\n                    _obj_guid,\r\n                    _attrs\r\n                );\r\n\r\n            PERFORM reclada_object.refresh_mv(_class_name);\r\n        END IF;\r\n    END LOOP;\r\n\r\n    SELECT array_agg(_affected_objects->>'GUID')\r\n    FROM (\r\n        SELECT jsonb_array_elements(_affected_objects) AS _affected_objects\r\n        FROM (\r\n            SELECT reclada_object.create(data) AS _affected_objects\r\n            FROM reclada.draft\r\n            WHERE parent_guid = ANY (affected)\r\n        ) a\r\n    ) b\r\n    WHERE _affected_objects->>'GUID' IS NOT NULL\r\n        INTO inserted_from_draft;\r\n    affected := affected || inserted_from_draft;    \r\n\r\n    res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (affected)\r\n                )\r\n            )::jsonb;\r\n    notify_res := array_to_json\r\n            (\r\n                array\r\n                (\r\n                    SELECT o.data \r\n                    FROM reclada.v_active_object o\r\n                    WHERE o.obj_id = ANY (inserted)\r\n                )\r\n            )::jsonb; \r\n    \r\n    DELETE FROM reclada.draft \r\n        WHERE guid = ANY (affected);\r\n\r\n    PERFORM reclada.update_unique_object(affected);\r\n        \r\n    PERFORM reclada_notification.send_object_notification\r\n        (\r\n            'create',\r\n            notify_res\r\n        );\r\n    RETURN res;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.delete ;\nCREATE OR REPLACE FUNCTION reclada_object.delete(data jsonb, user_info jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_obj_id              uuid;\r\n    tran_id               bigint;\r\n    _class_name           text;\r\n    _class_name_from_uuid text;\r\n    _uniFields_index_name text;\r\n    _class_uuid           uuid;\r\n    list_id               bigint[];\r\n    _list_class_name      text[];\r\n    _for_class            text;\r\n    _exec_text            text;\r\n    _attrs                jsonb;\r\nBEGIN\r\n\r\n    v_obj_id := data->>'GUID';\r\n    tran_id := (data->>'transactionID')::bigint;\r\n    _class_name := data->>'class';\r\n\r\n    IF (v_obj_id IS NULL AND _class_name IS NULL AND tran_id IS NULl) THEN\r\n        RAISE EXCEPTION 'Could not delete object with no GUID, class and transactionID';\r\n    END IF;\r\n\r\n    _class_uuid := reclada.try_cast_uuid(_class_name);\r\n    IF _class_uuid IS NOT NULL THEN\r\n        SELECT v.for_class \r\n        FROM reclada.v_class_lite v\r\n        WHERE _class_uuid = v.obj_id\r\n            INTO _class_name_from_uuid;\r\n    END IF;\r\n\r\n    WITH t AS\r\n    (    \r\n        UPDATE reclada.object u\r\n            SET status = reclada_object.get_archive_status_obj_id()\r\n            FROM reclada.object o\r\n                LEFT JOIN\r\n                (   SELECT obj_id FROM reclada_object.get_guid_for_class(_class_name)\r\n                    UNION SELECT _class_uuid WHERE _class_uuid IS NOT NULL\r\n                ) c ON o.class = c.obj_id\r\n                WHERE u.id = o.id AND\r\n                (\r\n                    (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id = o.transaction_id)\r\n\r\n                    OR (v_obj_id = o.GUID AND c.obj_id IS NULL AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id = o.class AND tran_id IS NULL)\r\n                    OR (v_obj_id IS NULL AND c.obj_id IS NULL AND tran_id = o.transaction_id)\r\n                )\r\n                    AND o.status != reclada_object.get_archive_status_obj_id()\r\n                    RETURNING o.id\r\n    ) \r\n        SELECT\r\n            array\r\n            (\r\n                SELECT t.id FROM t\r\n            )\r\n        INTO list_id;\r\n\r\n    SELECT array_to_json\r\n    (\r\n        array\r\n        (\r\n            SELECT o.data\r\n            FROM reclada.v_object o\r\n            WHERE o.id IN (SELECT unnest(list_id))\r\n        )\r\n    )::jsonb\r\n    INTO data;\r\n\r\n\r\n    SELECT string_agg('DROP INDEX reclada.'||(attrs->>'name')||';',' ')\r\n        FROM reclada.v_object o\r\n        WHERE o.id IN (SELECT unnest(list_id))\r\n            AND o.class_name = 'Index'\r\n        into _exec_text;\r\n    \r\n    if _exec_text is not null then\r\n        EXECUTE _exec_text;\r\n    end if;\r\n\r\n\r\n    IF (jsonb_array_length(data) <= 1) THEN\r\n        data := data->0;\r\n    END IF;\r\n    \r\n    IF (data IS NULL) THEN\r\n        RAISE EXCEPTION 'Could not delete object, no such GUID';\r\n    END IF;\r\n\r\n    SELECT array_agg(distinct class_name)\r\n    FROM reclada.v_object vo\r\n    WHERE class_name IN ('jsonschema','User','ObjectStatus')\r\n        AND id = ANY(list_id)\r\n        INTO _list_class_name;\r\n    \r\n    PERFORM reclada_object.refresh_mv(cn)\r\n        FROM unnest( _list_class_name ) AS cn;\r\n\r\n    PERFORM reclada_notification.send_object_notification('delete', data);\r\n\r\n    RETURN data;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.object_insert ;\nCREATE OR REPLACE FUNCTION reclada_object.object_insert(_class_name text, _obj_id uuid, attributes jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    _exec_text          text ;\r\n    _where              text ;\r\n    _fields             text ;\r\n\r\n    _pipeline_lite      jsonb;\r\n    _task               jsonb;\r\n    _dataset_guid       uuid ;\r\n    _new_guid           uuid ;\r\n    _pipeline_job_guid  uuid ;\r\n    _stage              text ;\r\n    _uri                text ;\r\n    _dataset2ds_type    text = 'defaultDataSet to DataSource';\r\n    _f_name             text = 'reclada_object.object_insert';\r\nBEGIN\r\n    IF _class_name in ('DataSource','File') THEN\r\n\r\n        _uri := attributes->>'uri';\r\n\r\n        SELECT v.obj_id\r\n            FROM reclada.v_active_object v\r\n            WHERE v.class_name = 'DataSet'\r\n                and v.attrs->>'name' = 'defaultDataSet'\r\n            INTO _dataset_guid;\r\n\r\n        IF (_dataset_guid IS NULL) THEN\r\n            RAISE EXCEPTION 'Can''t found defaultDataSet';\r\n        END IF;\r\n        PERFORM reclada_object.create_relationship(_dataset2ds_type, _obj_id, _dataset_guid);\r\n        IF _uri LIKE '%inbox/jobs/%' THEN\r\n            PERFORM reclada_object.create_job(_uri, _obj_id);\r\n        ELSE\r\n            \r\n            SELECT data \r\n                FROM reclada.v_active_object\r\n                    WHERE class_name = 'PipelineLite'\r\n                        LIMIT 1\r\n                INTO _pipeline_lite;\r\n            _new_guid := public.uuid_generate_v4();\r\n            IF _uri LIKE '%inbox/pipelines/%/%' THEN\r\n                \r\n                _stage := SPLIT_PART(\r\n                                SPLIT_PART(_uri,'inbox/pipelines/',2),\r\n                                '/',\r\n                                2\r\n                            );\r\n                _stage = replace(_stage,'.json','');\r\n                SELECT data \r\n                    FROM reclada.v_active_object o\r\n                        where o.class_name = 'Task'\r\n                            and o.obj_id = (_pipeline_lite #>> ('{attributes,tasks,'||_stage||'}')::text[])::uuid\r\n                    into _task;\r\n                \r\n                _pipeline_job_guid = reclada.try_cast_uuid(\r\n                                        SPLIT_PART(\r\n                                            SPLIT_PART(_uri,'inbox/pipelines/',2),\r\n                                            '/',\r\n                                            1\r\n                                        )\r\n                                    );\r\n                IF _pipeline_job_guid IS NULL THEN\r\n                    perform reclada.raise_exception('PIPELINE_JOB_GUID not found',_f_name);\r\n                END IF;\r\n                \r\n                SELECT  data #>> '{attributes,inputParameters,0,uri}',\r\n                        (data #>> '{attributes,inputParameters,1,dataSourceId}')::uuid\r\n                    FROM reclada.v_active_object o\r\n                        WHERE o.obj_id = _pipeline_job_guid\r\n                    INTO _uri, _obj_id;\r\n\r\n            ELSE\r\n                SELECT data \r\n                    FROM reclada.v_active_object o\r\n                        WHERE o.class_name = 'Task'\r\n                            AND o.obj_id = (_pipeline_lite #>> '{attributes,tasks,0}')::uuid\r\n                    INTO _task;\r\n                IF _task IS NOT NULL THEN\r\n                    _pipeline_job_guid := _new_guid;\r\n                END IF;\r\n            END IF;\r\n            \r\n            PERFORM reclada_object.create_job(\r\n                _uri,\r\n                _obj_id,\r\n                _new_guid,\r\n                _task->>'GUID',\r\n                _task-> 'attributes' ->>'command',\r\n                _pipeline_job_guid\r\n            );\r\n        END IF;\r\n    \r\n    ELSIF _class_name = 'Index' then\r\n        _exec_text := 'DROP INDEX IF EXISTS reclada.#@#@#name#@#@#;\r\n            CREATE INDEX #@#@#name#@#@# ON reclada.object USING #@#@#method#@#@# (#@#@#fields#@#@#) #@#@#where#@#@#;';\r\n        _exec_text := REPLACE(_exec_text, '#@#@#name#@#@#'   , attributes->>'name'                      );\r\n        _exec_text := REPLACE(_exec_text, '#@#@#method#@#@#' , coalesce(attributes->>'method' ,'btree') );\r\n\r\n        _fields :=  (\r\n                        select string_agg(value,'#@#@#sep#@#@#')\r\n                            from jsonb_array_elements_text(attributes->'fields')\r\n                    );\r\n        _where := coalesce(attributes->>'wherePredicate','');\r\n\r\n        if _where != '' then\r\n            if _where = 'IS NOT NULL' then\r\n                _where := REPLACE(_fields,'#@#@#sep#@#@#', ' IS NOT NULL OR ') || ' IS NOT NULL';\r\n            end if;\r\n            _where := 'WHERE ' || _where;\r\n        end if;\r\n\r\n        _fields := REPLACE(_fields,'#@#@#sep#@#@#', ' , ');\r\n\r\n        _exec_text := REPLACE(_exec_text, '#@#@#fields#@#@#' , _fields);\r\n        _exec_text := REPLACE(_exec_text, '#@#@#where#@#@#'  , _where );\r\n        EXECUTE _exec_text;\r\n\r\n    END IF;\r\nEND;\r\n$function$\n;\nDROP function IF EXISTS reclada_object.perform_trigger_function ;\n\nDROP view IF EXISTS reclada.v_db_trigger_function ;\n\nDROP view IF EXISTS reclada.v_trigger ;\n\n	2022-04-05 11:05:31.439851+00
52	51	\N	begin;\nSET CLIENT_ENCODING TO 'utf8';\nCREATE TEMP TABLE var_table\n    (\n        ver int,\n        upgrade_script text,\n        downgrade_script text\n    );\n    \ninsert into var_table(ver)\t\n    select max(ver) + 1\n        from dev.VER;\n        \nselect reclada.raise_exception('Can not apply this version!') \n    where not exists\n    (\n        select ver from var_table where ver = 51 --!!! write current version HERE !!!\n    );\n\nCREATE TEMP TABLE tmp\n(\n    id int GENERATED ALWAYS AS IDENTITY,\n    str text\n);\n--{ logging upgrade script\nCOPY tmp(str) FROM  'up.sql' delimiter E'';\nupdate var_table set upgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\ndelete from tmp;\n--} logging upgrade script\t\n\n--{ create downgrade script\nCOPY tmp(str) FROM  'down.sql' delimiter E'';\nupdate tmp set str = drp.v || scr.v\n    from tmp ttt\n    inner JOIN LATERAL\n    (\n        select substring(ttt.str from 4 for length(ttt.str)-4) as v\n    )  obj_file_name ON TRUE\n    inner JOIN LATERAL\n    (\n        select \tsplit_part(obj_file_name.v,'/',1) typ,\n                split_part(obj_file_name.v,'/',2) nam\n    )  obj ON TRUE\n        inner JOIN LATERAL\n    (\n        select case\n                when obj.typ = 'trigger'\n                    then\n                        (select 'DROP '|| obj.typ || ' IF EXISTS '|| obj.nam ||' ON ' || schm||'.'||tbl ||';' || E'\n'\n                        from (\n                            select n.nspname as schm,\n                                   c.relname as tbl\n                            from pg_trigger t\n                                join pg_class c on c.oid = t.tgrelid\n                                join pg_namespace n on n.oid = c.relnamespace\n                            where t.tgname = obj.nam) o)\n                else 'DROP '||obj.typ|| ' IF EXISTS '|| obj.nam || ' ;' || E'\n'\n                end as v\n    )  drp ON TRUE\n    inner JOIN LATERAL\n    (\n        select case \n                when obj.typ in ('function', 'procedure')\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    SELECT 1 a\n                                        FROM pg_proc p \n                                        join pg_namespace n \n                                            on p.pronamespace = n.oid \n                                            where n.nspname||'.'||p.proname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then (select pg_catalog.pg_get_functiondef(obj.nam::regproc::oid))||';'\n                            else ''\n                        end\n                when obj.typ = 'view'\n                    then\n                        case \n                            when EXISTS\n                                (\n                                    select 1 a \n                                        from pg_views v \n                                            where v.schemaname||'.'||v.viewname = obj.nam\n                                        LIMIT 1\n                                ) \n                                then E'CREATE OR REPLACE VIEW '\n                                        || obj.nam\n                                        || E'\nAS\n'\n                                        || (select pg_get_viewdef(obj.nam, true))\n                            else ''\n                        end\n                when obj.typ = 'trigger'\n                    then\n                        case\n                            when EXISTS\n                                (\n                                    select 1 a\n                                        from pg_trigger v\n                                            where v.tgname = obj.nam\n                                        LIMIT 1\n                                )\n                                then (select pg_catalog.pg_get_triggerdef(oid, true)\n                                        from pg_trigger\n                                        where tgname = obj.nam)||';'\n                            else ''\n                        end\n                else \n                    ttt.str\n            end as v\n    )  scr ON TRUE\n    where ttt.id = tmp.id\n        and tmp.str like '--{%/%}';\n    \nupdate var_table set downgrade_script = array_to_string(ARRAY((select str from tmp order by id asc)),chr(10),'');\t\n--} create downgrade script\ndrop table tmp;\n\n\n--{!!! write upgrare script HERE !!!\n\n--\tyou can use "i 'function/reclada_object.get_schema.sql'"\n--\tto run text script of functions\n \n/*\n    you can use "i 'function/reclada_object.get_schema.sql'"\n    to run text script of functions\n*/\n\nDROP TABLE reclada.unique_object_reclada_object;\nDROP TABLE reclada.unique_object;\nDROP TABLE reclada.field;\nDROP FUNCTION reclada.update_unique_object;\n\ni 'function/reclada_object.create.sql'\ni 'function/reclada_object.update.sql'\ni 'function/reclada_object.list.sql'\ni 'function/reclada_object.get_parent_guid.sql'\n\n\n SELECT reclada.raise_notice('Begin install component db...');\n                SELECT dev.begin_install_component('db','https://gitlab.reclada.com/developers/db.git','d0c102285471903fd5edb48d923cabbb8e7f47f0');\n                \n-- 1\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "tag",\n        "properties": {\n            "name": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 2\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DataSource",\n        "properties": {\n            "name": {"type": "string"},\n            "uri": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 3\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "S3Config",\n        "properties": {\n            "endpointURL": {"type": "string"},\n            "regionName": {"type": "string"},\n            "accessKeyId": {"type": "string"},\n            "secretAccessKey": {"type": "string"},\n            "bucketName": {"type": "string"}\n            },\n        "required": ["accessKeyId", "secretAccessKey", "bucketName"]\n    }\n}'::jsonb);\n--{ 4 DataSet\nSELECT reclada_object.create_subclass('{\n        "class": "RecladaObject",\n        "attributes": {\n            "newClass": "DataSet",\n            "properties": {\n                "name": {"type": "string"},\n                "dataSources": {\n                    "type": "array",\n                    "items": {"type": "string"}\n                }\n            },\n            "required": ["name"]\n        }\n    }'::jsonb);\n\n        SELECT reclada_object.create('{\n            "GUID":"10c400ff-a328-450d-ae07-ce7d427d961c",\n            "class": "DataSet",\n            "attributes": {\n                "name": "defaultDataSet",\n                "dataSources": []\n            }\n        }'::jsonb);\n--} 4 DataSet\n\n-- 5\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Message",\n        "properties": {\n            "channelName": {"type": "string"},\n            "class": {"type": "string"},\n            "event": {\n                "type": "string",\n                "enum": [\n                    "create",\n                    "update",\n                    "list",\n                    "delete"\n                ]\n            },\n            "attributes": {\n                "type": "array", \n                "items": {"type": "string"}\n            }\n        },\n        "required": ["class", "channelName", "event"]\n    }\n}'::jsonb);\n\n--{ 6 Index\nSELECT reclada_object.create_subclass('{\n            "class": "RecladaObject",\n            "attributes": {\n                "newClass": "Index",\n                "properties": {\n                    "name": {"type": "string"},\n                    "method": {\n                        "type": "string",\n                        "enum ": [\n                            "btree", \n                            "hash" , \n                            "gist" , \n                            "gin"\n                        ]\n                    },\n                    "wherePredicate": {\n                        "type": "string"\n                    },\n                    "fields": {\n                        "items": {\n                            "type": "string"\n                        },\n                        "type": "array",\n                        "minContains": 1\n                    }\n                },\n                "required": ["name","fields"]\n            }\n        }'::jsonb);\n\n    select reclada_object.create('{\n            "GUID": "db0873d1-786f-4d5d-b790-5c3b3cd29baf",\n            "class": "Index",\n            "attributes": {\n                "name": "checksum_index_",\n                "fields": ["(attributes ->> ''checksum''::text)"],\n                "method": "hash",\n                "wherePredicate": "((attributes ->> ''checksum''::text) IS NOT NULL)"\n            }\n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db08d53b-c423-4e94-8b14-e73ebe98e991",\n            "class": "Index",\n            "attributes": {\n                "name": "repository_index_",\n                "fields": ["(attributes ->> ''repository''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''repository''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n        "GUID": "db05e253-7954-4610-b094-8f9925ea77b4",\n        "class": "Index",\n        "attributes": {\n                "name": "commithash_index_",\n                "fields": ["(attributes ->> ''commitHash''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''commitHash''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n        "GUID": "db02f980-cd5a-4c1a-9341-7a81713cd9d0",\n        "class": "Index",\n        "attributes": {\n                "name": "fields_index_",\n                "fields": ["(attributes ->> ''fields''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''fields''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0e400b-1da4-4823-bb80-15eb144a1639",\n            "class": "Index",\n            "attributes": {\n                    "name": "caption_index_",\n                    "fields": ["(attributes ->> ''caption''::text)"],\n                    "method": "btree",\n                    "wherePredicate": "((attributes ->> ''caption''::text) IS NOT NULL)"\n                }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db09fafb-91b1-4fe6-8e5c-1cd2d7d9225a",\n            "class": "Index",\n            "attributes": {\n                "name": "type_index",\n                "fields": ["(attributes ->> ''type''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''type''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0118e5-ea34-45dc-b72c-f16f6a628ddb",\n            "class": "Index",\n            "attributes": {\n                "name": "schema_index_",\n                "fields": ["(attributes ->> ''schema''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''schema''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db07c919-5bc0-4fec-961c-f558401d3e71",\n            "class": "Index",\n            "attributes": {\n                "name": "forclass_index_",\n                "fields": ["(attributes ->> ''forclass''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''forclass''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0184b8-556e-4f57-af12-d84066adbe31",\n            "class": "Index",\n            "attributes": {\n                "name": "revision_index",\n                "fields": ["(attributes ->> ''revision''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''revision''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0e22c0-e0d7-4b11-bf25-367a8fbdef83",\n            "class": "Index",\n            "attributes": {\n                "name": "subject_index_",\n                "fields": ["(attributes ->> ''subject''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''subject''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db05c9c7-17ce-4b36-89d7-81b0ddd26a6a",\n            "class": "Index",\n            "attributes": {\n                "name": "class_index_",\n                "fields": ["(attributes ->> ''class''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''class''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0a88c1-ac00-42e5-9caa-6007a1c948c6",\n            "class": "Index",\n                "attributes": {\n                "name": "name_index_",\n                "fields": ["(attributes ->> ''name''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''name''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0fdc46-6479-4d20-bd21-a6330905e45b",\n            "class": "Index",\n            "attributes": {\n                "name": "event_index_",\n                "fields": ["(attributes ->> ''event''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''event''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db02b45a-acfd-4448-a51a-8e7dc35bf3af",\n            "class": "Index",\n            "attributes": {\n                "name": "function_index_",\n                "fields": ["(attributes ->> ''function''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''function''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db0b797a-b287-4282-b0f8-d985c7a439f4",\n            "class": "Index",\n            "attributes": {\n                "name": "login_index_",\n                "fields": ["(attributes ->> ''login''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''login''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n    select reclada_object.create('{\n            "GUID": "db03c715-c0f9-43c3-940a-803aafa513e0",\n            "class": "Index",\n            "attributes": {\n                "name": "object_index_",\n                "fields": ["(attributes ->> ''object''::text)"],\n                "method": "btree",\n                "wherePredicate": "((attributes ->> ''object''::text) IS NOT NULL)"\n            }    \n        }'::jsonb);\n\n--} 6 Index\n\n-- 7\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Component",\n        "properties": {\n            "name": {"type": "string"},\n            "commitHash": {"type": "string"},\n            "repository": {"type": "string"}\n        },\n        "required": ["name","commitHash","repository"]\n    }\n}'::jsonb);\n\n--{ 9 DTOJsonSchema\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DTOJsonSchema",\n        "properties": {\n            "schema": {"type": "object"},\n            "function": {"type": "string"}\n        },\n        "required": ["schema","function"]\n    }\n}'::jsonb);\n\n    SELECT reclada_object.create('{\n            "GUID":"db0bf6f5-7eea-4dbd-9f46-e0535f7fb299",\n            "class": "DTOJsonSchema",\n            "attributes": {\n                "function": "reclada_object.get_query_condition_filter",\n                "schema": {\n                    "id": "expr",\n                    "type": "object",\n                    "required": [\n                        "value",\n                        "operator"\n                    ],\n                    "properties": {\n                        "value": {\n                            "type": "array",\n                            "items": {\n                                "anyOf": [\n                                    {\n                                        "type": "string"\n                                    },\n                                    {\n                                        "type": "null"\n                                    },\n                                    {\n                                        "type": "number"\n                                    },\n                                    {\n                                        "$ref": "expr"\n                                    },\n                                    {\n                                        "type": "boolean"\n                                    },\n                                    {\n                                        "type": "array",\n                                        "items": {\n                                            "anyOf": [\n                                                {\n                                                    "type": "string"\n                                                },\n                                                {\n                                                    "type": "number"\n                                                }\n                                            ]\n                                        }\n                                    }\n                                ]\n                            },\n                            "minItems": 1\n                        },\n                        "operator": {\n                            "type": "string"\n                        }\n                    }\n                }\n            }\n        }'::jsonb);\n\n     SELECT reclada_object.create('{\n            "GUID":"db0ad26e-a522-4907-a41a-a82a916fdcf9",\n            "class": "DTOJsonSchema",\n            "attributes": {\n                "function": "reclada_object.list",\n                "schema": {\n                    "type": "object",\n                    "anyOf": [\n                        {\n                            "required": [\n                                "transactionID"\n                            ]\n                        },\n                        {\n                            "required": [\n                                "class"\n                            ]\n                        },\n                        {\n                            "required": [\n                                "filter"\n                            ]\n                        }\n                    ],\n                    "properties": {\n                        "class": {\n                            "type": "string"\n                        },\n                        "limit": {\n                            "anyOf": [\n                                {\n                                    "enum": [\n                                        "ALL"\n                                    ],\n                                    "type": "string"\n                                },\n                                {\n                                    "type": "integer"\n                                }\n                            ]\n                        },\n                        "filter": {\n                            "type": "object"\n                        },\n                        "offset": {\n                            "type": "integer"\n                        },\n                        "orderBy": {\n                            "type": "array",\n                            "items": {\n                                "type": "object",\n                                "required": [\n                                    "field"\n                                ],\n                                "properties": {\n                                    "field": {\n                                        "type": "string"\n                                    },\n                                    "order": {\n                                        "enum": [\n                                            "ASC",\n                                            "DESC"\n                                        ],\n                                        "type": "string"\n                                    }\n                                }\n                            }\n                        },\n                        "transactionID": {\n                            "type": "integer"\n                        }\n                    }\n                }\n            }\n            \n        }'::jsonb);\n--} 9 DTOJsonSchema\n\n-- 10\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n\n        "dupBehavior": "Replace",\n        "dupChecking": [\n            {\n                "isMandatory": true,\n                "uniFields": [\n                    "uri"\n                ]\n            },\n            {\n                "isMandatory": true,\n                "uniFields": [\n                    "checksum"\n                ]\n            }\n        ],\n        "isCascade": true,\n\n        "newClass": "File",\n        "properties": {\n            "uri": {"type": "string"},\n            "name": {"type": "string"},\n            "mimeType": {"type": "string"},\n            "checksum": {"type": "string"}\n        },\n        "required": ["uri","mimeType","name"]\n    }\n}'::jsonb);\n\n--{ 11 User\nSELECT reclada_object.create_subclass('{\n    "GUID":"db0db7c0-9b25-4af0-8013-d2d98460cfff",\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "User",\n        "properties": {\n            "login": {"type": "string"}\n        },\n        "required": ["login"]\n    }\n}'::jsonb);\n\n    select reclada_object.create('{\n            "GUID": "db0789c1-1b4e-4815-b70c-4ef060e90884",\n            "class": "User",\n            "attributes": {\n                "login": "dev"\n            }\n        }'::jsonb);\n--} 11 User\n\n-- 12\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "ImportInfo",\n        "properties": {\n            "tranID": {"type": "number"},\n            "name": {"type": "string"}\n        },\n        "required": ["tranID","name"]\n    }\n}'::jsonb);\n-- 13\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "Asset",\n        "properties": {\n            "name": {"type": "string"},\n            "uri": {"type": "string"}\n        },\n        "required": ["name"]\n    }\n}'::jsonb);\n-- 14\nSELECT reclada_object.create_subclass('{\n    "class": "Asset",\n    "attributes": {\n        "newClass": "DBAsset"\n    }\n}'::jsonb);\n-- 15\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "revision",\n        "properties": {\n            "branch": {"type": "string"},\n            "user": {"type": "string"},\n            "num": {"type": "number"},\n            "dateTime": {"type": "string"}\n        },\n        "required": ["dateTime"]\n    }\n}'::jsonb);\n\n--{ 16 ObjectDisplay\nSELECT reclada_object.create_subclass('{\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "ObjectDisplay",\n        "$defs": {\n            "displayType": {\n                "properties": {\n                    "orderColumn": {\n                        "items": {\n                            "type": "string"\n                        },\n                        "type": "array"\n                    },\n                    "orderRow": {\n                        "items": {\n                            "patternProperties": {\n                                "^{.*}$": {\n                                    "enum": [\n                                        "ASC",\n                                        "DESC"\n                                    ],\n                                    "type": "string"\n                                }\n                            },\n                            "type": "object"\n                        },\n                        "type": "array"\n                    }\n                },\n                "required": [\n                    "orderColumn",\n                    "orderRow"\n                ],\n                "type": "object"\n            }\n        },\n        "properties": {\n            "caption": {\n                "type": "string"\n            },\n            "card": {\n                "$ref": "#/$defs/displayType"\n            },\n            "classGUID": {\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            },\n            "flat": {\n                "type": "bool"\n            },\n            "list": {\n                "$ref": "#/$defs/displayType"\n            },\n            "preview": {\n                "$ref": "#/$defs/displayType"\n            },\n            "table": {\n                "$ref": "#/$defs/displayType"\n            }\n        },\n        "required": [\n            "classGUID",\n            "caption"\n        ]\n    }\n}'::jsonb);\n\n    SELECT reclada_object.create(('{\n        "GUID": "db09dd42-f2a2-4e34-90ea-a6e5f5ea6dff",\n        "class": "ObjectDisplay",\n        "attributes": {\n            "card": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "list": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "table": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ],\n                "{GUID}:string": {\n                    "width": 250,\n                    "caption": "GUID",\n                    "displayCSS": "GUID"\n                },\n                "{status}:string": {\n                    "width": 250,\n                    "caption": "Status",\n                    "displayCSS": "status"\n                },\n                "{createdTime}:string": {\n                    "width": 250,\n                    "caption": "Created time",\n                    "displayCSS": "createdTime"\n                },\n                "{transactionID}:number": {\n                    "width": 250,\n                    "caption": "Transaction",\n                    "displayCSS": "transactionID"\n                },\n                "{attributes,tags}:array": {\n                    "items": {\n                        "class": "e12e729b-ac44-45bc-8271-9f0c6d4fa27b",\n                        "behavior": "preview",\n                        "displayCSS": "link"\n                    },\n                    "width": 250,\n                    "caption": "Tags",\n                    "displayCSS": "arrayLink"\n                },\n                "{attributes,name}:string": {\n                    "width": 250,\n                    "caption": "File name",\n                    "behavior": "preview",\n                    "displayCSS": "name"\n                },\n                "{attributes,checksum}:string": {\n                    "width": 250,\n                    "caption": "Checksum",\n                    "displayCSS": "checksum"\n                },\n                "{attributes,mimeType}:string": {\n                    "width": 250,\n                    "caption": "Mime type",\n                    "displayCSS": "mimeType"\n                }\n            },\n            "caption": "Files",\n            "preview": {\n                "orderRow": [\n                    {\n                        "{attributes,name}:string": "ASC"\n                    },\n                    {\n                        "{attributes,mimeType}:string": "DESC"\n                    }\n                ],\n                "orderColumn": [\n                    "{attributes,name}:string",\n                    "{attributes,mimeType}:string",\n                    "{attributes,tags}:array",\n                    "{status}:string",\n                    "{createdTime}:string",\n                    "{transactionID}:number"\n                ]\n            },\n            "classGUID": "'|| (SELECT obj_id\n                                FROM reclada.v_class\n                                    WHERE for_class = 'File'\n                                    ORDER BY ID DESC\n                                    LIMIT 1 ) ||'"\n        }\n    }')::jsonb);\n\n--} 16 ObjectDisplay\n\n--{ 17 View\nSELECT reclada_object.create_subclass('{\n        "GUID":"db09dcaa-fc90-4760-af68-f855cbe9c2b0",\n        "class": "RecladaObject",\n        "attributes": {\n            "newClass": "View",\n            "properties": {\n                "name": {"type": "string"},\n                "query": {"type": "string"}\n            },\n            "required": ["name","query"]\n        }\n    }'::jsonb);\n--} 17 View\n\n--{ 18 Function\nSELECT reclada_object.create_subclass('{\n        "GUID":"db0d8ccd-a06e-46c3-9836-a8b4b68f3cd4",\n        "class": "RecladaObject",\n        "attributes": {\n            "newClass": "Function",\n            "$defs": {\n                "declare":{\n                    "type":"array",\n                    "items": {\n                        "type": "object",\n                        "properties":{\n                            "name":{"type": "string"},\n                            "type":{\n                                "type": "string",\n                                "enum": [\n                                    "uuid" ,\n                                    "jsonb",\n                                    "text" ,\n                                    "bigint"\n                                ]\n                            }\n                        },\n                        "required": ["name","type"]\n                    }\n                }\n            },\n            "properties": {\n                "name": {"type": "string"},\n                "parameters": { "$ref": "#/$defs/declare" },\n                "returns": {\n                    "type": "string",\n                    "enum": [\n                        "void",\n                        "uuid" ,\n                        "jsonb",\n                        "text" ,\n                        "bigint"\n                    ]\n                },\n                "declare": { "$ref": "#/$defs/declare" },\n                "body": {"type": "string"}\n            },\n            "required": ["name","returns","body"]\n        }\n    }'::jsonb);\n--} 18 Function\n\n--{ 19 DBTriggerFunction\nSELECT reclada_object.create_subclass('{\n        "GUID":"db0635d4-33be-4b5c-8af4-c90038665b7d",\n        "class": "Function",\n        "attributes": {\n            "newClass": "DBTriggerFunction",\n            "properties": {\n                "parameters": {\n                    "type":"array",\n                    "minItems": 1,\n                    "maxItems": 1,\n                    "items": {\n                        "type": "object",\n                        "properties":{\n                            "name":{\n                                "type": "string", \n                                "enum": ["object_id"]\n                            },\n                            "type":{\n                                "type": "string",\n                                "enum": ["bigint"]\n                            }\n                        },\n                        "required": ["name","type"]\n                    }\n                },\n                "returns": {\n                    "type": "string",\n                    "enum": [\n                        "void"]\n                }\n            },\n            "required": ["parameters"]\n        }\n    }'::jsonb);\n--} 19 DBTriggerFunction\n\n\n--{ 20 Trigger\nSELECT reclada_object.create_subclass('{\n    "GUID":"db05bc71-4f3c-4276-9b97-c9e83f21c813",\n    "class": "RecladaObject",\n    "attributes": {\n        "newClass": "DBTrigger",\n        "properties": {\n            "name": {"type": "string"},\n            "action": {\n                "type": "string",\n                "enum": [\n                    "insert",\n                    "delete"\n                ]\n            },\n            "forClasses": {\n                "type": "array",\n                "items": {"type": "string"}\n            },\n            "function":{\n                "type": "string",\n                "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"\n            }\n        },\n        "required": ["name","action","forClasses","function"]\n    }\n }'::jsonb);\n--} 20 Trigger\n                SELECT dev.finish_install_component();\n\n--}!!! write upgrare script HERE !!!\n\ninsert into dev.ver(ver,upgrade_script,downgrade_script)\n    select ver, upgrade_script, downgrade_script\n        from var_table;\n\n--{ testing downgrade script\nSAVEPOINT sp;\n    select dev.downgrade_version();\nROLLBACK TO sp;\n--} testing downgrade script\n\nselect reclada.raise_notice('OK, current version: ' \n                            || (select ver from var_table)::text\n                          );\ndrop table var_table;\n\ncommit;	-- you can use "--{function/reclada_object.get_schema}"\n-- to add current version of object to downgrade script\n\nselect reclada.raise_exception('downgrade is not allowed');	2022-04-29 06:23:59.732687+00
\.


--
-- Data for Name: auth_setting; Type: TABLE DATA; Schema: reclada; Owner: -
--

COPY reclada.auth_setting (oidc_url, oidc_client_id, oidc_redirect_url, jwk) FROM stdin;
\.


--
-- Data for Name: draft; Type: TABLE DATA; Schema: reclada; Owner: -
--

COPY reclada.draft (id, guid, user_guid, data, parent_guid) FROM stdin;
\.


--
-- Data for Name: object; Type: TABLE DATA; Schema: reclada; Owner: -
--

COPY reclada.object (id, status, attributes, transaction_id, created_time, created_by, class, guid, parent_guid) FROM stdin;
22	3748b1f7-b674-47ca-9ded-d011b16bbf7b	{"caption": "active"}	9	2021-09-22 14:50:50.411942+00	16d789c1-1b4e-4815-b70c-4ef060e90884	14af3113-18b5-4da8-af57-bdf37a6693aa	3748b1f7-b674-47ca-9ded-d011b16bbf7b	\N
24	3748b1f7-b674-47ca-9ded-d011b16bbf7b	{"caption": "archive"}	53	2021-09-22 14:50:50.411942+00	16d789c1-1b4e-4815-b70c-4ef060e90884	14af3113-18b5-4da8-af57-bdf37a6693aa	9dc0a032-90d6-4638-956e-9cd64cd2900c	\N
2	3748b1f7-b674-47ca-9ded-d011b16bbf7b	{"schema": {"type": "object", "required": ["forClass", "schema"], "properties": {"schema": {"type": "object"}, "forClass": {"type": "string"}, "parentList": {"type": "array", "items": {"type": "string"}}}}, "version": 1, "forClass": "jsonschema", "parentList": []}	32	2021-09-22 14:50:50.411942+00	16d789c1-1b4e-4815-b70c-4ef060e90884	5362d59b-82a1-4c7c-8ec3-07c256009fb0	5362d59b-82a1-4c7c-8ec3-07c256009fb0	\N
50	3748b1f7-b674-47ca-9ded-d011b16bbf7b	{"schema": {"type": "object", "required": ["subject", "type", "object"], "properties": {"tags": {"type": "array", "items": {"type": "string"}}, "type": {"type": "string", "enum ": ["params"]}, "object": {"type": "string", "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"}, "disable": {"type": "boolean", "default": false}, "subject": {"type": "string", "pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}"}}}, "version": "1", "forClass": "Relationship", "parentList": []}	27	2021-09-22 14:53:04.158111+00	16d789c1-1b4e-4815-b70c-4ef060e90884	5362d59b-82a1-4c7c-8ec3-07c256009fb0	2d054574-8f7a-4a9a-a3b3-0400ad9d0489	\N
4	3748b1f7-b674-47ca-9ded-d011b16bbf7b	{"schema": {"type": "object", "required": [], "properties": {"tags": {"type": "array", "items": {"type": "string"}}, "disable": {"type": "boolean", "default": false}}}, "version": 1, "forClass": "RecladaObject", "parentList": []}	31	2021-09-22 14:50:50.411942+00	16d789c1-1b4e-4815-b70c-4ef060e90884	5362d59b-82a1-4c7c-8ec3-07c256009fb0	ab9ab26c-8902-43dd-9f1a-743b14a89825	\N
20	3748b1f7-b674-47ca-9ded-d011b16bbf7b	{"schema": {"type": "object", "required": ["caption"], "properties": {"tags": {"type": "array", "items": {"type": "string"}}, "caption": {"type": "string"}, "disable": {"type": "boolean", "default": false}}}, "version": 1, "forClass": "ObjectStatus", "parentList": []}	11	2021-09-22 14:50:50.411942+00	16d789c1-1b4e-4815-b70c-4ef060e90884	5362d59b-82a1-4c7c-8ec3-07c256009fb0	14af3113-18b5-4da8-af57-bdf37a6693aa	\N
\.


--
-- Data for Name: staging; Type: TABLE DATA; Schema: reclada; Owner: -
--

COPY reclada.staging (data) FROM stdin;
\.


--
-- Name: component_object_id_seq; Type: SEQUENCE SET; Schema: dev; Owner: -
--

SELECT pg_catalog.setval('dev.component_object_id_seq', 470, true);


--
-- Name: meta_data_id_seq; Type: SEQUENCE SET; Schema: dev; Owner: -
--

SELECT pg_catalog.setval('dev.meta_data_id_seq', 126, true);


--
-- Name: t_dbg_id_seq; Type: SEQUENCE SET; Schema: dev; Owner: -
--

SELECT pg_catalog.setval('dev.t_dbg_id_seq', 24, true);


--
-- Name: ver_id_seq; Type: SEQUENCE SET; Schema: dev; Owner: -
--

SELECT pg_catalog.setval('dev.ver_id_seq', 52, true);


--
-- Name: draft_id_seq; Type: SEQUENCE SET; Schema: reclada; Owner: -
--

SELECT pg_catalog.setval('reclada.draft_id_seq', 1, false);


--
-- Name: object_id_seq; Type: SEQUENCE SET; Schema: reclada; Owner: -
--

SELECT pg_catalog.setval('reclada.object_id_seq', 982, true);


--
-- Name: transaction_id; Type: SEQUENCE SET; Schema: reclada; Owner: -
--

SELECT pg_catalog.setval('reclada.transaction_id', 547, true);


--
-- Name: component_object component_object_pkey; Type: CONSTRAINT; Schema: dev; Owner: -
--

ALTER TABLE ONLY dev.component_object
    ADD CONSTRAINT component_object_pkey PRIMARY KEY (id);


--
-- Name: meta_data meta_data_id_key; Type: CONSTRAINT; Schema: dev; Owner: -
--

ALTER TABLE ONLY dev.meta_data
    ADD CONSTRAINT meta_data_id_key UNIQUE (id);


--
-- Name: object object_pkey; Type: CONSTRAINT; Schema: reclada; Owner: -
--

ALTER TABLE ONLY reclada.object
    ADD CONSTRAINT object_pkey PRIMARY KEY (id);


--
-- Name: class_index; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX class_index ON reclada.object USING btree (class);


--
-- Name: colspan_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX colspan_index_v47 ON reclada.object USING btree (((attributes -> 'colspan'::text))) WHERE ((attributes -> 'colspan'::text) IS NOT NULL);


--
-- Name: column_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX column_index_v47 ON reclada.object USING btree (((attributes -> 'column'::text))) WHERE ((attributes -> 'column'::text) IS NOT NULL);


--
-- Name: environment_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX environment_index_v47 ON reclada.object USING hash (((attributes -> 'environment'::text))) WHERE ((attributes -> 'environment'::text) IS NOT NULL);


--
-- Name: event_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX event_index_v47 ON reclada.object USING hash (((attributes -> 'event'::text))) WHERE ((attributes -> 'event'::text) IS NOT NULL);


--
-- Name: guid_index; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX guid_index ON reclada.object USING hash (guid);


--
-- Name: height_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX height_index_v47 ON reclada.object USING btree (((attributes -> 'height'::text))) WHERE ((attributes -> 'height'::text) IS NOT NULL);


--
-- Name: left_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX left_index_v47 ON reclada.object USING btree (((attributes -> 'left'::text))) WHERE ((attributes -> 'left'::text) IS NOT NULL);


--
-- Name: nexttask_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX nexttask_index_v47 ON reclada.object USING hash (((attributes -> 'nexttask'::text))) WHERE ((attributes -> 'nexttask'::text) IS NOT NULL);


--
-- Name: number_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX number_index_v47 ON reclada.object USING btree (((attributes -> 'number'::text))) WHERE ((attributes -> 'number'::text) IS NOT NULL);


--
-- Name: object_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX object_index_v47 ON reclada.object USING hash (((attributes -> 'object'::text))) WHERE ((attributes -> 'object'::text) IS NOT NULL);


--
-- Name: parent_guid_index; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX parent_guid_index ON reclada.object USING hash (parent_guid) WHERE (parent_guid IS NOT NULL);


--
-- Name: relationship_type_subject_object_index; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX relationship_type_subject_object_index ON reclada.object USING btree (((attributes ->> 'type'::text)), (((attributes ->> 'subject'::text))::uuid), status, (((attributes ->> 'object'::text))::uuid)) WHERE (((attributes ->> 'subject'::text) IS NOT NULL) AND ((attributes ->> 'object'::text) IS NOT NULL));


--
-- Name: row_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX row_index_v47 ON reclada.object USING btree (((attributes -> 'row'::text))) WHERE ((attributes -> 'row'::text) IS NOT NULL);


--
-- Name: rowspan_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX rowspan_index_v47 ON reclada.object USING btree (((attributes -> 'rowspan'::text))) WHERE ((attributes -> 'rowspan'::text) IS NOT NULL);


--
-- Name: runner_type_index; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX runner_type_index ON reclada.object USING btree (((attributes ->> 'type'::text))) WHERE ((attributes ->> 'type'::text) IS NOT NULL);


--
-- Name: subject_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX subject_index_v47 ON reclada.object USING hash (((attributes -> 'subject'::text))) WHERE ((attributes -> 'subject'::text) IS NOT NULL);


--
-- Name: task_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX task_index_v47 ON reclada.object USING hash (((attributes -> 'task'::text))) WHERE ((attributes -> 'task'::text) IS NOT NULL);


--
-- Name: tasks_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX tasks_index_v47 ON reclada.object USING gin (((attributes -> 'tasks'::text))) WHERE ((attributes -> 'tasks'::text) IS NOT NULL);


--
-- Name: top_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX top_index_v47 ON reclada.object USING btree (((attributes -> 'top'::text))) WHERE ((attributes -> 'top'::text) IS NOT NULL);


--
-- Name: tranid_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX tranid_index_v47 ON reclada.object USING btree (((attributes -> 'tranid'::text))) WHERE ((attributes -> 'tranid'::text) IS NOT NULL);


--
-- Name: transaction_id_index; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX transaction_id_index ON reclada.object USING btree (transaction_id);


--
-- Name: triggers_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX triggers_index_v47 ON reclada.object USING gin (((attributes -> 'triggers'::text))) WHERE ((attributes -> 'triggers'::text) IS NOT NULL);


--
-- Name: width_index_v47; Type: INDEX; Schema: reclada; Owner: -
--

CREATE INDEX width_index_v47 ON reclada.object USING btree (((attributes -> 'width'::text))) WHERE ((attributes -> 'width'::text) IS NOT NULL);


--
-- Name: staging load_staging; Type: TRIGGER; Schema: reclada; Owner: -
--

CREATE TRIGGER load_staging AFTER INSERT ON reclada.staging REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE FUNCTION reclada.load_staging();


--
-- Name: FUNCTION invoke(function_name aws_commons._lambda_function_arn_1, payload json, invocation_type text, log_type text, context json, qualifier character varying, OUT status_code integer, OUT payload json, OUT executed_version text, OUT log_result text); Type: ACL; Schema: aws_lambda; Owner: -
--



--
-- Name: FUNCTION invoke(function_name aws_commons._lambda_function_arn_1, payload jsonb, invocation_type text, log_type text, context jsonb, qualifier character varying, OUT status_code integer, OUT payload jsonb, OUT executed_version text, OUT log_result text); Type: ACL; Schema: aws_lambda; Owner: -
--



--
-- Name: FUNCTION invoke(function_name text, payload json, region text, invocation_type text, log_type text, context json, qualifier character varying, OUT status_code integer, OUT payload json, OUT executed_version text, OUT log_result text); Type: ACL; Schema: aws_lambda; Owner: -
--



--
-- Name: FUNCTION invoke(function_name text, payload jsonb, region text, invocation_type text, log_type text, context jsonb, qualifier character varying, OUT status_code integer, OUT payload jsonb, OUT executed_version text, OUT log_result text); Type: ACL; Schema: aws_lambda; Owner: -
--



--
-- Name: v_class_lite; Type: MATERIALIZED VIEW DATA; Schema: reclada; Owner: -
--

REFRESH MATERIALIZED VIEW reclada.v_class_lite;


--
-- Name: v_object_status; Type: MATERIALIZED VIEW DATA; Schema: reclada; Owner: -
--

REFRESH MATERIALIZED VIEW reclada.v_object_status;


--
-- Name: v_object_unifields; Type: MATERIALIZED VIEW DATA; Schema: reclada; Owner: -
--

REFRESH MATERIALIZED VIEW reclada.v_object_unifields;


--
-- Name: v_user; Type: MATERIALIZED VIEW DATA; Schema: reclada; Owner: -
--

REFRESH MATERIALIZED VIEW reclada.v_user;


--
-- PostgreSQL database dump complete
--

